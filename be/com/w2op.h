
/* 
   Copyright (C) 2002-2006 Tensilica, Inc.  All Rights Reserved.
   Revised to support Tensilica processors and to improve overall performance
 */

/*

  Copyright (C) 2000 Silicon Graphics, Inc.  All Rights Reserved.

  This program is free software; you can redistribute it and/or modify it
  under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it would be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

  Further, this software is distributed without any warranty that it is
  free of the rightful claim of any third person regarding infringement 
  or the like.  Any license provided herein, whether implied or 
  otherwise, applies only to this software file.  Patent licenses, if 
  any, provided herein do not apply to combinations of this program with 
  other software, or any other product whatsoever.  

  You should have received a copy of the GNU General Public License along
  with this program; if not, write the Free Software Foundation, Inc., 59
  Temple Place - Suite 330, Boston MA 02111-1307, USA.

  Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
  Mountain View, CA 94043, or:

  http://www.sgi.com

  For further information regarding this notice, see:

  http://oss.sgi.com/projects/GenInfo/NoticeExplan

*/


#ifndef	w2op_INCLUDED
#define	w2op_INCLUDED

#include "libti.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Given a WHIRL opcode, return the corresponding TOP.
 * This will only return machine ops, 
 * else TOP_UNDEFINED if not an exact correspondence.
 */
extern TOP OPCODE_To_TOP (OPCODE opcode);

/* Given a WHIRL node, return the corresponding TOP. 
 * This will only return machine ops, 
 * else TOP_UNDEFINED if not an exact correspondence.
 * (this handles more cases than OPCODE_To_TOP, cause it can look at kids).
 */
extern TOP WHIRL_To_TOP (WN *wn);

/* return whether MPY, DIV, or REM will be translated into shifts and adds */
extern BOOL Can_Do_Fast_Multiply (TYPE_ID mtype, INT64 val);
extern BOOL Can_Do_Fast_Divide (TYPE_ID mtype, INT64 val);
extern BOOL Can_Do_Fast_Remainder (TYPE_ID mtype, INT64 val);

/* When trying to convert a multiply or divide operation into a series
 * of shifts/adds/subtracts, there is some operation limit at which
 * the conversion is not profitable.  Return that limit.  */
extern INT Multiply_Limit (WN * tree);
extern INT Divide_Limit (void);

/* Initialize/Finalize for offset canonicalization. */  
extern void Init_Offset_Canonicalization (WN *func, MEM_POOL *pool,
					  BOOL have_do_while, BOOL trace);
extern void Finalize_Offset_Canonicalization (void);

/* Canonicalize 'offset' by dividing it into a base portion and an
   offset portion. Return the base portion. */
extern INT64 Canonicalize_Memory_Offset (WN *wn, WN *parent, INT64 offset);

/* Return true if 'offset' can not be encoded in a memory
   instruction. */
extern BOOL Memory_Offset_Must_Split (TYPE_ID type, INT64 offset, WN *parent, WN *wn);

/* Return the portion of 'offset' that cannot be encoded in a memory
   instruction accessing an object of type 'type'. */
extern INT32 Memory_Offset_Hi (TYPE_ID type, INT64 offset, WN *parent, WN *wn);

/* Return the portion of 'offset' that can be encoded in a memory
   instruction accessing an object of type 'type'. */
extern INT32 Memory_Offset_Lo (TYPE_ID type, INT64 offset, WN *parent, WN *wn);

  
/* Return whether or not the immediate specified by <val> would be a valid
 * operand of the machine instruction generated by the whirl operator
 * <opr> with the immediate as the <whichkid> whirl operand.
 * The datatype of the operator is specified by <dtype> and if the
 * operation is an STID, <stid_st> specifies the symbol being stored to.
 */
extern BOOL Can_Be_Immediate(OPERATOR opr,
			     INT64 val,
			     TYPE_ID dtype,
			     INT whichkid,
			     ST *stid_st);

/* Mark OPR_MPY nodes that can be implemented with a 16-bit
   multiply. */
extern void Find_Mul16 (WN *func, struct DU_MANAGER *du_mgr, 
				struct ALIAS_MANAGER *alias_mgr);

/* Target specific aliasing analysis. Return TRUE if access to 'st1'
   at 'offset1' of size 'size1' may overlap with access to 'st2' at
   'offset2' of size 'size2'. This routine should only check for
   target specific aliasing that is not detected by the common alias
   routines. */
extern BOOL Target_Analyze_Alias (ST *st1, INT32 offset1, INT32 size1,
				  ST *st2, INT32 offset2, INT32 size2);
  
  
/* determine speculative execution taking into account eagerness level
 *
 */
extern BOOL TOP_Can_Be_Speculative (TOP opcode);
extern BOOL WN_Can_Be_Speculative (WN *wn, struct ALIAS_MANAGER *alias);
extern BOOL WN_Expr_Can_Be_Speculative (WN *wn, struct ALIAS_MANAGER *alias);
extern BOOL OPCODE_Can_Be_Speculative(OPCODE opcode);

#ifdef __cplusplus
}
#endif
#endif /* w2op_INCLUDED */
