#define __OLIVE_HEADER_INCLUDED__
/* line 1 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

/*

  Copyright (C) 2003-2007 Tensilica, Inc.  All Rights Reserved.

  This program is free software; you can redistribute it and/or modify it
  under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it would be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

  Further, this software is distributed without any warranty that it is
  free of the rightful claim of any third person regarding infringement 
  or the like.  Any license provided herein, whether implied or 
  otherwise, applies only to this software file.  Patent licenses, if 
  any, provided herein do not apply to combinations of this program with 
  other software, or any other product whatsoever.  

  You should have received a copy of the GNU General Public License along
  with this program; if not, write the Free Software Foundation, Inc., 59
  Temple Place - Suite 330, Boston MA 02111-1307, USA.


  isel.cxx and isel.h were generated by Olive from input files developed
  by Tensilica, Inc. Olive is a code-generator generator copyright 1994 by 
  Synopsys, Inc. All bug reports regarding isel.cxx or isel.h should be
  reported to Tensilica, Inc.

  For more information regarding Olive itself, contact Synopsis, Inc.

*/

#include "defs.h"

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <alloca.h>

#include <elf.h>
#include <vector>
#include "em_elf.h"
#include "erglob.h"
#include "ercg.h"
#include "tracing.h"
#include "config.h"
#include "config_targ_options.h"
#include "config_debug.h"
#include "config_opt.h"
#include "xstats.h"
#include "topcode.h"
#include "tn.h"
#include "cg_flags.h"
#include "targ_isa_lits.h"
#include "op.h"
#include "stblock.h"
#include "data_layout.h"
#include "strtab.h"
#include "stab.h"
#include "cg.h"
#include "cgexp.h"
#include "cgexp_internals.h"
#include "whirl2ops.h"
#include "const.h"
#include "targ_const.h"
#include "targ_const_private.h"
#include "label_util.h"
#include "cxx_hash.h"
#include "cg_tie.h"
#include "intrn_info.h"
#include "util.h"
#include "libti.h"
#include "wn_util.h"
#include "be_util.h"
  
extern WN_MAP ISEL_State_Map;
 
#define ABI_CALL (Target_ABI == ABI_WINDOWED ? TOP_call8 : TOP_call0)
#define ABI_ICALL (Target_ABI == ABI_WINDOWED ? TOP_callx8 : TOP_callx0)

//
// Define two pools.  One ISEL_Mem_Pool is used for memory allocated during
// the matching of one tree.  The other ISEL_Map_Pool is used to hold the map
// that associates state structures with a WN node.
//
extern MEM_POOL ISEL_Mem_Pool, ISEL_Map_Pool;
extern void fdump_tree(FILE *, WN *);

// A structure to represent a pair of preg as TNs.  Note that
// the register pair should differ by one.
struct preg_pair {
  TN *lo;
  TN *hi;
};

typedef WN * NODEPTR;
#define GET_KIDS(p)	(&(WN_kid0(p)))
#define PANIC printf
#define DEFAULT_COST	break
#define NO_MATCH        return(0)
#define NO_ACTION(x)
#define OP_LABEL(p) (WN_opcode(p))

//#define ALLOC(t,n) (TYPE_MEM_POOL_ALLOC_N(t,&ISEL_Mem_Pool,n))
typedef struct COST {
    int cost;
} COST;
#define COST_LESS(a,b) ((a).cost < (b).cost)

static COST COST_INFINITY = { 32767 };
static COST COST_ZERO     = { 0 };

#define IS_POWER_OF_2(val)      ((val != 0) && ((val & (val-1)) == 0))
#define SWAP_TNS(a, b) (_swap_tmp = a, a = b, b = _swap_tmp)
static TN *_swap_tmp;
  
static int _ern = 0;

static void ISEL_trace(NODEPTR, int, int, int);
static void asm_action_callback (WN *n, TN *result, OPS *ops);
static void Generate_ICall( WN *n, TOP top, OPS *ops );
static BOOL Label_ICall ( WN *n, COST *cost);
static BOOL MUL16_arg_cost (WN *result_wn, WN *left, WN *right,
                            COST *new_cost, int cost_offset);
static TN *Generate_MUL16(TYPE_ID rtype, TN *result, WN *result_wn,
                          char *instruction_name, WN *left, WN *right, OPS *ops);
static BOOL MAC16_arg_cost(WN *left, WN *right, COST *new_cost, int cost_offset);
static void Generate_MAC16(const char *opcode, WN *left, WN *right, OPS *ops);
static BOOL Label_Asm ( WN *n, COST *cost);
static BOOL Get_Extui_Shift_Mask (UINT64 val, INT32 *shift =NULL, INT32 *size =NULL);
static BOOL Get_Bbci_Bbsi_Immediate (INT64 val, INT32 *imm =NULL);
static const char* find_nonterm_name(const char* tie_proto_type);
static const char* find_nonterm_name(TYPE_ID mtype);
static TN* action_by_type(WN* n, TYPE_ID mtype, TN *result, OPS* ops);
static TN* action_by_type(WN* n, const char* tie_proto_type, TN *result, OPS* ops);
static WN *preg_home (WN *ldid);
static WN *preg_equivalent_literal (WN *ldid);


static void print_sym( ST *sym, INT64 ofst )
  {
    ST *base_sym;
    INT64 base_ofst;

    putc('<',stderr);
    fprintf(stderr,"%s+%ld", &Str_Table[sym->u1.name_idx], ofst );
    Base_Symbol_And_Offset_For_Addressing (sym, ofst, &base_sym, &base_ofst);
    if( base_sym != sym )
      fprintf(stderr,"=%s+%ld", &Str_Table[base_sym->u1.name_idx], base_ofst );
    putc('>',stderr);
  }

/* Predicates */

static bool is_tie_intrinsic_call(WN *n)
  {
    return INTRN_is_tie_intrinsic(WN_intrinsic(n));
  }

static bool is_tie_tn(WN *n)
  {
    if( WN_operator(n)==OPR_TN &&
	MTYPE_is_tie(TN_mtype(WN_tn(n))))
      return true;
    return false;
  }

static bool is_xtbool_tn(WN *n)
  {
    if( WN_operator(n)==OPR_TN &&
	MTYPE_is_xtbool(TN_mtype(WN_tn(n))))
      return true;
    return false;
  }

static bool is_preg(WN *n)
  {
    if (WN_operator(n) == OPR_TN )
      return TN_is_register(WN_tn(n));
    else if (WN_class(n) == CLASS_PREG)
      return true;
    else if ((WN_operator(n) == OPR_LDID) || (WN_operator(n) == OPR_STID))
      return ST_assigned_to_dedicated_preg(WN_st(n));
    return false;
  }

static bool is_float_tn(WN *n)
  {
    Is_True(is_preg(n), ("is_float_tn requires is_preg"));
    if (!xt_hard_float)
      return false;
    if (WN_operator(n) == OPR_TN) 
      return MTYPE_is_float(TN_mtype(WN_tn(n)));
    if (WN_class(n) == CLASS_PREG)
      return !Preg_Is_Dedicated(WN_offset(n)) || 
              Preg_Is_Dedicated_Float(WN_offset(n));
    return !ST_assigned_to_dedicated_preg(WN_st(n)) ||
            Preg_Is_Dedicated_Float(Find_PREG_For_Symbol(WN_st(n)));
  }

static bool hw_fp(WN *n)
  {
    return xt_hard_float;
  }

static bool hw_fp_recip(WN *n)
  {
    return xt_hard_float_recip;
  }

static bool hw_fp_rsqrt(WN *n)
  {
    return xt_hard_float_rsqrt;
  }

static bool is_const(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_class(s)==CLASS_CONST;
  }

static bool is_var(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_class(s)==CLASS_VAR;
  }

static bool is_auto(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_storage_class(*s)==SCLASS_AUTO;
  }

static bool is_formal(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_storage_class(*s)==SCLASS_FORMAL;
  }

static bool is_formal_ref(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_storage_class(*s)==SCLASS_FORMAL_REF;
  }

static bool is_auto_or_formal(WN *n)
  {
    return is_auto(n) || is_formal(n) || is_formal_ref(n);
  }

static bool use_conservative_addressing (ST *st)
  {
    return(st &&
	   ((ST_sclass(st) == SCLASS_FORMAL) ||
	    (ST_sclass(st) == SCLASS_FORMAL_REF)));
  }

static bool allowed_shiftadd_immed (WN *n)
  {
    if (!xt_addx)
      return FALSE;
    return((WN_operator(n) == OPR_INTCONST) &&
	   (WN_const_val(n) >= 0) &&
	   (WN_const_val(n) <= 3));
  }
 
static bool is_nop_cvtl (WN *n)
  {
    if (WN_operator(n) == OPR_CVTL)
    {
      WN *kid0 = WN_kid0(n);
      if (WN_operator(kid0) == OPR_LDID && !is_preg(kid0))
      {
	if ((WN_rtype(kid0) == WN_rtype(n)) &&
	    (MTYPE_bit_size(WN_desc(kid0)) == WN_cvtl_bits(n)))
	  return TRUE;

#if 0
	/* peng says we can't assume the rtype and desc indicated by
           the home location are valid over the entire live-range of
           the preg. */
	WN *home = preg_home(kid0);
	if (home &&
	    (WN_operator(home) == OPR_LDID) &&
	    (WN_rtype(home) == WN_rtype(n)) &&
	    (MTYPE_bit_size(WN_desc(home)) == WN_cvtl_bits(n)))
	  return TRUE;
#endif
      } else if (WN_operator(kid0) == OPR_INTRINSIC_OP &&
		 INTRN_is_tie_intrinsic(WN_intrinsic(kid0))) {
	  TIE_MACRO_ID tie_macro_id =
		Intrinsic_To_Tie_Macro_Id(WN_intrinsic(kid0));
	  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
	  if ((WN_rtype(kid0) == WN_rtype(n)) &&
	      (MTYPE_bit_size(
		tie_info->mtype_id(tie_macro->return_type_name())) ==
	       WN_cvtl_bits(n)))
	    return TRUE;
      }
    }

    return FALSE;
  }
 
/* Predicates for allowed immediates. */ 

static bool tn_has_value (TN *tn, INT32 val)
  {
    return TN_has_value(tn) && (TN_value(tn) == val);
  }
 
static bool tn_immediate_value (TN *tn, INT64 *val, bool allow_symbol_tn)
  {
    if (TN_is_constant(tn))
      {
	if (TN_has_value(tn))
	  {
	    *val = TN_value(tn);
	    return true;
	  }
	else if (allow_symbol_tn && TN_is_symbol(tn))
	  {
	    ST *st = TN_var(tn);
	    ST *base_st;
	    INT64 base_ofst;
	    
	    *val = TN_value(tn);
	    
	    Base_Symbol_And_Offset(st, &base_st, &base_ofst);
	    if (base_st == SP_Sym || base_st == FP_Sym)
	      {
		*val += base_ofst;
	      }
	    
	    return true;
	  }
      }

    return false;
  }

static bool wn_immediate_value (WN *n, ISA_LITCLASS lc,
				bool allow_symbol_tn =false,
				bool negate =false)
  {
    INT64 val;
    if( WN_operator(n)==OPR_TN )
      {
	if (!tn_immediate_value(WN_tn(n), &val, allow_symbol_tn))
	  return false;
      }
    else if (WN_operator(n)==OPR_INTCONST)
      {
	val = WN_const_val(n);
      }
    else
      return false;

    if (negate)
      val = -val;
    
    return TI_ISA_LC_Value_In_Class(val, lc);
  }

static bool is_one(WN *n)
{
  return WN_const_val(n)==1;
}

static bool is_zero(WN *n)
{
  return WN_const_val(n)==0;
}

static bool is_thirtytwo(WN *n)
{
  return WN_const_val(n)==32;
}

static bool hw_idiv32(WN *n)
{
  return xt_div32;
}

static bool is_extui_mask(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  INT64 val = WN_const_val(n);
  return((val > 0) && (val < 65536) && IS_POWER_OF_2(val + 1));
}

static bool is_extui_shift_mask(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  return Get_Extui_Shift_Mask(WN_const_val(n));
}

static bool is_bbci_bbsi_imm(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  return Get_Bbci_Bbsi_Immediate(WN_const_val(n));
}

static bool is_clamps_const(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  INT64 val = WN_const_val(n);
  if (val >= 0)
    return((val >= 127) && (val < 4194304) && IS_POWER_OF_2(val + 1));
  else
    return((val <= -128) && (val >= -4194304) && IS_POWER_OF_2(-val));
}

static bool is_left_right_shift_pair(WN *c0, WN *c1)
{
  if (WN_operator(c0) != OPR_INTCONST)
  {
    c0 = preg_equivalent_literal(c0);
    if (!c0)
      return FALSE;
  }

  if (WN_operator(c1) != OPR_INTCONST)
  {
    c1 = preg_equivalent_literal(c1);
    if (!c1)
      return FALSE;
  }

  return(WN_const_val(c0) == 32 - WN_const_val(c1));
}

static bool is_clamps_const_pair(WN *c0, WN *c1)
{
  if (WN_operator(c0) != OPR_INTCONST)
  {
    c0 = preg_equivalent_literal(c0);
    if (!c0)
      return FALSE;
  }

  if (WN_operator(c1) != OPR_INTCONST)
  {
    c1 = preg_equivalent_literal(c1);
    if (!c1)
      return FALSE;
  }

  Is_True(is_clamps_const(c0) && is_clamps_const(c1), (""));
  return(WN_const_val(c0) == (-WN_const_val(c1) - 1));
}


static bool is_simm8x256(WN *n) { return wn_immediate_value(n, LC_simm8x256); }
static bool is_simm4(WN *n)     { return wn_immediate_value(n, LC_simm4); }
static bool is_simm7(WN *n)     { return wn_immediate_value(n, LC_simm7); }
static bool is_simm8(WN *n)     { return wn_immediate_value(n, LC_simm8); }
static bool is_simm12(WN *n)    { return wn_immediate_value(n, LC_simm12); }
static bool is_simm16(WN *n)    { return wn_immediate_value(n, LC_simm16); }
static bool is_simm32(WN *n)    { return wn_immediate_value(n, LC_simm32, true); }
static bool is_uimm12x8(WN *n)  { return wn_immediate_value(n, LC_uimm12x8); }
static bool is_uimm16x4(WN *n)  { return wn_immediate_value(n, LC_uimm16x4); }
static bool is_uimm4(WN *n)     { return wn_immediate_value(n, LC_uimm4); }
static bool is_uimm5(WN *n)     { return wn_immediate_value(n, LC_uimm5); }
static bool is_uimm8(WN *n)     { return wn_immediate_value(n, LC_uimm8); }
static bool is_uimm8x2(WN *n)   { return wn_immediate_value(n, LC_uimm8x2); }
static bool is_uimm8x4(WN *n)   { return wn_immediate_value(n, LC_uimm8x4); }
static bool is_ai4const(WN *n)  { return wn_immediate_value(n, LC_ai4const); }
static bool is_b4constu(WN *n)  { return wn_immediate_value(n, LC_b4constu); }
static bool is_b4const(WN *n)   { return wn_immediate_value(n, LC_b4const); }
static bool is_lsi4x4(WN *n)    { return wn_immediate_value(n, LC_lsi4x4); }
static bool is_op2p1(WN *n)     { return wn_immediate_value(n, LC_op2p1); }
static bool is_tp7(WN *n)       { return wn_immediate_value(n, LC_tp7); }
static bool is_msalp32(WN *n)   { return wn_immediate_value(n, LC_msalp32); }

static bool is_simm8x256_negated(WN *n) { return wn_immediate_value(n, LC_simm8x256, false, true); }
 
/* Code generation function */

static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    TN *base_tn, INT64 base_ofst, OPS *ops,
			    bool is_tie_macro, bool is_float);
static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    ST *s, INT64 o, OPS *ops,
			    bool conservative_addr,
			    bool is_tie_macro, bool is_float);

// Given a symbol which may represent a constant, create a literal whose value
// is a pointer to it.  Put the literal value in the .begin literal section for
// the current function.

static ST *Generate_Literal_Pointer_Nonbased( ST *s, INT64 o );
static ST *Generate_Literal_Label( LABEL_IDX lab );
static ST *Generate_Literal_Pointer( ST *s, INT64 o );

//constant loading functions
extern TN *Generate_Constant (TYPE_ID rtype, TN *result, INT32 val, OPS *ops);
extern TN *Generate_Constant (TYPE_ID rtype, WN* wn, TN *result, TN *src, OPS *ops);
extern TN *Generate_Constant (TYPE_ID rtype, WN *wn, TN* result, ST *s, INT64 o, OPS *ops);
static ST *Generate_Literal_Float( float );

static void Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, ST *s, INT64 o, INT16 variant, OPS *ops);
static void Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, TN *addr, INT64 o, INT16 variant, OPS *ops);
static TN *Generate_Load_Memory (WN *tree, TYPE_ID rtype, TYPE_ID desc, TN *result,
				 ST *s, INT64 o, INT16 variant, OPS *ops);
static TN *Generate_Load_Memory (WN *tree, TYPE_ID rtype, TYPE_ID desc, TN *result,
				 TN *addr, INT64 o, INT16 variant, OPS *ops);

static TN *
round_mode_tn()
{
  static TN *rm_tn = NULL;
  FmtAssert(xt_hard_float, ("RoundMode state register requires FP hardware"));
  if (rm_tn == NULL) {
    rm_tn = Gen_State_Register_TN("RoundMode");
  }
  return rm_tn;
}

static TN *
xtsync_tn()
{
  static TN *xtsync_tn = NULL;
  if (xtsync_tn == NULL) {
    xtsync_tn = Gen_State_Register_TN("XTSYNC");
  }
  return xtsync_tn;
}

static TN *
accum_tn()
{
  static TN *acc_tn = NULL;
  FmtAssert(xt_mac16, ("Accumulator state register requires MAC16 hardware"));
  if (acc_tn == NULL) {
    acc_tn = Gen_State_Register_TN("ACC");
  }
  return acc_tn;
}

static TN *
float_preg_to_int_tn(ST *preg_st, PREG_NUM preg_num)
{
  TN *tn = PREG_To_TN(preg_st, preg_num);
  if (TN_mtype(tn) == MTYPE_F4) {
    Set_TN_mtype(tn, MTYPE_I4);
    Set_TN_register_class(tn, TI_ISA_Regclass_Integer());
    PREG_To_TN_Mtype[preg_num] = MTYPE_I4;
  }
  return tn;
}


static TN *
build_hifi2_pr_tn ()
{
  Is_True(xt_hifi2, ("Expected HiFi2"));
  return Build_TN_Of_Mtype(TI_ISA_Mtype_For_Regclass(TI_ISA_Regclass_HiFi2_PR()));
}


static TN *
build_hifi2_qr_tn ()
{
  Is_True(xt_hifi2, ("Expected HiFi2"));
  return Build_TN_Of_Mtype(TI_ISA_Mtype_For_Regclass(TI_ISA_Regclass_HiFi2_QR()));
}


static void Check_For_Dedicated_Preg (WN *n)
{
  if (ST_assigned_to_dedicated_preg(WN_st(n)))
  {
    WN_offset(n) = Find_PREG_For_Symbol(WN_st(n));
    WN_st_idx(n) = ST_st_idx(MTYPE_To_PREG(ST_mtype(WN_st(n))));
    Set_TN_is_asm_reg(PREG_To_TN(WN_st(n),WN_offset(n)));
  }
}

static WN *preg_home (WN *ldid)
{
  BOOL dum;

  if ((WN_class(ldid) == CLASS_PREG) && !Preg_Is_Dedicated(WN_load_offset(ldid)))
    return Preg_Is_Rematerializable(WN_load_offset(ldid), &dum);

  return NULL;
}

static WN *preg_equivalent_literal (WN *ldid)
{
  WN *lit = preg_home(ldid);
  if (lit && (WN_operator(lit) == OPR_INTCONST))
    return lit;

  return NULL;
}

static BOOL
tn_is_const_equiv (TN *tn)
{
  if (TN_has_value(tn))
    return TRUE;

  if (TN_is_register(tn) && TN_is_rematerializable(tn) &&
      TN_home(tn) && (WN_operator(TN_home(tn)) == OPR_INTCONST))
    return TRUE;

  return FALSE;
}

static INT64
tn_equiv_const (TN *tn)
{
  if (TN_has_value(tn))
    return TN_value(tn);

  if (TN_is_register(tn) && TN_is_rematerializable(tn) &&
      TN_home(tn) && (WN_operator(TN_home(tn)) == OPR_INTCONST))
    return WN_const_val(TN_home(tn));

  FmtAssert(FALSE, ("expecting tn equivalent to constant\n"));
}


static BOOL
Get_Extui_Shift_Mask (UINT64 val, INT32 *shift, INT32 *size)
{
  /* we only get here for MTYPE_I4 or MTYPE_U4, so we can truncate
     upper bits. */
  val = val & 0x00000000ffffffffll;

  INT64 hb = TARG_INT_Most_Sig_One(val);
  INT64 lb = TARG_INT_Least_Sig_One(val);
  if ((lb == -1) || (hb == -1) ||
      (lb > 31) || (hb > 31) ||
      ((hb-lb) >= 16) ||
      !Immediate_Has_All_Ones(val, hb, lb))
    return FALSE;

  if (shift)
    *shift = lb;
  if (size)
    *size = hb - lb + 1;

  return TRUE;
}

static BOOL
Get_Bbci_Bbsi_Immediate (INT64 val, INT32 *imm)
{
  if ((val < 0) || !IS_POWER_OF_2(val))
    return FALSE;

  INT64 bit = TARG_INT_Least_Sig_One(val);
  if ((bit == -1) || (bit > 31))
    return FALSE;

  if (imm)
    *imm = bit;

  return TRUE;
}

static void
Generate_Const16 (TYPE_ID rtype, TN *result, TN *src, OPS *ops)
{
  Is_True(xt_const16, ("Config doesn't support const16"));
  Build_OP(TOP_const16hi, result, src, ops);
  Build_OP(TOP_const16lo, result, result, src, ops);
}

static void
Generate_Movi (TYPE_ID rtype, TN *result, TN *src, OPS *ops)
{
  Build_OP(TOP_movi, result, src, ops);
}

static void
Generate_Load_Const (TYPE_ID rtype, TN *result, TN *src, OPS *ops)
{
  Build_OP(TOP_load_const, result, src, ops);
}

/* Sign or zero extend, based on 'rtype', the lower 'bits' of 'src'
   into 'result'. To extend a byte, 'bits' should be 8, for a short
   'bits' should be 16, etc. */
static TN *
Generate_Extend (TYPE_ID rtype, TN *result, TN *src, UINT32 bits, OPS *ops)
{
  Is_True((bits > 0) && (bits < 32), ("Generate_Extend: unexpected bits value %d", bits));

  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  /* If we have sext instruction then use it, otherwise we have to use either
     an extract or shifts. */

  if (xt_sext && MTYPE_is_signed(rtype) && (bits >= 8) && (bits <= 23))
  {
    Build_OP(TOP_sext, result, src, Gen_Literal_TN(bits - 1, 4), ops);
  }
  else if (MTYPE_is_unsigned(rtype) && (bits <= 16))
  {
    Build_OP(TOP_extui, result, src, Gen_Literal_TN(0, 4), Gen_Literal_TN(bits, 4), ops);
  }
  else
  {
    TN *tmp = Build_TN_Of_Mtype(rtype);
    Build_OP(TOP_slli, tmp, src, Gen_Literal_TN(32 - bits, 4), ops);
    Build_OP(MTYPE_is_unsigned(rtype) ? TOP_srli : TOP_srai,
	     result, tmp, Gen_Literal_TN(32 - bits, 4), ops);
  }

  return result;
}

TN *
Generate_Constant (TYPE_ID rtype, TN *result, INT32 val, OPS *ops)
{
  TN *src = Gen_Literal_TN(val, 4);
  return Generate_Constant(rtype, WN_Intconst(rtype, val), result, src, ops);
}

TN *
Generate_Constant (TYPE_ID rtype, WN* wn, TN *result, TN *src, OPS *ops)
{
  FmtAssert(TN_is_constant(src), ("not a constant TN"));

  /* If we aren't given a result tn, then create one and mark it as
     rematerializable. */
  
  if (!result)
  {
    result = Build_TN_Of_Mtype(rtype);
    if (CGSPILL_Rematerialize_Constants && wn)
    {
      Set_TN_is_rematerializable(result);
      Set_TN_home(result, wn);
    }
  }
  
  if (TN_has_value(src) && TI_ISA_LC_Value_In_Class(TN_value(src), LC_simm12))
    Generate_Movi(rtype, result, src, ops);
  else
  {
    if (xt_prefer_const16)
      Generate_Const16(rtype, result, src, ops);
    else
      Generate_Load_Const(rtype, result, src, ops);
  }
  return result;
}

TN *
Generate_Constant(TYPE_ID rtype, WN *wn, TN* result, ST *s, INT64 o, OPS *ops)
{
  /* If we aren't given a result tn, then create one and mark it as
     rematerializable. */
  
  if (!result)
  {
    result = Build_TN_Of_Mtype(rtype);
    if (CGSPILL_Rematerialize_Constants && wn)
    {
      Set_TN_is_rematerializable(result);
      Set_TN_home(result, wn);
    }
  }

  Allocate_Object(s);

  TN* tn = Gen_Symbol_TN(s, o, TN_RELOC_NONE);
  if (xt_prefer_const16)
    Generate_Const16(rtype, result, tn, ops);
  else
    Generate_Load_Const(rtype, result, tn, ops);

  return result;
}

extern TN *Move_To_Register (TYPE_ID rtype, TN *result, TN *val, OPS *ops)
{
  if (result &&
      (MTYPE_is_tie(TN_mtype(result)) ||
       MTYPE_is_tie(TN_mtype(val))))
  {
    if (result!=val) {
      FmtAssert(TN_is_register(val), ("expecting register tn"));
      result = Tie_Move_To_Result(result,val,ops);
    }
  }
  else if (MTYPE_is_xtbool(rtype)) {
    if (TN_register(val) && TN_is_dedicated(val)) {
        if (!result)
	  result = Build_TN_Of_Mtype(rtype);
    } else
      FmtAssert(rtype==TN_mtype(val) && TN_is_register(val),
				("Expecting source br register tn"));
    if (result && result != val) {
      FmtAssert(TN_is_register(result), ("Expecting result br register tn"));
      FmtAssert(TN_is_dedicated(result) ||
		TN_is_dedicated(val) ||
		TN_mtype(val)==TN_mtype(result),
				("Move between different xtbool types"));

      /* first try to see if there is a real move macro */
      TIE_MACRO_p macro = tie_info->mtype_move_macro(rtype);
      if (macro && macro->num_instructions()!=0) {
	result = Tie_Move_To_Result(result,val,ops);
      } else if (rtype == MTYPE_XTBOOL) {
        Build_OP(TOP_movbr, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      } else if (rtype == MTYPE_XTBOOL2) {
        Build_OP(TOP_movbr2, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      } else if (rtype == MTYPE_XTBOOL4) {
        Build_OP(TOP_movbr4, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      } else if (rtype == MTYPE_XTBOOL8) {
        TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
        TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
        Build_OP(TOP_get_tmp_ar, tmp1, ops );
        Build_OP(TOP_get_tmp_ar, tmp2, ops );
        Build_OP(TOP_movbr8, result, val, tmp1, tmp2, ops );
      } else {
        Build_OP(TOP_movbr16, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      }
    } else
      result = val;
  }
  else if (TN_has_value(val))
  {
    result = Generate_Constant(rtype, result, TN_value(val), ops);
  }
  else if (result && result != val)
  {
    FmtAssert(TN_is_register(val), ("expecting register tn"));
    if (xt_hard_float && rtype == MTYPE_F4) {
      TOP mov = tie_info->xtfloat_move_topcode();
      TN* state1 = cpenable_tn(mov);
      if (state1)
        Build_OP(mov, result, val, state1 /* cpenable_tn()*/, ops );
      else
        Build_OP(mov, result, val, ops );
    } else {
      TOP mov = TOP_mov_n;
      Build_OP(mov, result, val, ops );
    }
    Set_OP_copy (OPS_last(ops));
  }
  else
  {
    result = val;
  }
  
  return result;
}

static void
Generate_Call ( WN *n, TOP t, OPS *ops )
{
  ST *s = WN_st(n);
  TN *tn, *ret_addr_tn;
  ISA_REGCLASS ar = TI_ISA_Regclass_Integer();
  REGISTER ret_addr_reg;
  INT first_reg = TI_ISA_Regclass_First_Reg(TI_ISA_Regclass_Info(ar)) +
    REGISTER_MIN;
  switch (t) {
  case TOP_call0:
    ret_addr_reg = first_reg + 0; break;
  case TOP_call4:
    ret_addr_reg = first_reg + 4; break;
  case TOP_call8:
    ret_addr_reg = first_reg + 8; break;
  case TOP_call12:
    ret_addr_reg = first_reg + 12; break;
  }
  ret_addr_tn = Build_Dedicated_TN(ar, ret_addr_reg, 4);

  if ( Gen_Indirect_Call || 
       (Gen_PIC_Shared && (ST_export(s) != EXPORT_LOCAL))) {
    char *buf = (char *)alloca(strlen(ST_name(s))+5);
    sprintf (buf, "%s@PLT", ST_name(s));
    ST *plt_st = Gen_Intrinsic_Function(ST_type(s), buf);
    Set_ST_suppress_asm_type(plt_st);

    tn = Generate_Constant(MTYPE_U4, NULL, NULL, plt_st, 0, ops);
    switch (t) {
    case TOP_call0: t = TOP_callx0; break;
    case TOP_call4: t = TOP_callx4; break;
    case TOP_call8: t = TOP_callx8; break;
    case TOP_call12: t = TOP_callx12; break;
    }
  } else
    tn = Gen_Symbol_TN( s, 0, TN_RELOC_NONE );
  PU_Has_Calls = TRUE;
  Set_Last_Mem_OP( ops );
  Build_OP( t, ret_addr_tn, tn, ops );
  Handle_Call_Site_Extras( n, WN_operator( n ) );
}

static TN *
Generate_Binary(TYPE_ID mtype, TOP t,
		TN *result, TN *left, TN *right, OPS *ops)
{
  Is_True(!MTYPE_is_float(mtype), ("Generate_Binary() used on float type"));
  if( !result )
    result = Build_TN_Of_Mtype(mtype);

  Build_OP(t, result, left, right, ops );
  return result;
}


static TN *
Generate_Unary_CPENABLE (TOP t, TN *result, TN *src, OPS *ops)
{
  Is_True(t != TOP_UNDEFINED, ("Unknown instruction."));
  Is_True(TI_ISA_Op_Results(TI_ISA_Operand_Info(t)) == 1,
          ("Unexpected number of results."));
  
  TN *cpenable_state = cpenable_tn(t);
  if (cpenable_state)
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 2,
            ("Unexpected number of operands."));
    Build_OP(t, result, src, cpenable_state, ops);
  }
  else
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 1,
            ("Unexpected number of operands."));
    Build_OP(t, result, src, ops);
  }

  return result;
}


static TN *
Generate_Binary_CPENABLE (TOP t, TN *result, TN *left, TN *right, OPS *ops)
{
  Is_True(t != TOP_UNDEFINED, ("Unknown instruction."));
  Is_True(TI_ISA_Op_Results(TI_ISA_Operand_Info(t)) == 1,
          ("Unexpected number of results."));
  
  TN *cpenable_state = cpenable_tn(t);
  if (cpenable_state)
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 3,
            ("Unexpected number of operands."));
    Build_OP(t, result, left, right, cpenable_state, ops);
  }
  else
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 2,
            ("Unexpected number of operands."));
    Build_OP(t, result, left, right, ops);
  }

  return result;
}


static TN *
Generate_Binary_Mul(TYPE_ID mtype, TOP t,
		TN *result, TN *left, TN *right, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(mtype);

  TN* state2 = cpenable_tn(t);
  if (state2)
    Build_OP(t, result, left, right, state2 /* cpenable_tn() */, ops );
  else
    Build_OP(t, result, left, right, ops );
  return result;
}

static TN *
Generate_Binary_FP(TYPE_ID mtype, TOP t,
		   TN *result, TN *left, TN *right, BOOL roundmode, OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(mtype);
  if (roundmode) {
    TN* state3 = cpenable_tn(t);
    if (state3)
      Build_OP(t, result, left, right, round_mode_tn(), state3 /* cpenable_tn() */, ops);
    else
      Build_OP(t, result, left, right, round_mode_tn(),  ops);
  } else {
    TN* state2 = cpenable_tn(t);
    if (state2)
      Build_OP(t, result, left, right, state2 /* cpenable_tn() */, ops);
    else
      Build_OP(t, result, left, right, ops);
  }
  return result;
}

static TN *
Generate_Unary(TYPE_ID mtype, TOP t,
	       TN *result, TN *src, OPS *ops)
{
  Is_True(!MTYPE_is_float(mtype), ("Generate_Unary() used on float type"));
  if( !result )
    result = Build_TN_Of_Mtype(mtype);
  Build_OP(t, result, src, ops);
  return result;
}

static TN *
Generate_Unary_FP(TYPE_ID mtype, TOP t,
	       TN *result, TN *src, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(mtype);
  TN* state1 = cpenable_tn(t);
  if (state1)
    Build_OP(t, result, src, state1 /* cpenable_tn() */, ops);
  else
    Build_OP(t, result, src, ops);
  return result;
}

static TN *
Generate_And_Immediate (TYPE_ID rtype, TN *result, TN *reg, TN *imm, OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  imm = Gen_Literal_TN(TARG_INT_Least_Sig_One(TN_value(imm) + 1), 4);
  Build_OP(TOP_extui, result, reg, Gen_Literal_TN(0,4), imm, ops);

  return result;
}

static TN *
Generate_Sub (TYPE_ID rtype, TN *result, TN *left, TN *right, OPS *ops)
{
  BOOL negate = FALSE;

  /* If both 'left' and 'right' are immediates, then we can just
     perform the subtraction now. */
  if ((CG_opt_level > 0) && tn_is_const_equiv(left) && tn_is_const_equiv(right))
  {
    DevWarn("both operands to subtract are constant");
    return Generate_Constant(rtype, result, tn_equiv_const(left)-tn_equiv_const(right), ops);
  }

  /* If 'left' is an immediate, we must first load it into a
     register. */
  if (TN_has_value(left))
    left = Generate_Constant(rtype, 0, TN_value(left), ops);

  FmtAssert(TN_is_register(left), ("operand 0 of subtract must be register"));
  FmtAssert(TN_is_register(right) || TN_has_value(right),
	    ("operand 1 of subtract must be register or immediate"));
  
  if (tn_is_const_equiv(right) && TI_ISA_LC_Value_In_Class(-tn_equiv_const(right), LC_simm8))
  {
    result = Generate_Binary(MTYPE_I4, TOP_addi, result, left,
			     Gen_Literal_TN(-tn_equiv_const(right), 4), ops);
  }
  else
  {
    /* If 'right' is an immediate, we must first load it into a
       register (It doesn't fit in the addi immediate field, so we get
       here...). */
    if (TN_has_value(right))
      right = Generate_Constant(rtype, 0, TN_value(right), ops);

    result = Generate_Binary(MTYPE_I4, TOP_sub, result, left, right, ops);
  }

  return result;
}

static TN *
Generate_HiFi2_Mul (TYPE_ID rtype, TN *result, WN *result_wn,
                    TN *left, TN *right, OPS *ops)
{
  Is_True(xt_hifi2, ("Expected a HiFi2 configuration."));
  Is_True(WN_Mpy_16Bit(result_wn), ("No support for 32-bit multiplcation on HiFi2"));
  
  if( !result )
    result = Build_TN_Of_Mtype(rtype);
  
  if (WN_Mpy_16Bit_Signed(result_wn))
  {
    /* Signed 16-bit multiplication. */
    TN *pr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_cvtp24a16x2.ll"),
                                      build_hifi2_pr_tn(), left, right, ops);
    TN *qr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_mulp24s.hl"),
                                      build_hifi2_qr_tn(), pr, pr, ops);
    result = Generate_Unary_CPENABLE(TI_TOP_Topcode("ae_trunca32q48"),
                                     result, qr, ops);
    return result;
  }
    
  /* Unsigned 16-bit multiplication. The TNs must be correctly
     zero-extended. */
  TN *pr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_movpa24x2"),
                                    build_hifi2_pr_tn(), left, right, ops);
  TN *qr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_mulp24s.hl"),
                                    build_hifi2_qr_tn(), pr, pr, ops);
  TN *qr_shl = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_slliq56"),
                                        build_hifi2_qr_tn(), qr,
                                        Gen_Literal_TN(16, 4), ops);
  result = Generate_Unary_CPENABLE(TI_TOP_Topcode("ae_trunca32q48"),
                                   result, qr_shl, ops);
  return result;
}


static TN *
Generate_Mul (TYPE_ID rtype, TN *result, WN *result_wn,
              char * instruction_name, TN *left, TN *right, OPS *ops)
{
  Is_True(xt_mul16 || xt_mul32 || Enable_HiFi2_Ops,
	  ("Cannot generate multiply instructions"));

  /* If both 'left' and 'right' are immediates, then we can just
     perform the multiply now. */
  if ((CG_opt_level > 0) && tn_is_const_equiv(left) && tn_is_const_equiv(right))
  {
    DevWarn("both operands to mult are constant");
    return Generate_Constant(rtype, result, tn_equiv_const(left)*tn_equiv_const(right), ops);
  }

  /* If 'left' is an immediate, we must first load it into a
     register. */
  if (TN_has_value(left))
    left = Generate_Constant(rtype, 0, TN_value(left), ops);

  /* If 'right' is an immediate, we must first load it into a
     register */
  if (TN_has_value(right))
      right = Generate_Constant(rtype, 0, TN_value(right), ops);

  if (instruction_name)
  {
    Is_True(xt_mul16 || xt_mul32,
            ("No MUL16 or MUL32 option available."));
    TOP top = TI_TOP_Topcode(instruction_name);
    Is_True((top != TOP_UNDEFINED), ("Cannot generate %s instruction", instruction_name));
    result = Generate_Binary_Mul(rtype, top, result, left, right, ops);
  }
  else
  {
    /* Implement the multiplication through HiFi2 operations. */
    Is_True(Enable_HiFi2_Ops, ("Unable to use HiFi2 instructions."));
    result = Generate_HiFi2_Mul(rtype, result, result_wn, left, right, ops);
  }
  
  return result;
}

static TN *
Generate_iDivRem(TYPE_ID rtype, TOP divRem_top, TN *result, TN *divident, TN *divisor, OPS *ops)
{
  Is_True(xt_div32, ("Cannot generate integer divide"));

  /* If any operand is constant, load it into register */
  if (TN_has_value(divident)) {
    divident = Generate_Constant(TN_mtype(divident), 0, TN_value(divident), ops);
  }

  if (TN_has_value(divisor)) {
    divisor = Generate_Constant(TN_mtype(divisor), 0, TN_value(divisor), ops);
  }

  if ( !result ) {
    result = Build_TN_Of_Mtype(rtype);
  }
  Build_OP(divRem_top, result, divident, divisor, ops);
  return result;
}

static TN *
Generate_AddShift(WN *wn, TYPE_ID rtype, TN *result, TN *left, TN *right, TN *shift, OPS *ops)
{
  TOP top = TOP_UNDEFINED;
  
  FmtAssert(xt_addx, ("Config does not support addx"));

  if (!result) 
    result = Build_TN_Of_Mtype(rtype);

  if (TN_has_value(shift))
  {
    switch (TN_value(shift))
    {
    case 0:
      top = TOP_add;
      break;
    case 1:
      top = TOP_addx2;
      break;
    case 2:
      top = TOP_addx4;
      break;
    case 3:
      top = TOP_addx8;
      break;
    }
  }

  FmtAssert(top != TOP_UNDEFINED, ("unable to form shift-add combination"));
  Build_OP(top, result, left, right, ops);
  return result;
}

static TN *
Generate_SubShift(WN *wn, TYPE_ID rtype, TN *result, TN *left, TN *right, TN *shift, OPS *ops)
{
  TOP top = TOP_UNDEFINED;
  
  FmtAssert(xt_addx, ("Config does not support subx"));

  if (!result) 
    result = Build_TN_Of_Mtype(rtype);

  if (TN_has_value(shift))
  {
    switch (TN_value(shift))
    {
    case 0:
      top = TOP_sub;
      break;
    case 1:
      top = TOP_subx2;
      break;
    case 2:
      top = TOP_subx4;
      break;
    case 3:
      top = TOP_subx8;
      break;
    }
  }

  FmtAssert(top != TOP_UNDEFINED, ("unable to form shift-sub combination"));
  Build_OP(top, result, left, right, ops);
  return result;
}

static void
Generate_Branch (WN *wn, TYPE_ID desc, TOP top, LABEL_IDX target, TN *l, TN *r, OPS *ops)
{
  BOOL reload = FALSE;
  

  /* If 'l' and/or 'r' is a constant tn, then try to use an immediate
     form of branch 'top'. If we can't use an immediate form, then just
     load the constant into a register tn. */

  if (TN_has_value(l) || TN_has_value(r))
  {
    /* If both 'l' and 'r' are constant, then give a warning since the
       optimizer should have eliminated the branch. Below we will load
       both constants into registers for the branch. We don't bother
       to try to optimize this case by using one tn as an immediate,
       since it should be caught by the optimizer. */

    if (TN_has_value(l) && TN_has_value(r))
    {
      reload = TRUE;
      DevWarn("Found compile-time constant branch condition");
    }
    else
    {
      /* Put the immediate as the second operand. */

      BOOL flip = TN_has_value(l);
      TN *tl = l;
      TN *tr = r;
      
      if (flip)
      {
	tl = r;
	tr = l;
      }

      /* Try to create an immediate version of the branch. If we fail,
         then mark that we need to reload all constant tns into
         registers. */

      INT64 imm_val = TN_value(tr);
      if (TI_Equivalent_Immed_Branch(&top, &imm_val, flip))
      {
	/* We created an immediate version of the branch... */

	l = tl;
	r = tr;
	
	/* If the new branch has only 2 operands, then show that 'r'
           is no longer used. Otherwise, if 'imm_val' has changed then create a
           new immediate tn to represent it. */

	const ISA_OPERAND_INFO *info = TI_ISA_Operand_Info(top);
	const INT ops = TI_ISA_Op_Operands(info);
	FmtAssert((ops == 2) || (ops == 3), ("expecting branch to have 2 or 3 operands, not %d", ops));
  
	if (ops == 2)
	  r = NULL;
	else if (imm_val != TN_value(r))
	  r = Gen_Literal_TN(imm_val, 4);
      }
      else
      {
	reload = TRUE;
      }
    }
  }
  
  /* Reload constant tns into registers, if necessary. */

  if (reload)
  {
    if (TN_has_value(l))
      l = Generate_Constant(desc, 0, TN_value(l), ops);
    if (TN_has_value(r))
      r = Generate_Constant(desc, 0, TN_value(r), ops);
  }

  if (r == NULL)
    Build_OP(top, l, Gen_Label_TN(target, 0), ops);
  else
    Build_OP(top, l, r, Gen_Label_TN(target, 0), ops);

  if (wn)
    End_Basic_Block(wn);
}

static TN *
Generate_Cmov (TYPE_ID rtype, TOP top, TN *result, TN *cond, TN *tn_true, TN* tn_false, OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  /* If 'tn_true' == NULL we use literal 1. If 'tn_false' is NULL we
     use literal 0. */

  if (!tn_true)
    tn_true = Generate_Constant(rtype, tn_true, 1, ops);
  if (!tn_false)
    tn_false = Generate_Constant(rtype, tn_false, 0, ops);
  
  /* Get the condition tn. We must copy it to a temporary tn if 'cond'
     == 'result' since we clobber 'result' before using 'cond'. We
     must also put 'cond' in a register if it is a constant. */

  if ((cond == result) || TN_has_value(cond))
    cond = Move_To_Register(MTYPE_I4, Build_TN_Of_Mtype(MTYPE_I4), cond, ops);

  /* Get the true tn. We must copy it to a temporary tn if 'tn_true'
     == 'result' since we clobber 'result' before using 'tn_true'.  We
     must also put 'tn_true' in a register if it is a constant.*/

  if ((tn_true == result) || TN_has_value(tn_true))
    tn_true = Move_To_Register(rtype, Build_TN_Of_Mtype(rtype), tn_true, ops);

  /* Evaluate false side into result, then conditional move true side
     into result. */
  
  result = Move_To_Register(rtype, result, tn_false, ops);
  if (MTYPE_is_float(rtype)) {
    TN* state3 = cpenable_tn(top);
    if (state3)
      Build_OP(top, result, result, tn_true, cond, state3 /* cpenable_tn() */, ops);
    else
      Build_OP(top, result, result, tn_true, cond, ops);
  } else {
    Build_OP(top, result, result, tn_true, cond, ops);
  }
  return result;
}

static TN *
Generate_Branch_Select (TYPE_ID rtype, TYPE_ID desc, TOP t,
			TN *result, TN *l, TN *r,
			TN *tn_true, TN *tn_false,
			OPS *ops)
{
  LABEL_IDX label;
  BB *this_bb = Get_Cur_BB();

  TOP nt = CGTARG_Invert_Branch(t);
  if (nt != TOP_UNDEFINED)
  {
    BOOL swap = FALSE;
    
    /* If 'tn_false' is the same as 'result', and we can invert the
       branch, then do so and switch 'tn_true' and 'tn_false'. This
       gives better code since the copy of 'tn_true' to 'result' before
       the branch will then be a nop. */

    if (tn_false == result)
    {
      swap = TRUE;
    }
    /* If 'tn_false' is equivalent to a constant and is the same TN as
       'l' or 'r', then invert the branch, so that all uses of the
       constant occur in the first block (i.e. the copy of 'tn_true'
       to 'result' and the branch). Then, if we have to rematerialize
       the constant it can be done in a single location for both the
       copy and the branch.  */
    else if (tn_false && tn_is_const_equiv(tn_false) &&
	     ((tn_false == l) || (tn_false == r)))
    {
      swap = TRUE;
    }

    if (swap)
    {
      TN *tmp = tn_true;
      tn_true = tn_false;
      tn_false = tmp;
      t = nt;
    }
  }
  
  /* We need a temporary tn for the calculation. If 'result' is a
     non-dedicated tn and is not the same as one of the inputs that is
     used after 'result' is set (i.e. 'l', 'r', or 'tn_false'), then
     we can just use it, otherwise we must build one. */
  
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  TN *tmp = ((TN_is_dedicated(result) ||
	      (result == l) || (result == r) ||
	      (result == tn_false)) ?
	     Build_TN_Of_Mtype(rtype) : result);

  /* If 'tn_true' is non-null, then we want to use that as the true
     outcome, otherwise we just use the constant 1 as the true
     outcome. */

  if (!tn_true)
    Generate_Constant(rtype, tmp, 1, ops);
  else
    Move_To_Register(rtype, tmp, tn_true, ops);
    
  label = Gen_Temp_Label();
  Generate_Branch(NULL, desc, t, label, l, r, ops);

  Link_Pred_Succ(this_bb, Start_New_Basic_Block());

  /* If 'tn_false' is non-null, then we want to use that as the false
     outcome, otherwise we just use the constant 0 as the false
     outcome. */

  if (!tn_false)
    Generate_Constant(rtype, tmp, 0, ops);
  else
    Move_To_Register(rtype, tmp, tn_false, ops);

  /* Start a new basic block beginning with "label" and attach it to
     this_bb */
  Add_Label(label);
  Link_Pred_Succ(this_bb, Get_Cur_BB());

  /* If we used a temporary tn that is not 'result', then move that
     temporary to 'result'. */

  if (tmp != result)
    result = Move_To_Register(rtype, result, tmp, ops);
  
  return result;
}


static TN *
Generate_Conditional_Select (TYPE_ID rtype, TYPE_ID desc, OPERATOR opr,
			     TN *result, TN *l, TN *r,
			     TN *tn_true, TN *tn_false,
			     OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  /* If 'result' is a dedicated tn, then we must use a temporary
     register and copy that to 'result' at the end. */

  TN *orig_result = NULL;
  if (TN_is_dedicated(result))
  {
    orig_result = result;
    result = Build_TN_Of_Mtype(rtype);
  }

  /* We can sometimes use a more efficient sequence if 'l' or 'r' is a
     constant. Because of the way we are called, we can be passed 'l'
     or 'r' as a register TN that is equivalent to a constant. Below,
     when we can use a constant to simplify we use tn_is_const_equiv
     and tn_equiv_const to determine if a TN is equivalent to a
     constant. If we want to know if a TN itself is constant we use
     TN_has_value. */

  /* If 'tn_true' == NULL we assume it is literal 1. If 'tn_false' is
     NULL we assume it is literal 0. If 'tn_true' == 1 and 'tn_false'
     == 0 then we have a boolean result, for which we can sometimes
     generate better instruction sequences. */

  const BOOL boolean = ((!tn_true || (tn_is_const_equiv(tn_true) && (tn_equiv_const(tn_true) == 1))) &&
			(!tn_false || (tn_is_const_equiv(tn_false) && (tn_equiv_const(tn_false) == 0))));
  const BOOL signed_compare = MTYPE_signed(desc);
  const BOOL signed_result = MTYPE_signed(rtype);

  /* We may iterate here since some comparisons are best implemented
     by changing the operator, and we don't want to replicate all the
     logic. */

  BOOL repeat = TRUE;
  UINT repeat_cnt = 0;

  while (repeat)
  {
    FmtAssert(repeat < 3, ("expecting at most 3 iterations"));
    repeat = FALSE;
    repeat_cnt++;
    
    switch (opr)
    {
    case OPR_NE:
    {
      /* OPR_NE:

	 - for boolean we can be tricky and avoid loading an immediate
	 0, since that is available as the result of the subtract

	 - otherwise just subtract and cmov.

	 For both cases we are free to switch the order of operands in
	 the subtract since we are only interested in whether they are
	 equal or not.
      */
      if (boolean)
      {
	TN *one = Generate_Constant(MTYPE_I4, NULL, 1, ops);
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	  result = Move_To_Register(rtype, result, l, ops);
	else if (tn_is_const_equiv(l) && (tn_equiv_const(l) == 0))
	  result = Move_To_Register(rtype, result, r, ops);
	else
	{
	  if (TN_has_value(l))
	    SWAP_TNS(l, r);
      
	  result = Generate_Sub(rtype, result, l, r, ops);
	}
	
	Build_OP(TOP_movnez, result, result, one, result, ops);
      }
      else
      {
	TN *dif;
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	  dif = l;
	else if (tn_is_const_equiv(l) && (tn_equiv_const(l) == 0))
	  dif = r;
	else
	{
	  if (TN_has_value(l))
	    SWAP_TNS(l, r);

	  dif = Generate_Sub(rtype, 0, l, r, ops);
	}
	
	Generate_Cmov(rtype, TOP_movnez, result, dif, tn_true, tn_false, ops);
      }

      break;
    }

    case OPR_EQ:
    {
      /* OPR_EQ:

	 - just subtract and cmov.

	 We are free to switch the order of operands in the subtract
	 since we are only interested in whether they are equal or
	 not.
      */
      TN *dif;
      if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	dif = l;
      else if (tn_is_const_equiv(l) && (tn_equiv_const(l) == 0))
	dif = r;
      else
      {
	if (TN_has_value(l))
	  SWAP_TNS(l, r);
      
	dif = Generate_Sub(rtype, 0, l, r, ops);
      }

      Generate_Cmov(rtype, TOP_moveqz, result, dif, tn_true, tn_false, ops);
      break;
    }

    case OPR_GT:
      /* OPR_GT:

	 Just swap the comparison operands and let the OPR_LT case
	 handle it.
      */
      opr = OPR_LT;
      SWAP_TNS(l, r);
      // fall-through
      
    case OPR_LT:
    {
      /* OPR_LT:

	 if 'l' is a constant, then change to OPR_GE 'r' >= ('l'+1).

	 signed comparison

	 - if 'r' == 0, then we can use a cmov
	      
	 - otherwise we must branch

	 unsigned comparison

	 - if 'r' == 0 the result is always 'tn_false'.

	 - if 'r' == 1, then change to OPR_EQ 'l' == 0.

	 - otherwise we must use a branch
      */
      
      if (!TN_has_value(r) && TN_has_value(l) && (TN_value(l) < INT_MAX))
      {
	opr = OPR_GE;
	SWAP_TNS(l, r);
	r = Gen_Literal_TN(TN_value(r) + 1, 4);
	repeat = TRUE;
      }
      else if (signed_compare)
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  Generate_Cmov(rtype, TOP_movltz, result, l, tn_true, tn_false, ops);
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_blt,
					  result, l, r, tn_true, tn_false, ops);
	}
      }
      else
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  DevWarn("OPR_LT unsigned comparison l < 0 is always false");
	  if (!tn_false)
	    result = Generate_Constant(rtype, result, 0, ops);
	  else
	    result = Move_To_Register(rtype, result, tn_false, ops);
	}
	else if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 1))
	{
	  opr = OPR_EQ;
	  r = Gen_Literal_TN(0, 4);
	  repeat = TRUE;
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_bltu,
					  result, l, r, tn_true, tn_false, ops);
	}
      }

      break;
    }

    case OPR_LE:
      /* OPR_LE:

	 Just swap the comparison operands and let the OPR_GE case
	 handle it.
      */
      opr = OPR_GE;
      SWAP_TNS(l, r);
      // fall-through
      
    case OPR_GE:
    {
      /* OPR_GE:

	 if 'l' is a constant, then change to OPR_LT 'r' < ('l'+1).

	 signed comparison

	 - if 'r' == 0, then we can use a cmov
	      
	 - otherwise we must branch

	 unsigned comparison

	 - if 'r' == 0 the result is always 'tn_true'.

	 - if 'r' == 1, then change to OPR_NE 'l' != 0.

	 - otherwise we must use a branch
      */

      BOOL no_overflow = signed_compare ?  ((TN_value(l) < INT_MAX)) :
					   (TN_value(l)+1 != 0);
      
      if (!TN_has_value(r) && TN_has_value(l) && no_overflow)
      {
	opr = OPR_LT;
	SWAP_TNS(l, r);
	r = Gen_Literal_TN(TN_value(r) + 1, 4);
	repeat = TRUE;
      }
      else if (signed_compare)
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  Generate_Cmov(rtype, TOP_movgez, result, l, tn_true, tn_false, ops);
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_bge,
					  result, l, r, tn_true, tn_false, ops);
	}
      }
      else
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  DevWarn("OPR_GE unsigned comparison l >= 0 is always true");
	  if (!tn_true)
	    result = Generate_Constant(rtype, result, 1, ops);
	  else
	    result = Move_To_Register(rtype, result, tn_true, ops);
	}
	else if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 1))
	{
	  opr = OPR_NE;
	  r = Gen_Literal_TN(0, 4);
	  repeat = TRUE;
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_bgeu,
					  result, l, r, tn_true, tn_false, ops);
	}
      }

      break;
    }

    default:
      FmtAssert(FALSE, ("Unknown comparison operator, %d\n", opr));
      break;
    }
  }

  if (orig_result)
    result = Move_To_Register(rtype, orig_result, result, ops);

  return result;
}

static TN *
Generate_Comparison (OPERATOR opr, TYPE_ID rtype, TYPE_ID desc,
		     TN *result, TN *l, TN *r, OPS *ops)
{
  return Generate_Conditional_Select(rtype, desc, opr, result, l, r,
				     NULL, NULL, ops);
}

// FP comparison using ar (address register) as return result
static TN *
Generate_FP_Comparison (OPERATOR opr, TYPE_ID rtype, TN *result, TN *l, TN *r, OPS *ops)
{
  FmtAssert(xt_hard_float, ("Cannot do FP compares without FP hardware"));
  Is_True(rtype == MTYPE_I4 || rtype == MTYPE_U4, 
          ("Expected MTYPE_I4 or MTYPE_U4 for FP compare result"));

  bool flip = false;
  TOP cmp = TOP_UNDEFINED, mov = TOP_UNDEFINED;

  switch (opr) {
    case OPR_EQ: 
      cmp = TI_TOP_Topcode("oeq.s");
      mov = TOP_movt;
      break;
    case OPR_NE: 
      cmp = TI_TOP_Topcode("oeq.s");
      mov = TOP_movf;
      break;
    case OPR_LT: 
      cmp = TI_TOP_Topcode("olt.s");
      mov = TOP_movt;
      break;
    case OPR_LE: 
      cmp = TI_TOP_Topcode("ole.s");
      mov = TOP_movt;
      break;
    case OPR_GT: 
      cmp = TI_TOP_Topcode("olt.s");
      mov = TOP_movt;
      flip = true;
      break;
    case OPR_GE: 
      cmp = TI_TOP_Topcode("ole.s");
      mov = TOP_movt;
      flip = true;
      break;
  }

  Is_True(cmp != TOP_UNDEFINED, ("Cannot find compare op for FP comparison"));
  Is_True(mov != TOP_UNDEFINED, ("Cannot find move op for FP comparison"));
  
  TN *orig_result = NULL;
  if (!result) {
    result = Build_TN_Of_Mtype(rtype);
  }
  if (TN_is_dedicated(result)) {
    orig_result = result;
    result = Build_TN_Of_Mtype(rtype);
  }

  TN* bres = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* state2 = cpenable_tn(cmp);
  if (flip) {
    if (state2)
      Build_OP(cmp, bres, r, l, state2 /* cpenable */, ops);
    else
      Build_OP(cmp, bres, r, l, ops);
  } else {
    if (state2)
      Build_OP(cmp, bres, l, r, state2 /* cpenable */, ops);
    else
      Build_OP(cmp, bres, l, r, ops);
  }
   
  TN *tmp = Generate_Constant(rtype, NULL, 1, ops);
  result = Generate_Constant(rtype, result, 0, ops);
  
  Build_OP(mov, result, result, tmp, bres, ops);

  if (orig_result) {
    result = Move_To_Register(rtype, orig_result, result, ops);
  }
  return result;
}

// FP comparison using br (boolean register) as return result
static TN *
Generate_FP_Comparison_br (OPERATOR opr, TN *result, TN *l, TN *r, OPS *ops)
{
  FmtAssert(xt_hard_float, ("Cannot do FP compares without FP hardware"));

  TOP cmp = TOP_UNDEFINED;

  switch (opr) {
    case OPR_EQ:
      cmp = TI_TOP_Topcode("oeq.s");
      break;
    case OPR_LT:
      cmp = TI_TOP_Topcode("olt.s");
      break;
    case OPR_LE:
      cmp = TI_TOP_Topcode("ole.s");
      break;
  }

  Is_True(cmp != TOP_UNDEFINED, ("Cannot find compare op for FP comparison"));

  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  } else {
    FmtAssert(TN_is_xtbool(result), ("Expected MTYPE_XTBOOL for FP compare result"));
  }

  TN* state2 = cpenable_tn(cmp);
  if (state2)
    Build_OP(cmp, result, l, r, state2 /* cpenable */, ops);
  else
    Build_OP(cmp, result, l, r, ops);

  return result;
}

static TN *
Generate_Logical_And_Conditional (WN *n, TYPE_ID desc, TOP br_top, TN *l, TN *r, OPS *ops)
{
  INT32 shift, size, imm;

  if (!TN_has_value(l) && TN_has_value(r)) {

    /* If 'r' is an immediate that can be used in a bbci/bbsi, then do
       that; otherwise we can use an extui feeding into a branch. */

    if (Get_Bbci_Bbsi_Immediate(TN_value(r), &imm))
    {
      switch (br_top)
      {
      case TOP_beq:
        br_top = TOP_bbc;
        break;
      
      case TOP_bne:
        br_top = TOP_bbs;
        break;

      default:
        FmtAssert(FALSE, ("unexpected topcode, %s\n", TI_TOP_Name(br_top)));
        break;
      }

      if (Target_Byte_Sex == BIG_ENDIAN)
        imm = 31 - imm;
    
      Generate_Branch(n, desc, br_top, Get_WN_Label(n), l, Gen_Literal_TN(imm, 4), ops);
    }
    else if (Get_Extui_Shift_Mask(TN_value(r), &shift, &size))
    {
      TN *cond = Build_TN_Of_Mtype(desc);
      Build_OP(TOP_extui, cond, l, Gen_Literal_TN(shift, 4), Gen_Literal_TN(size, 4), ops);
      Generate_Branch(n, desc, br_top, Get_WN_Label(n), cond, Gen_Literal_TN(0, 4), ops);
    }
    else
      FmtAssert(FALSE, ("unexpected immediate, %d\n", TN_value(r)));
  }

  else
  {
    /* recognize non-immediate version of bbc/bbs */
    if (br_top == TOP_beq)
      br_top = TOP_bbc;
    else if (br_top == TOP_bne)
      br_top = TOP_bbs;
    else 
      FmtAssert(FALSE, ("unexpected topcode, %s\n", TI_TOP_Name(br_top)));

    TN *mask = r;
    if (Target_Byte_Sex == BIG_ENDIAN) {
      mask = Build_TN_Of_Mtype(desc);
      Generate_Sub(desc, mask, Gen_Literal_TN(31, 4), r, ops);
    }

    Generate_Branch(n, desc, br_top, Get_WN_Label(n), l, mask, ops);
  }

  return 0;
}

static TN *
Generate_Compose(WN *n, TYPE_ID rtype, TYPE_ID desc,
		 TN *result, TN *into, TN *from, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  INT offset = WN_bit_offset(n);
  INT size = WN_bit_size(n);

//  if (Target_Byte_Sex == BIG_ENDIAN)
//    offset = MTYPE_bit_size(desc) - offset - size;

  Is_True((offset >= 0) && (size >= 0),
	  ("unexpected offset %d or size %d", offset, size));
  
  TN *insert = Build_TN_Of_Mtype(rtype);

  /* Mask and position the bits in 'from' so they are ready for
     insertion to 'into'. */
  if ((offset == 0) && (size <= 16))
  {
    Build_OP(TOP_extui, insert, from, Gen_Literal_TN(0, 4), Gen_Literal_TN(size, 4), ops);
  }
  else
  {
    UINT rsh = 32 - size - offset;
    Build_OP(TOP_slli, insert, from, Gen_Literal_TN(32 - size, 4), ops);
    Build_OP(TOP_srli, insert, insert, Gen_Literal_TN(32 - size - offset, 4), ops);
  }

  /* Mask bits out of 'into'. */
  UINT mask_val = ~(((1 << size) - 1) << offset);
  TN *mask = Generate_Constant(MTYPE_U4, NULL, mask_val, ops);

  TN *compose = Build_TN_Of_Mtype(rtype);
  Build_OP(TOP_and, compose, into, mask, ops);

  /* Insert 'insert' into 'compose'. */
  Build_OP(TOP_or, result, compose, insert, ops);

  return result;
}

static TN *
Generate_Extract (WN *n, TYPE_ID rtype, TYPE_ID desc, TN *result, TN *src, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  /* If 'desc' is smaller than 'rtype', then we must sign or zero
     extend 'src' to get it the same size as rtype. */
  FmtAssert((rtype == MTYPE_U4) || (rtype == MTYPE_I4),
	    ("expecting result MTYPE_U4 or MTYPE_I4, got %d", rtype));

  if ((desc == MTYPE_I1) || (desc == MTYPE_I2)
      || (desc == MTYPE_U1) || (desc == MTYPE_U2))
  {
    TN *tmp = Build_TN_Of_Mtype(rtype);
    src = Generate_Extend(desc, tmp, src, MTYPE_bit_size(desc), ops);
  }
  
  INT offset = WN_bit_offset(n);
  INT size = WN_bit_size(n);

//  if (Target_Byte_Sex == BIG_ENDIAN)
//    offset = MTYPE_bit_size(desc) - offset - size;

  Is_True((offset >= 0) && (size >= 0),
	  ("unexpected offset %d or size %d", offset, size));

  /* For unsigned result, we use extui when possible. */
  if (MTYPE_is_unsigned(rtype) && (size <= 16))
  {
    Build_OP(TOP_extui, result, src, Gen_Literal_TN(offset, 4), Gen_Literal_TN(size, 4), ops);
  }
  else
  {
    TN *tmp = Build_TN_Of_Mtype(rtype);
    Build_OP(TOP_slli, tmp, src, Gen_Literal_TN(32 - size - offset, 4), ops);
    Build_OP(MTYPE_is_unsigned(rtype) ? TOP_srli : TOP_srai,
	     result, tmp, Gen_Literal_TN(32 - size, 4), ops);
  }

  return result;
}


static TN *
Generate_IStoreLda_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc, TN *bits_tn, OPS *ops)
{
  WN *kid0 = WN_kid0(n);
  WN *kid1 = WN_kid1(n);

  // guard against U1MPY or U2MPY
  if (MTYPE_byte_size(rtype) < 4)
    rtype = Mtype_TransferSize(MTYPE_U4, rtype);
  if (MTYPE_byte_size(WN_rtype(kid0)) > MTYPE_byte_size(rtype)) 
    rtype = Mtype_TransferSize(WN_rtype(kid0), rtype);

  TN *field_tn = Generate_Load_Memory(n, rtype, desc, 0, WN_st(kid1), 
				      WN_store_offset(n) + WN_lda_offset(kid1), Variant_ISTORE(n), ops);
  TN *comp = Generate_Compose(n, rtype, desc, 0, field_tn, bits_tn, ops);
  Generate_Store_Memory(n, desc, comp, WN_st(kid1),
			WN_store_offset(n) + WN_lda_offset(kid1), Variant_ISTORE(n), ops);
  return comp;
}

static TN *
Generate_IStore_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc, TN *bits_tn, 
		      TN *addr_tn, OPS *ops)
{
  WN *kid0 = WN_kid0(n);
  WN *kid1 = WN_kid1(n);

  // guard against U1MPY or U2MPY
  if (MTYPE_byte_size(rtype) < 4)
    rtype = Mtype_TransferSize(MTYPE_U4, rtype);
  if (MTYPE_byte_size(WN_rtype(kid0)) > MTYPE_byte_size(rtype)) 
    rtype = Mtype_TransferSize(WN_rtype(kid0), rtype);

  TN *field_tn = Generate_Load_Memory(n, rtype, desc, 0,
				      addr_tn, WN_store_offset(n), Variant_ISTORE(n), ops);
  TN *comp = Generate_Compose(n, rtype, desc, 0, field_tn, bits_tn, ops);
  Generate_Store_Memory(n, desc, comp, addr_tn, WN_store_offset(n), Variant_ISTORE(n), ops);
  return comp;
}


static TN *
Generate_ILoadLda_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc,
			TN *result, OPS *ops)
{
  WN *kid0 = WN_kid0(n);

  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  TN *src_tn = Generate_Load_Memory(n, rtype, desc, 0, WN_st(kid0),
				    WN_offset(n) + WN_lda_offset(kid0),
				    Variant_ILOAD(n), ops);
  return Generate_Extract(n, rtype, desc, result, src_tn, ops);
}

static TN *
Generate_ILoad_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc,
		     TN *result, TN *addr_tn, OPS *ops)
{
  TN *src_tn = Generate_Load_Memory(n, rtype, desc, 0,
				    addr_tn, WN_offset(n), Variant_ILOAD(n), ops);
  return Generate_Extract(n, rtype, desc, result, src_tn, ops);
}

static TN *
Generate_Alloca (TYPE_ID rtype, TN *result, TN *adjust, OPS *ops)
{
  /* We adjust the stack by the size indicated in 'adjust', plus size
     needed for any outgoing arguments, plus any padding necessary to
     reach Stack_Alignment. Both the space allocated for the object,
     and the new SP are aligned to Stack_Alignment. */
  
  /* Align 'adjust' up to the stack alignment. */
  if (TN_has_value(adjust))
  {
    INT64 size; 
    size = TN_value(adjust);
    size += Stack_Alignment() - 1;
    size &= -Stack_Alignment();
    adjust = Gen_Literal_TN(size, Pointer_Size);
  }
  else
  {
    TN *c0 = Generate_Constant(MTYPE_I4, NULL, Stack_Alignment()-1, ops);
    TN *tn1 = Generate_Binary(TN_mtype(adjust), TOP_add, NULL,
			      adjust, c0, ops);
    TN *c1 = Generate_Constant(MTYPE_I4, NULL, -Stack_Alignment(), ops);
    adjust = Generate_Binary(TN_mtype(adjust), TOP_and, NULL,
			     tn1, c1, ops);
  }

  result = Generate_Sub(rtype, result, SP_TN, adjust, ops);

  /* We only need to move the sp if 'adjust' is non-zero. */

  if (!TN_has_value(adjust) || (TN_value(adjust) != 0))
  {
    /* If we have actuals, we must make space for them below the
       alloca space. We align the needed actual space to
       Stack_Alignment. */
    TN *actuals = result;
    if (Current_PU_Actual_Size)
    {
      INT64 size = Current_PU_Actual_Size;
      size += Stack_Alignment() - 1;
      size &= -Stack_Alignment();
      actuals = Generate_Sub(rtype, NULL, result, Gen_Literal_TN(size, Pointer_Size), ops);
    }
    
    /* call0: this seems inefficient, but the optimizer will fix it if it can */
    if (Target_ABI == ABI_WINDOWED)
      Generate_Unary(rtype, TOP_movsp, SP_TN, actuals, ops);
    else
      Generate_Unary(rtype, TOP_mov_n, SP_TN, actuals, ops);
  }

  return result;
}

static void
Generate_Dealloca (TYPE_ID rtype, TN *newsp, OPS *ops)
{
    /* call0: this seems inefficient, but the optimizer will fix it if it can */
  if (Target_ABI == ABI_WINDOWED)
    Generate_Unary(rtype, TOP_movsp, SP_TN, newsp, ops);
  else
    Generate_Unary(rtype, TOP_mov_n, SP_TN, newsp, ops);
}

static TN *
Generate_MINMAX (TYPE_ID mtype, TOP orig_op, OPERATOR cond_op,
		 TN *result, TN *left, TN *right, OPS *ops)
{
  if( xt_minmax ) {
    return Generate_Binary(mtype, orig_op, result,
			   left, right, ops );
  }
  else {
    return Generate_Conditional_Select(mtype, mtype, cond_op, result, 
				       left, right, left, right, ops);
  }

  return result;
}

static TN *
Generate_Clamps (TYPE_ID rtype, TN *result, TN *src, TN *imm, OPS *ops)
{
  Is_True(TN_is_register(src) && TN_has_value(imm), (""));
  FmtAssert(TARG_INT_Pop_Count(TN_value(imm) + 1) == 1, ("expecting power of 2"));

  /* 'imm' is the positive clamp immediate, e.g. 255, 511, ... */
  INT64 imm2 = TARG_INT_Least_Sig_One(TN_value(imm) + 1);
  return Generate_Binary(rtype, TOP_clamps, result,
			 src, Gen_Literal_TN(imm2, 4), ops);
}


// the following implements a simple mapping between a pair of reg TNs
// the map needs to be reset at the end of usage

static TN* reg1=NULL;
static TN* reg2=NULL;
static TN* get_reg_tn_pair(TN* in_tn) {
  TN* result=NULL;
  if (reg1==in_tn) result=reg2;
  else if (reg2==in_tn) result=reg1;
  else Is_True(FALSE,("Missing reg pair"));

  reg1=reg2=NULL;

  return result;
}
static void set_reg_tn_pair(TN* tn1, TN* tn2) {
  //Is_True(reg1==NULL && reg2==NULL, ("Bad reg pair"));
  Is_True(TN_is_register(tn1) && TN_is_register(tn2), ("Bad reg pair"));
  reg1 = tn1; reg2 = tn2;
}



#if !defined(ISEL_INITIAL_MAX_DYNAMIC_RULES)
#define ISEL_INITIAL_MAX_DYNAMIC_RULES 1024
#endif
#if !defined(ISEL_MAX_NT)
#define ISEL_MAX_NT 64
#endif
#define ISEL_NT_BITVECTOR_SIZE (((ISEL_MAX_NT)+31)>>5)
#define ISEL_NUM_PRECOMPILED_RULES 706

class ISEL {
public:
  // typedefs
  class Rule_info;
  class Chain_rule_info;
  class State;
  typedef int Rule;
  typedef unsigned int Nonterm;
  typedef State *(Precompiled_labeller_func)(NODEPTR);
  typedef bool (Labeller_func)(NODEPTR, COST &);
  typedef /* line 2283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (stmt_action_type)(ISEL::State *, /* line 2283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (expr_action_type)(ISEL::State *, /* line 2235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (areg_action_type)(ISEL::State *, /* line 2236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (breg_action_type)(ISEL::State *, /* line 2237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2238 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (bareg_action_type)(ISEL::State *, /* line 2238 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (b1reg_action_type)(ISEL::State *, /* line 2239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (freg_action_type)(ISEL::State *, /* line 2240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (tie_reg_action_type)(ISEL::State *, /* line 2241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2242 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (tie_cvt_reg_action_type)(ISEL::State *, /* line 2242 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (ll_cvt_areg_action_type)(ISEL::State *, /* line 2243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void (acc_reg_action_type)(ISEL::State *, /* line 2244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2245 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (tie_imm_action_type)(ISEL::State *);
  typedef /* line 2246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (wsar_action_type)(ISEL::State *, /* line 2246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops);
  typedef /* line 2247 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (sar_left_action_type)(ISEL::State *, /* line 2247 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops);
  typedef /* line 2248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (sar_right_action_type)(ISEL::State *, /* line 2248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops);
  typedef /* line 2249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (areg_or_simm12_action_type)(ISEL::State *, /* line 2249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (areg_or_simm8_action_type)(ISEL::State *, /* line 2250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (areg_or_b4const_action_type)(ISEL::State *, /* line 2251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (areg_or_b4constu_action_type)(ISEL::State *, /* line 2252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2253 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (extui_mask_action_type)(ISEL::State *);
  typedef /* line 2254 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (bbci_bbsi_imm_action_type)(ISEL::State *);
  typedef /* line 2255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (logical_and_immed_action_type)(ISEL::State *, /* line 2255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
  typedef /* line 2256 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (clamps_const_action_type)(ISEL::State *);
  typedef /* line 2257 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (simm8x256_action_type)(ISEL::State *);
  typedef /* line 2260 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (simm8_action_type)(ISEL::State *);
  typedef /* line 2261 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (simm12_action_type)(ISEL::State *);
  typedef /* line 2263 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (simm32_action_type)(ISEL::State *);
  typedef /* line 2266 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (uimm4_action_type)(ISEL::State *);
  typedef /* line 2267 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (uimm5_action_type)(ISEL::State *);
  typedef /* line 2272 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (b4constu_action_type)(ISEL::State *);
  typedef /* line 2273 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (b4const_action_type)(ISEL::State *);
  typedef /* line 2277 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * (msalp32_action_type)(ISEL::State *);
  typedef /* line 2278 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void (zero_action_type)(ISEL::State *);
  typedef /* line 2279 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void (one_action_type)(ISEL::State *);
  typedef /* line 2280 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void (thirtytwo_action_type)(ISEL::State *);
  typedef /* line 2281 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
INT32 (float_const_action_type)(ISEL::State *);
  union Action_type {
    void *none;
    stmt_action_type *_stmt;
    expr_action_type *_expr;
    areg_action_type *_areg;
    breg_action_type *_breg;
    bareg_action_type *_bareg;
    b1reg_action_type *_b1reg;
    freg_action_type *_freg;
    tie_reg_action_type *_tie_reg;
    tie_cvt_reg_action_type *_tie_cvt_reg;
    ll_cvt_areg_action_type *_ll_cvt_areg;
    acc_reg_action_type *_acc_reg;
    tie_imm_action_type *_tie_imm;
    wsar_action_type *_wsar;
    sar_left_action_type *_sar_left;
    sar_right_action_type *_sar_right;
    areg_or_simm12_action_type *_areg_or_simm12;
    areg_or_simm8_action_type *_areg_or_simm8;
    areg_or_b4const_action_type *_areg_or_b4const;
    areg_or_b4constu_action_type *_areg_or_b4constu;
    extui_mask_action_type *_extui_mask;
    bbci_bbsi_imm_action_type *_bbci_bbsi_imm;
    logical_and_immed_action_type *_logical_and_immed;
    clamps_const_action_type *_clamps_const;
    simm8x256_action_type *_simm8x256;
    simm8_action_type *_simm8;
    simm12_action_type *_simm12;
    simm32_action_type *_simm32;
    uimm4_action_type *_uimm4;
    uimm5_action_type *_uimm5;
    b4constu_action_type *_b4constu;
    b4const_action_type *_b4const;
    msalp32_action_type *_msalp32;
    zero_action_type *_zero;
    one_action_type *_one;
    thirtytwo_action_type *_thirtytwo;
    float_const_action_type *_float_const;
  };
  enum {
    stmt_NT=1,
    expr_NT=2,
    areg_NT=3,
    breg_NT=4,
    bareg_NT=5,
    b1reg_NT=6,
    freg_NT=7,
    tie_reg_NT=8,
    tie_cvt_reg_NT=9,
    ll_cvt_areg_NT=10,
    acc_reg_NT=11,
    tie_imm_NT=12,
    wsar_NT=13,
    sar_left_NT=14,
    sar_right_NT=15,
    areg_or_simm12_NT=16,
    areg_or_simm8_NT=17,
    areg_or_b4const_NT=18,
    areg_or_b4constu_NT=19,
    extui_mask_NT=20,
    bbci_bbsi_imm_NT=21,
    logical_and_immed_NT=22,
    clamps_const_NT=23,
    simm8x256_NT=24,
    simm8_NT=25,
    simm12_NT=26,
    simm32_NT=27,
    uimm4_NT=28,
    uimm5_NT=29,
    b4constu_NT=30,
    b4const_NT=31,
    msalp32_NT=32,
    zero_NT=33,
    one_NT=34,
    thirtytwo_NT=35,
    float_const_NT=36,
  };
  static int max_nt;
  static int max_dynamic_rules;
  static int num_dynamic_rules;
  static Rule_info *dynamic_rules;
  static const char *ntname[ISEL_MAX_NT];
  static Rule_info *ntchains[ISEL_MAX_NT];
  struct Match {
    COST cost;
    Rule rule_num;
  };
  struct State {
    int op;
    NODEPTR node;
    int arity;
    State **kids;
    Match *matches;
    unsigned has_match[ISEL_NT_BITVECTOR_SIZE];
    void set_match(Nonterm nt,COST &,Rule r);
    bool has_match_for(Nonterm nt);
  };

  struct Exception {
    char *reason;
    NODEPTR node;
    Exception(char *r,NODEPTR u): reason(r),node(u) {}
  };
  struct Rule_info { // for dynamic rules 
  int op;
    Nonterm lhs;
    Nonterm rhs;
    Labeller_func *f;
    Action_type action;
    Rule_info *next;
    inline bool is_chain_rule(void) const { return rhs!=0; }
  };
  struct Op_info {
    int op;
    Precompiled_labeller_func *labeller;
    Rule_info *dynamic_rules;
  };
  // User-provided static functions
  static Op_info *find_op_info( int opc );
  static void add_op_info( int opc, Op_info *);
  static State *STATE_LABEL(NODEPTR p);
  static void SET_STATE(NODEPTR p, State *s);
  // ALLOC_FOR_TREE for objects whose lifetime same as a tree
  // ALLOC for more persistent objects
  static void *ALLOC_FOR_TREE( int size );
  static void *ALLOC( int size );
  static void *REALLOC(void *, int old_size, int new_size);

  // Generated functions
  static State *label(NODEPTR);
  static bool match(NODEPTR, Nonterm, COST &);
  static State *label1(NODEPTR);
  static void closure(State *s,Nonterm rhs);
  static void initialize(void);
  static Rule rule_no(Rule_info *);
  static State *alloc_state(NODEPTR u,int arity);
  static Rule ISEL::rule(ISEL::State *state,int goalnt);
  static Nonterm add_nonterm( const char *name);
  static Rule_info *alloc_rule(void);
  static Rule add_rule( int opc, Nonterm nt, int arity, Labeller_func f);
  static Rule add_chain_rule( Nonterm lhs, Nonterm rhs, Labeller_func f);
  static Nonterm find_nonterm(const char *n);
  static Rule_info *get_dynamic_rule(Rule r) {
    assert( (int)r >= ISEL_NUM_PRECOMPILED_RULES );
    assert( (int)r-ISEL_NUM_PRECOMPILED_RULES < num_dynamic_rules );
    return &dynamic_rules[(int)r-ISEL_NUM_PRECOMPILED_RULES];
  }

  static void add_stmt_action(Rule r, stmt_action_type *a) {
    get_dynamic_rule(r)->action._stmt = a;
  }
  static void add_expr_action(Rule r, expr_action_type *a) {
    get_dynamic_rule(r)->action._expr = a;
  }
  static void add_areg_action(Rule r, areg_action_type *a) {
    get_dynamic_rule(r)->action._areg = a;
  }
  static void add_breg_action(Rule r, breg_action_type *a) {
    get_dynamic_rule(r)->action._breg = a;
  }
  static void add_bareg_action(Rule r, bareg_action_type *a) {
    get_dynamic_rule(r)->action._bareg = a;
  }
  static void add_b1reg_action(Rule r, b1reg_action_type *a) {
    get_dynamic_rule(r)->action._b1reg = a;
  }
  static void add_freg_action(Rule r, freg_action_type *a) {
    get_dynamic_rule(r)->action._freg = a;
  }
  static void add_tie_reg_action(Rule r, tie_reg_action_type *a) {
    get_dynamic_rule(r)->action._tie_reg = a;
  }
  static void add_tie_cvt_reg_action(Rule r, tie_cvt_reg_action_type *a) {
    get_dynamic_rule(r)->action._tie_cvt_reg = a;
  }
  static void add_ll_cvt_areg_action(Rule r, ll_cvt_areg_action_type *a) {
    get_dynamic_rule(r)->action._ll_cvt_areg = a;
  }
  static void add_acc_reg_action(Rule r, acc_reg_action_type *a) {
    get_dynamic_rule(r)->action._acc_reg = a;
  }
  static void add_tie_imm_action(Rule r, tie_imm_action_type *a) {
    get_dynamic_rule(r)->action._tie_imm = a;
  }
  static void add_wsar_action(Rule r, wsar_action_type *a) {
    get_dynamic_rule(r)->action._wsar = a;
  }
  static void add_sar_left_action(Rule r, sar_left_action_type *a) {
    get_dynamic_rule(r)->action._sar_left = a;
  }
  static void add_sar_right_action(Rule r, sar_right_action_type *a) {
    get_dynamic_rule(r)->action._sar_right = a;
  }
  static void add_areg_or_simm12_action(Rule r, areg_or_simm12_action_type *a) {
    get_dynamic_rule(r)->action._areg_or_simm12 = a;
  }
  static void add_areg_or_simm8_action(Rule r, areg_or_simm8_action_type *a) {
    get_dynamic_rule(r)->action._areg_or_simm8 = a;
  }
  static void add_areg_or_b4const_action(Rule r, areg_or_b4const_action_type *a) {
    get_dynamic_rule(r)->action._areg_or_b4const = a;
  }
  static void add_areg_or_b4constu_action(Rule r, areg_or_b4constu_action_type *a) {
    get_dynamic_rule(r)->action._areg_or_b4constu = a;
  }
  static void add_extui_mask_action(Rule r, extui_mask_action_type *a) {
    get_dynamic_rule(r)->action._extui_mask = a;
  }
  static void add_bbci_bbsi_imm_action(Rule r, bbci_bbsi_imm_action_type *a) {
    get_dynamic_rule(r)->action._bbci_bbsi_imm = a;
  }
  static void add_logical_and_immed_action(Rule r, logical_and_immed_action_type *a) {
    get_dynamic_rule(r)->action._logical_and_immed = a;
  }
  static void add_clamps_const_action(Rule r, clamps_const_action_type *a) {
    get_dynamic_rule(r)->action._clamps_const = a;
  }
  static void add_simm8x256_action(Rule r, simm8x256_action_type *a) {
    get_dynamic_rule(r)->action._simm8x256 = a;
  }
  static void add_simm8_action(Rule r, simm8_action_type *a) {
    get_dynamic_rule(r)->action._simm8 = a;
  }
  static void add_simm12_action(Rule r, simm12_action_type *a) {
    get_dynamic_rule(r)->action._simm12 = a;
  }
  static void add_simm32_action(Rule r, simm32_action_type *a) {
    get_dynamic_rule(r)->action._simm32 = a;
  }
  static void add_uimm4_action(Rule r, uimm4_action_type *a) {
    get_dynamic_rule(r)->action._uimm4 = a;
  }
  static void add_uimm5_action(Rule r, uimm5_action_type *a) {
    get_dynamic_rule(r)->action._uimm5 = a;
  }
  static void add_b4constu_action(Rule r, b4constu_action_type *a) {
    get_dynamic_rule(r)->action._b4constu = a;
  }
  static void add_b4const_action(Rule r, b4const_action_type *a) {
    get_dynamic_rule(r)->action._b4const = a;
  }
  static void add_msalp32_action(Rule r, msalp32_action_type *a) {
    get_dynamic_rule(r)->action._msalp32 = a;
  }
  static void add_zero_action(Rule r, zero_action_type *a) {
    get_dynamic_rule(r)->action._zero = a;
  }
  static void add_one_action(Rule r, one_action_type *a) {
    get_dynamic_rule(r)->action._one = a;
  }
  static void add_thirtytwo_action(Rule r, thirtytwo_action_type *a) {
    get_dynamic_rule(r)->action._thirtytwo = a;
  }
  static void add_float_const_action(Rule r, float_const_action_type *a) {
    get_dynamic_rule(r)->action._float_const = a;
  }
};

#ifndef ISEL_assert
#define ISEL_assert(x,y) if (!(x)) {  y; abort(); }
#endif

int ISEL::max_nt = 37;

int ISEL::max_dynamic_rules = 0;
int ISEL::num_dynamic_rules = 0;
const char *ISEL::ntname[ISEL_MAX_NT] = {
  0,
  "stmt",
  "expr",
  "areg",
  "breg",
  "bareg",
  "b1reg",
  "freg",
  "tie_reg",
  "tie_cvt_reg",
  "ll_cvt_areg",
  "acc_reg",
  "tie_imm",
  "wsar",
  "sar_left",
  "sar_right",
  "areg_or_simm12",
  "areg_or_simm8",
  "areg_or_b4const",
  "areg_or_b4constu",
  "extui_mask",
  "bbci_bbsi_imm",
  "logical_and_immed",
  "clamps_const",
  "simm8x256",
  "simm8",
  "simm12",
  "simm32",
  "uimm4",
  "uimm5",
  "b4constu",
  "b4const",
  "msalp32",
  "zero",
  "one",
  "thirtytwo",
  "float_const",
  0
};

static short ISEL_nts_0[] = { ISEL::expr_NT, 0 };
static short ISEL_nts_1[] = { 0 };
static short ISEL_nts_2[] = { ISEL::areg_or_simm8_NT, 0 };
static short ISEL_nts_3[] = { ISEL::areg_NT, 0 };
static short ISEL_nts_4[] = { ISEL::one_NT, 0 };
static short ISEL_nts_5[] = { ISEL::b1reg_NT, 0 };
static short ISEL_nts_6[] = { ISEL::freg_NT, ISEL::freg_NT, 0 };
static short ISEL_nts_7[] = { ISEL::areg_or_b4const_NT, ISEL::areg_or_b4const_NT, 0 };
static short ISEL_nts_8[] = { ISEL::areg_or_b4constu_NT, ISEL::areg_or_b4constu_NT, 0 };
static short ISEL_nts_9[] = { ISEL::areg_NT, ISEL::logical_and_immed_NT, ISEL::zero_NT, 0 };
static short ISEL_nts_10[] = { ISEL::logical_and_immed_NT, ISEL::areg_NT, ISEL::zero_NT, 0 };
static short ISEL_nts_11[] = { ISEL::zero_NT, ISEL::areg_NT, ISEL::logical_and_immed_NT, 0 };
static short ISEL_nts_12[] = { ISEL::zero_NT, ISEL::logical_and_immed_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_13[] = { ISEL::zero_NT, ISEL::areg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_14[] = { ISEL::areg_NT, ISEL::areg_NT, ISEL::zero_NT, 0 };
static short ISEL_nts_15[] = { ISEL::areg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_16[] = { ISEL::areg_NT, ISEL::bbci_bbsi_imm_NT, ISEL::zero_NT, 0 };
static short ISEL_nts_17[] = { ISEL::areg_NT, ISEL::areg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_18[] = { ISEL::areg_NT, ISEL::freg_NT, ISEL::freg_NT, 0 };
static short ISEL_nts_19[] = { ISEL::areg_or_simm8_NT, ISEL::areg_or_simm8_NT, ISEL::areg_or_simm12_NT, ISEL::areg_or_simm12_NT, 0 };
static short ISEL_nts_20[] = { ISEL::b1reg_NT, ISEL::areg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_21[] = { ISEL::b1reg_NT, ISEL::freg_NT, ISEL::freg_NT, 0 };
static short ISEL_nts_22[] = { ISEL::freg_NT, ISEL::freg_NT, ISEL::freg_NT, ISEL::freg_NT, 0 };
static short ISEL_nts_23[] = { ISEL::areg_NT, ISEL::breg_NT, ISEL::breg_NT, 0 };
static short ISEL_nts_24[] = { ISEL::freg_NT, 0 };
static short ISEL_nts_25[] = { ISEL::freg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_26[] = { ISEL::tie_reg_NT, 0 };
static short ISEL_nts_27[] = { ISEL::tie_cvt_reg_NT, 0 };
static short ISEL_nts_28[] = { ISEL::ll_cvt_areg_NT, 0 };
static short ISEL_nts_29[] = { ISEL::breg_NT, 0 };
static short ISEL_nts_30[] = { ISEL::areg_NT, ISEL::areg_or_simm8_NT, 0 };
static short ISEL_nts_31[] = { ISEL::simm8_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_32[] = { ISEL::areg_NT, ISEL::simm8x256_NT, 0 };
static short ISEL_nts_33[] = { ISEL::simm8x256_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_34[] = { ISEL::areg_NT, ISEL::clamps_const_NT, ISEL::clamps_const_NT, 0 };
static short ISEL_nts_35[] = { ISEL::clamps_const_NT, ISEL::areg_NT, ISEL::clamps_const_NT, 0 };
static short ISEL_nts_36[] = { ISEL::clamps_const_NT, ISEL::clamps_const_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_37[] = { ISEL::freg_NT, ISEL::freg_NT, ISEL::freg_NT, 0 };
static short ISEL_nts_38[] = { ISEL::areg_NT, ISEL::extui_mask_NT, 0 };
static short ISEL_nts_39[] = { ISEL::extui_mask_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_40[] = { ISEL::areg_NT, ISEL::one_NT, ISEL::one_NT, 0 };
static short ISEL_nts_41[] = { ISEL::areg_NT, ISEL::msalp32_NT, 0 };
static short ISEL_nts_42[] = { ISEL::areg_NT, ISEL::uimm5_NT, 0 };
static short ISEL_nts_43[] = { ISEL::areg_NT, ISEL::uimm4_NT, 0 };
static short ISEL_nts_44[] = { ISEL::areg_NT, ISEL::sar_left_NT, 0 };
static short ISEL_nts_45[] = { ISEL::areg_NT, ISEL::sar_right_NT, 0 };
static short ISEL_nts_46[] = { ISEL::areg_NT, ISEL::wsar_NT, ISEL::areg_NT, ISEL::thirtytwo_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_47[] = { ISEL::areg_NT, ISEL::thirtytwo_NT, ISEL::areg_NT, ISEL::areg_NT, ISEL::wsar_NT, 0 };
static short ISEL_nts_48[] = { ISEL::areg_NT, ISEL::areg_NT, ISEL::msalp32_NT, 0 };
static short ISEL_nts_49[] = { ISEL::areg_NT, ISEL::msalp32_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_50[] = { ISEL::acc_reg_NT, ISEL::areg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_51[] = { ISEL::areg_NT, ISEL::areg_NT, ISEL::acc_reg_NT, 0 };
static short ISEL_nts_52[] = { ISEL::acc_reg_NT, 0 };
static short ISEL_nts_53[] = { ISEL::simm12_NT, 0 };
static short ISEL_nts_54[] = { ISEL::simm32_NT, 0 };
static short ISEL_nts_55[] = { ISEL::float_const_NT, 0 };
static short ISEL_nts_56[] = { ISEL::simm8_NT, 0 };
static short ISEL_nts_57[] = { ISEL::b4const_NT, 0 };
static short ISEL_nts_58[] = { ISEL::b4constu_NT, 0 };
static short ISEL_nts_59[] = { ISEL::one_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_60[] = { ISEL::tie_imm_NT, 0 };
static short ISEL_nts_61[] = { ISEL::bareg_NT, 0 };
static short ISEL_nts_62[] = { ISEL::breg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_63[] = { ISEL::bareg_NT, ISEL::areg_NT, 0 };
static short ISEL_nts_64[] = { ISEL::b1reg_NT, ISEL::b1reg_NT, 0 };

short *ISEL_nts[] = {
  ISEL_nts_0,  /* 0 */
  ISEL_nts_0,  /* 1 */
  ISEL_nts_1,  /* 2 */
  ISEL_nts_2,  /* 3 */
  ISEL_nts_3,  /* 4 */
  ISEL_nts_1,  /* 5 */
  ISEL_nts_1,  /* 6 */
  ISEL_nts_1,  /* 7 */
  ISEL_nts_1,  /* 8 */
  ISEL_nts_1,  /* 9 */
  ISEL_nts_1,  /* 10 */
  ISEL_nts_1,  /* 11 */
  ISEL_nts_1,  /* 12 */
  ISEL_nts_1,  /* 13 */
  ISEL_nts_1,  /* 14 */
  ISEL_nts_1,  /* 15 */
  ISEL_nts_1,  /* 16 */
  ISEL_nts_1,  /* 17 */
  ISEL_nts_1,  /* 18 */
  ISEL_nts_1,  /* 19 */
  ISEL_nts_1,  /* 20 */
  ISEL_nts_1,  /* 21 */
  ISEL_nts_1,  /* 22 */
  ISEL_nts_1,  /* 23 */
  ISEL_nts_1,  /* 24 */
  ISEL_nts_1,  /* 25 */
  ISEL_nts_1,  /* 26 */
  ISEL_nts_1,  /* 27 */
  ISEL_nts_1,  /* 28 */
  ISEL_nts_1,  /* 29 */
  ISEL_nts_1,  /* 30 */
  ISEL_nts_1,  /* 31 */
  ISEL_nts_1,  /* 32 */
  ISEL_nts_1,  /* 33 */
  ISEL_nts_1,  /* 34 */
  ISEL_nts_3,  /* 35 */
  ISEL_nts_3,  /* 36 */
  ISEL_nts_4,  /* 37 */
  ISEL_nts_3,  /* 38 */
  ISEL_nts_3,  /* 39 */
  ISEL_nts_5,  /* 40 */
  ISEL_nts_6,  /* 41 */
  ISEL_nts_6,  /* 42 */
  ISEL_nts_5,  /* 43 */
  ISEL_nts_5,  /* 44 */
  ISEL_nts_5,  /* 45 */
  ISEL_nts_6,  /* 46 */
  ISEL_nts_6,  /* 47 */
  ISEL_nts_5,  /* 48 */
  ISEL_nts_5,  /* 49 */
  ISEL_nts_7,  /* 50 */
  ISEL_nts_7,  /* 51 */
  ISEL_nts_8,  /* 52 */
  ISEL_nts_8,  /* 53 */
  ISEL_nts_8,  /* 54 */
  ISEL_nts_5,  /* 55 */
  ISEL_nts_5,  /* 56 */
  ISEL_nts_5,  /* 57 */
  ISEL_nts_5,  /* 58 */
  ISEL_nts_5,  /* 59 */
  ISEL_nts_7,  /* 60 */
  ISEL_nts_7,  /* 61 */
  ISEL_nts_8,  /* 62 */
  ISEL_nts_8,  /* 63 */
  ISEL_nts_8,  /* 64 */
  ISEL_nts_8,  /* 65 */
  ISEL_nts_7,  /* 66 */
  ISEL_nts_7,  /* 67 */
  ISEL_nts_8,  /* 68 */
  ISEL_nts_8,  /* 69 */
  ISEL_nts_8,  /* 70 */
  ISEL_nts_8,  /* 71 */
  ISEL_nts_7,  /* 72 */
  ISEL_nts_7,  /* 73 */
  ISEL_nts_8,  /* 74 */
  ISEL_nts_8,  /* 75 */
  ISEL_nts_8,  /* 76 */
  ISEL_nts_8,  /* 77 */
  ISEL_nts_7,  /* 78 */
  ISEL_nts_7,  /* 79 */
  ISEL_nts_8,  /* 80 */
  ISEL_nts_8,  /* 81 */
  ISEL_nts_8,  /* 82 */
  ISEL_nts_8,  /* 83 */
  ISEL_nts_7,  /* 84 */
  ISEL_nts_7,  /* 85 */
  ISEL_nts_7,  /* 86 */
  ISEL_nts_7,  /* 87 */
  ISEL_nts_7,  /* 88 */
  ISEL_nts_7,  /* 89 */
  ISEL_nts_7,  /* 90 */
  ISEL_nts_7,  /* 91 */
  ISEL_nts_7,  /* 92 */
  ISEL_nts_7,  /* 93 */
  ISEL_nts_7,  /* 94 */
  ISEL_nts_7,  /* 95 */
  ISEL_nts_7,  /* 96 */
  ISEL_nts_7,  /* 97 */
  ISEL_nts_7,  /* 98 */
  ISEL_nts_7,  /* 99 */
  ISEL_nts_7,  /* 100 */
  ISEL_nts_7,  /* 101 */
  ISEL_nts_7,  /* 102 */
  ISEL_nts_7,  /* 103 */
  ISEL_nts_7,  /* 104 */
  ISEL_nts_7,  /* 105 */
  ISEL_nts_7,  /* 106 */
  ISEL_nts_7,  /* 107 */
  ISEL_nts_9,  /* 108 */
  ISEL_nts_10,  /* 109 */
  ISEL_nts_11,  /* 110 */
  ISEL_nts_12,  /* 111 */
  ISEL_nts_13,  /* 112 */
  ISEL_nts_14,  /* 113 */
  ISEL_nts_9,  /* 114 */
  ISEL_nts_10,  /* 115 */
  ISEL_nts_11,  /* 116 */
  ISEL_nts_12,  /* 117 */
  ISEL_nts_13,  /* 118 */
  ISEL_nts_14,  /* 119 */
  ISEL_nts_9,  /* 120 */
  ISEL_nts_10,  /* 121 */
  ISEL_nts_11,  /* 122 */
  ISEL_nts_12,  /* 123 */
  ISEL_nts_13,  /* 124 */
  ISEL_nts_14,  /* 125 */
  ISEL_nts_9,  /* 126 */
  ISEL_nts_10,  /* 127 */
  ISEL_nts_11,  /* 128 */
  ISEL_nts_12,  /* 129 */
  ISEL_nts_13,  /* 130 */
  ISEL_nts_14,  /* 131 */
  ISEL_nts_9,  /* 132 */
  ISEL_nts_10,  /* 133 */
  ISEL_nts_11,  /* 134 */
  ISEL_nts_12,  /* 135 */
  ISEL_nts_9,  /* 136 */
  ISEL_nts_10,  /* 137 */
  ISEL_nts_11,  /* 138 */
  ISEL_nts_12,  /* 139 */
  ISEL_nts_9,  /* 140 */
  ISEL_nts_10,  /* 141 */
  ISEL_nts_11,  /* 142 */
  ISEL_nts_12,  /* 143 */
  ISEL_nts_9,  /* 144 */
  ISEL_nts_10,  /* 145 */
  ISEL_nts_11,  /* 146 */
  ISEL_nts_12,  /* 147 */
  ISEL_nts_15,  /* 148 */
  ISEL_nts_15,  /* 149 */
  ISEL_nts_15,  /* 150 */
  ISEL_nts_15,  /* 151 */
  ISEL_nts_15,  /* 152 */
  ISEL_nts_15,  /* 153 */
  ISEL_nts_15,  /* 154 */
  ISEL_nts_15,  /* 155 */
  ISEL_nts_15,  /* 156 */
  ISEL_nts_15,  /* 157 */
  ISEL_nts_15,  /* 158 */
  ISEL_nts_15,  /* 159 */
  ISEL_nts_15,  /* 160 */
  ISEL_nts_15,  /* 161 */
  ISEL_nts_15,  /* 162 */
  ISEL_nts_15,  /* 163 */
  ISEL_nts_15,  /* 164 */
  ISEL_nts_15,  /* 165 */
  ISEL_nts_15,  /* 166 */
  ISEL_nts_15,  /* 167 */
  ISEL_nts_15,  /* 168 */
  ISEL_nts_15,  /* 169 */
  ISEL_nts_15,  /* 170 */
  ISEL_nts_15,  /* 171 */
  ISEL_nts_16,  /* 172 */
  ISEL_nts_16,  /* 173 */
  ISEL_nts_17,  /* 174 */
  ISEL_nts_17,  /* 175 */
  ISEL_nts_17,  /* 176 */
  ISEL_nts_18,  /* 177 */
  ISEL_nts_19,  /* 178 */
  ISEL_nts_19,  /* 179 */
  ISEL_nts_19,  /* 180 */
  ISEL_nts_19,  /* 181 */
  ISEL_nts_19,  /* 182 */
  ISEL_nts_19,  /* 183 */
  ISEL_nts_19,  /* 184 */
  ISEL_nts_19,  /* 185 */
  ISEL_nts_19,  /* 186 */
  ISEL_nts_19,  /* 187 */
  ISEL_nts_19,  /* 188 */
  ISEL_nts_19,  /* 189 */
  ISEL_nts_19,  /* 190 */
  ISEL_nts_19,  /* 191 */
  ISEL_nts_19,  /* 192 */
  ISEL_nts_19,  /* 193 */
  ISEL_nts_19,  /* 194 */
  ISEL_nts_19,  /* 195 */
  ISEL_nts_19,  /* 196 */
  ISEL_nts_19,  /* 197 */
  ISEL_nts_19,  /* 198 */
  ISEL_nts_19,  /* 199 */
  ISEL_nts_19,  /* 200 */
  ISEL_nts_19,  /* 201 */
  ISEL_nts_19,  /* 202 */
  ISEL_nts_19,  /* 203 */
  ISEL_nts_19,  /* 204 */
  ISEL_nts_19,  /* 205 */
  ISEL_nts_19,  /* 206 */
  ISEL_nts_19,  /* 207 */
  ISEL_nts_19,  /* 208 */
  ISEL_nts_19,  /* 209 */
  ISEL_nts_19,  /* 210 */
  ISEL_nts_19,  /* 211 */
  ISEL_nts_19,  /* 212 */
  ISEL_nts_19,  /* 213 */
  ISEL_nts_19,  /* 214 */
  ISEL_nts_19,  /* 215 */
  ISEL_nts_19,  /* 216 */
  ISEL_nts_19,  /* 217 */
  ISEL_nts_19,  /* 218 */
  ISEL_nts_19,  /* 219 */
  ISEL_nts_19,  /* 220 */
  ISEL_nts_19,  /* 221 */
  ISEL_nts_19,  /* 222 */
  ISEL_nts_19,  /* 223 */
  ISEL_nts_19,  /* 224 */
  ISEL_nts_19,  /* 225 */
  ISEL_nts_20,  /* 226 */
  ISEL_nts_20,  /* 227 */
  ISEL_nts_20,  /* 228 */
  ISEL_nts_21,  /* 229 */
  ISEL_nts_20,  /* 230 */
  ISEL_nts_20,  /* 231 */
  ISEL_nts_20,  /* 232 */
  ISEL_nts_21,  /* 233 */
  ISEL_nts_22,  /* 234 */
  ISEL_nts_23,  /* 235 */
  ISEL_nts_23,  /* 236 */
  ISEL_nts_23,  /* 237 */
  ISEL_nts_23,  /* 238 */
  ISEL_nts_23,  /* 239 */
  ISEL_nts_3,  /* 240 */
  ISEL_nts_3,  /* 241 */
  ISEL_nts_3,  /* 242 */
  ISEL_nts_24,  /* 243 */
  ISEL_nts_3,  /* 244 */
  ISEL_nts_3,  /* 245 */
  ISEL_nts_3,  /* 246 */
  ISEL_nts_3,  /* 247 */
  ISEL_nts_3,  /* 248 */
  ISEL_nts_3,  /* 249 */
  ISEL_nts_3,  /* 250 */
  ISEL_nts_3,  /* 251 */
  ISEL_nts_3,  /* 252 */
  ISEL_nts_3,  /* 253 */
  ISEL_nts_3,  /* 254 */
  ISEL_nts_24,  /* 255 */
  ISEL_nts_15,  /* 256 */
  ISEL_nts_15,  /* 257 */
  ISEL_nts_15,  /* 258 */
  ISEL_nts_15,  /* 259 */
  ISEL_nts_15,  /* 260 */
  ISEL_nts_15,  /* 261 */
  ISEL_nts_15,  /* 262 */
  ISEL_nts_25,  /* 263 */
  ISEL_nts_3,  /* 264 */
  ISEL_nts_26,  /* 265 */
  ISEL_nts_27,  /* 266 */
  ISEL_nts_28,  /* 267 */
  ISEL_nts_29,  /* 268 */
  ISEL_nts_24,  /* 269 */
  ISEL_nts_1,  /* 270 */
  ISEL_nts_1,  /* 271 */
  ISEL_nts_1,  /* 272 */
  ISEL_nts_1,  /* 273 */
  ISEL_nts_1,  /* 274 */
  ISEL_nts_1,  /* 275 */
  ISEL_nts_1,  /* 276 */
  ISEL_nts_1,  /* 277 */
  ISEL_nts_1,  /* 278 */
  ISEL_nts_1,  /* 279 */
  ISEL_nts_1,  /* 280 */
  ISEL_nts_1,  /* 281 */
  ISEL_nts_1,  /* 282 */
  ISEL_nts_1,  /* 283 */
  ISEL_nts_1,  /* 284 */
  ISEL_nts_1,  /* 285 */
  ISEL_nts_3,  /* 286 */
  ISEL_nts_3,  /* 287 */
  ISEL_nts_3,  /* 288 */
  ISEL_nts_3,  /* 289 */
  ISEL_nts_3,  /* 290 */
  ISEL_nts_3,  /* 291 */
  ISEL_nts_3,  /* 292 */
  ISEL_nts_3,  /* 293 */
  ISEL_nts_1,  /* 294 */
  ISEL_nts_1,  /* 295 */
  ISEL_nts_1,  /* 296 */
  ISEL_nts_1,  /* 297 */
  ISEL_nts_1,  /* 298 */
  ISEL_nts_1,  /* 299 */
  ISEL_nts_1,  /* 300 */
  ISEL_nts_1,  /* 301 */
  ISEL_nts_1,  /* 302 */
  ISEL_nts_3,  /* 303 */
  ISEL_nts_3,  /* 304 */
  ISEL_nts_3,  /* 305 */
  ISEL_nts_3,  /* 306 */
  ISEL_nts_30,  /* 307 */
  ISEL_nts_31,  /* 308 */
  ISEL_nts_32,  /* 309 */
  ISEL_nts_33,  /* 310 */
  ISEL_nts_30,  /* 311 */
  ISEL_nts_31,  /* 312 */
  ISEL_nts_32,  /* 313 */
  ISEL_nts_33,  /* 314 */
  ISEL_nts_30,  /* 315 */
  ISEL_nts_32,  /* 316 */
  ISEL_nts_30,  /* 317 */
  ISEL_nts_32,  /* 318 */
  ISEL_nts_15,  /* 319 */
  ISEL_nts_15,  /* 320 */
  ISEL_nts_15,  /* 321 */
  ISEL_nts_15,  /* 322 */
  ISEL_nts_15,  /* 323 */
  ISEL_nts_15,  /* 324 */
  ISEL_nts_15,  /* 325 */
  ISEL_nts_15,  /* 326 */
  ISEL_nts_15,  /* 327 */
  ISEL_nts_15,  /* 328 */
  ISEL_nts_15,  /* 329 */
  ISEL_nts_15,  /* 330 */
  ISEL_nts_34,  /* 331 */
  ISEL_nts_35,  /* 332 */
  ISEL_nts_35,  /* 333 */
  ISEL_nts_36,  /* 334 */
  ISEL_nts_34,  /* 335 */
  ISEL_nts_35,  /* 336 */
  ISEL_nts_35,  /* 337 */
  ISEL_nts_36,  /* 338 */
  ISEL_nts_3,  /* 339 */
  ISEL_nts_3,  /* 340 */
  ISEL_nts_3,  /* 341 */
  ISEL_nts_6,  /* 342 */
  ISEL_nts_6,  /* 343 */
  ISEL_nts_6,  /* 344 */
  ISEL_nts_6,  /* 345 */
  ISEL_nts_37,  /* 346 */
  ISEL_nts_37,  /* 347 */
  ISEL_nts_37,  /* 348 */
  ISEL_nts_37,  /* 349 */
  ISEL_nts_24,  /* 350 */
  ISEL_nts_24,  /* 351 */
  ISEL_nts_24,  /* 352 */
  ISEL_nts_24,  /* 353 */
  ISEL_nts_3,  /* 354 */
  ISEL_nts_3,  /* 355 */
  ISEL_nts_24,  /* 356 */
  ISEL_nts_24,  /* 357 */
  ISEL_nts_24,  /* 358 */
  ISEL_nts_24,  /* 359 */
  ISEL_nts_6,  /* 360 */
  ISEL_nts_6,  /* 361 */
  ISEL_nts_6,  /* 362 */
  ISEL_nts_6,  /* 363 */
  ISEL_nts_6,  /* 364 */
  ISEL_nts_6,  /* 365 */
  ISEL_nts_6,  /* 366 */
  ISEL_nts_6,  /* 367 */
  ISEL_nts_6,  /* 368 */
  ISEL_nts_6,  /* 369 */
  ISEL_nts_6,  /* 370 */
  ISEL_nts_6,  /* 371 */
  ISEL_nts_6,  /* 372 */
  ISEL_nts_6,  /* 373 */
  ISEL_nts_6,  /* 374 */
  ISEL_nts_6,  /* 375 */
  ISEL_nts_6,  /* 376 */
  ISEL_nts_6,  /* 377 */
  ISEL_nts_6,  /* 378 */
  ISEL_nts_6,  /* 379 */
  ISEL_nts_6,  /* 380 */
  ISEL_nts_6,  /* 381 */
  ISEL_nts_15,  /* 382 */
  ISEL_nts_38,  /* 383 */
  ISEL_nts_39,  /* 384 */
  ISEL_nts_15,  /* 385 */
  ISEL_nts_38,  /* 386 */
  ISEL_nts_39,  /* 387 */
  ISEL_nts_15,  /* 388 */
  ISEL_nts_15,  /* 389 */
  ISEL_nts_40,  /* 390 */
  ISEL_nts_40,  /* 391 */
  ISEL_nts_15,  /* 392 */
  ISEL_nts_15,  /* 393 */
  ISEL_nts_3,  /* 394 */
  ISEL_nts_3,  /* 395 */
  ISEL_nts_3,  /* 396 */
  ISEL_nts_3,  /* 397 */
  ISEL_nts_41,  /* 398 */
  ISEL_nts_41,  /* 399 */
  ISEL_nts_42,  /* 400 */
  ISEL_nts_42,  /* 401 */
  ISEL_nts_43,  /* 402 */
  ISEL_nts_43,  /* 403 */
  ISEL_nts_42,  /* 404 */
  ISEL_nts_42,  /* 405 */
  ISEL_nts_44,  /* 406 */
  ISEL_nts_44,  /* 407 */
  ISEL_nts_45,  /* 408 */
  ISEL_nts_45,  /* 409 */
  ISEL_nts_45,  /* 410 */
  ISEL_nts_45,  /* 411 */
  ISEL_nts_46,  /* 412 */
  ISEL_nts_46,  /* 413 */
  ISEL_nts_47,  /* 414 */
  ISEL_nts_47,  /* 415 */
  ISEL_nts_48,  /* 416 */
  ISEL_nts_49,  /* 417 */
  ISEL_nts_48,  /* 418 */
  ISEL_nts_49,  /* 419 */
  ISEL_nts_49,  /* 420 */
  ISEL_nts_49,  /* 421 */
  ISEL_nts_15,  /* 422 */
  ISEL_nts_15,  /* 423 */
  ISEL_nts_50,  /* 424 */
  ISEL_nts_51,  /* 425 */
  ISEL_nts_50,  /* 426 */
  ISEL_nts_51,  /* 427 */
  ISEL_nts_50,  /* 428 */
  ISEL_nts_50,  /* 429 */
  ISEL_nts_15,  /* 430 */
  ISEL_nts_15,  /* 431 */
  ISEL_nts_3,  /* 432 */
  ISEL_nts_3,  /* 433 */
  ISEL_nts_3,  /* 434 */
  ISEL_nts_3,  /* 435 */
  ISEL_nts_3,  /* 436 */
  ISEL_nts_3,  /* 437 */
  ISEL_nts_3,  /* 438 */
  ISEL_nts_3,  /* 439 */
  ISEL_nts_3,  /* 440 */
  ISEL_nts_3,  /* 441 */
  ISEL_nts_3,  /* 442 */
  ISEL_nts_3,  /* 443 */
  ISEL_nts_3,  /* 444 */
  ISEL_nts_3,  /* 445 */
  ISEL_nts_3,  /* 446 */
  ISEL_nts_3,  /* 447 */
  ISEL_nts_3,  /* 448 */
  ISEL_nts_3,  /* 449 */
  ISEL_nts_3,  /* 450 */
  ISEL_nts_3,  /* 451 */
  ISEL_nts_15,  /* 452 */
  ISEL_nts_15,  /* 453 */
  ISEL_nts_15,  /* 454 */
  ISEL_nts_15,  /* 455 */
  ISEL_nts_15,  /* 456 */
  ISEL_nts_15,  /* 457 */
  ISEL_nts_1,  /* 458 */
  ISEL_nts_1,  /* 459 */
  ISEL_nts_1,  /* 460 */
  ISEL_nts_1,  /* 461 */
  ISEL_nts_1,  /* 462 */
  ISEL_nts_1,  /* 463 */
  ISEL_nts_1,  /* 464 */
  ISEL_nts_1,  /* 465 */
  ISEL_nts_1,  /* 466 */
  ISEL_nts_1,  /* 467 */
  ISEL_nts_1,  /* 468 */
  ISEL_nts_1,  /* 469 */
  ISEL_nts_1,  /* 470 */
  ISEL_nts_1,  /* 471 */
  ISEL_nts_1,  /* 472 */
  ISEL_nts_1,  /* 473 */
  ISEL_nts_1,  /* 474 */
  ISEL_nts_1,  /* 475 */
  ISEL_nts_1,  /* 476 */
  ISEL_nts_1,  /* 477 */
  ISEL_nts_1,  /* 478 */
  ISEL_nts_1,  /* 479 */
  ISEL_nts_1,  /* 480 */
  ISEL_nts_1,  /* 481 */
  ISEL_nts_1,  /* 482 */
  ISEL_nts_1,  /* 483 */
  ISEL_nts_1,  /* 484 */
  ISEL_nts_1,  /* 485 */
  ISEL_nts_1,  /* 486 */
  ISEL_nts_1,  /* 487 */
  ISEL_nts_1,  /* 488 */
  ISEL_nts_1,  /* 489 */
  ISEL_nts_1,  /* 490 */
  ISEL_nts_1,  /* 491 */
  ISEL_nts_1,  /* 492 */
  ISEL_nts_1,  /* 493 */
  ISEL_nts_3,  /* 494 */
  ISEL_nts_3,  /* 495 */
  ISEL_nts_3,  /* 496 */
  ISEL_nts_3,  /* 497 */
  ISEL_nts_3,  /* 498 */
  ISEL_nts_3,  /* 499 */
  ISEL_nts_3,  /* 500 */
  ISEL_nts_3,  /* 501 */
  ISEL_nts_3,  /* 502 */
  ISEL_nts_3,  /* 503 */
  ISEL_nts_3,  /* 504 */
  ISEL_nts_3,  /* 505 */
  ISEL_nts_3,  /* 506 */
  ISEL_nts_3,  /* 507 */
  ISEL_nts_3,  /* 508 */
  ISEL_nts_3,  /* 509 */
  ISEL_nts_3,  /* 510 */
  ISEL_nts_3,  /* 511 */
  ISEL_nts_3,  /* 512 */
  ISEL_nts_3,  /* 513 */
  ISEL_nts_3,  /* 514 */
  ISEL_nts_1,  /* 515 */
  ISEL_nts_1,  /* 516 */
  ISEL_nts_1,  /* 517 */
  ISEL_nts_3,  /* 518 */
  ISEL_nts_52,  /* 519 */
  ISEL_nts_1,  /* 520 */
  ISEL_nts_3,  /* 521 */
  ISEL_nts_24,  /* 522 */
  ISEL_nts_53,  /* 523 */
  ISEL_nts_54,  /* 524 */
  ISEL_nts_55,  /* 525 */
  ISEL_nts_3,  /* 526 */
  ISEL_nts_53,  /* 527 */
  ISEL_nts_3,  /* 528 */
  ISEL_nts_56,  /* 529 */
  ISEL_nts_3,  /* 530 */
  ISEL_nts_57,  /* 531 */
  ISEL_nts_3,  /* 532 */
  ISEL_nts_58,  /* 533 */
  ISEL_nts_1,  /* 534 */
  ISEL_nts_1,  /* 535 */
  ISEL_nts_1,  /* 536 */
  ISEL_nts_1,  /* 537 */
  ISEL_nts_1,  /* 538 */
  ISEL_nts_1,  /* 539 */
  ISEL_nts_1,  /* 540 */
  ISEL_nts_1,  /* 541 */
  ISEL_nts_1,  /* 542 */
  ISEL_nts_1,  /* 543 */
  ISEL_nts_1,  /* 544 */
  ISEL_nts_1,  /* 545 */
  ISEL_nts_1,  /* 546 */
  ISEL_nts_1,  /* 547 */
  ISEL_nts_1,  /* 548 */
  ISEL_nts_1,  /* 549 */
  ISEL_nts_1,  /* 550 */
  ISEL_nts_1,  /* 551 */
  ISEL_nts_1,  /* 552 */
  ISEL_nts_1,  /* 553 */
  ISEL_nts_1,  /* 554 */
  ISEL_nts_1,  /* 555 */
  ISEL_nts_1,  /* 556 */
  ISEL_nts_59,  /* 557 */
  ISEL_nts_59,  /* 558 */
  ISEL_nts_1,  /* 559 */
  ISEL_nts_1,  /* 560 */
  ISEL_nts_1,  /* 561 */
  ISEL_nts_1,  /* 562 */
  ISEL_nts_1,  /* 563 */
  ISEL_nts_1,  /* 564 */
  ISEL_nts_1,  /* 565 */
  ISEL_nts_1,  /* 566 */
  ISEL_nts_1,  /* 567 */
  ISEL_nts_1,  /* 568 */
  ISEL_nts_1,  /* 569 */
  ISEL_nts_1,  /* 570 */
  ISEL_nts_1,  /* 571 */
  ISEL_nts_1,  /* 572 */
  ISEL_nts_1,  /* 573 */
  ISEL_nts_1,  /* 574 */
  ISEL_nts_1,  /* 575 */
  ISEL_nts_1,  /* 576 */
  ISEL_nts_1,  /* 577 */
  ISEL_nts_1,  /* 578 */
  ISEL_nts_1,  /* 579 */
  ISEL_nts_1,  /* 580 */
  ISEL_nts_1,  /* 581 */
  ISEL_nts_60,  /* 582 */
  ISEL_nts_1,  /* 583 */
  ISEL_nts_1,  /* 584 */
  ISEL_nts_1,  /* 585 */
  ISEL_nts_1,  /* 586 */
  ISEL_nts_1,  /* 587 */
  ISEL_nts_1,  /* 588 */
  ISEL_nts_1,  /* 589 */
  ISEL_nts_1,  /* 590 */
  ISEL_nts_1,  /* 591 */
  ISEL_nts_1,  /* 592 */
  ISEL_nts_1,  /* 593 */
  ISEL_nts_1,  /* 594 */
  ISEL_nts_1,  /* 595 */
  ISEL_nts_1,  /* 596 */
  ISEL_nts_1,  /* 597 */
  ISEL_nts_1,  /* 598 */
  ISEL_nts_1,  /* 599 */
  ISEL_nts_1,  /* 600 */
  ISEL_nts_1,  /* 601 */
  ISEL_nts_1,  /* 602 */
  ISEL_nts_1,  /* 603 */
  ISEL_nts_1,  /* 604 */
  ISEL_nts_1,  /* 605 */
  ISEL_nts_1,  /* 606 */
  ISEL_nts_1,  /* 607 */
  ISEL_nts_1,  /* 608 */
  ISEL_nts_1,  /* 609 */
  ISEL_nts_1,  /* 610 */
  ISEL_nts_1,  /* 611 */
  ISEL_nts_1,  /* 612 */
  ISEL_nts_1,  /* 613 */
  ISEL_nts_1,  /* 614 */
  ISEL_nts_1,  /* 615 */
  ISEL_nts_1,  /* 616 */
  ISEL_nts_1,  /* 617 */
  ISEL_nts_5,  /* 618 */
  ISEL_nts_1,  /* 619 */
  ISEL_nts_1,  /* 620 */
  ISEL_nts_1,  /* 621 */
  ISEL_nts_1,  /* 622 */
  ISEL_nts_1,  /* 623 */
  ISEL_nts_29,  /* 624 */
  ISEL_nts_5,  /* 625 */
  ISEL_nts_61,  /* 626 */
  ISEL_nts_61,  /* 627 */
  ISEL_nts_5,  /* 628 */
  ISEL_nts_29,  /* 629 */
  ISEL_nts_29,  /* 630 */
  ISEL_nts_29,  /* 631 */
  ISEL_nts_29,  /* 632 */
  ISEL_nts_61,  /* 633 */
  ISEL_nts_61,  /* 634 */
  ISEL_nts_61,  /* 635 */
  ISEL_nts_61,  /* 636 */
  ISEL_nts_61,  /* 637 */
  ISEL_nts_29,  /* 638 */
  ISEL_nts_29,  /* 639 */
  ISEL_nts_29,  /* 640 */
  ISEL_nts_29,  /* 641 */
  ISEL_nts_29,  /* 642 */
  ISEL_nts_61,  /* 643 */
  ISEL_nts_61,  /* 644 */
  ISEL_nts_61,  /* 645 */
  ISEL_nts_61,  /* 646 */
  ISEL_nts_61,  /* 647 */
  ISEL_nts_3,  /* 648 */
  ISEL_nts_3,  /* 649 */
  ISEL_nts_3,  /* 650 */
  ISEL_nts_3,  /* 651 */
  ISEL_nts_3,  /* 652 */
  ISEL_nts_3,  /* 653 */
  ISEL_nts_3,  /* 654 */
  ISEL_nts_3,  /* 655 */
  ISEL_nts_3,  /* 656 */
  ISEL_nts_3,  /* 657 */
  ISEL_nts_62,  /* 658 */
  ISEL_nts_62,  /* 659 */
  ISEL_nts_62,  /* 660 */
  ISEL_nts_62,  /* 661 */
  ISEL_nts_62,  /* 662 */
  ISEL_nts_63,  /* 663 */
  ISEL_nts_63,  /* 664 */
  ISEL_nts_63,  /* 665 */
  ISEL_nts_63,  /* 666 */
  ISEL_nts_63,  /* 667 */
  ISEL_nts_3,  /* 668 */
  ISEL_nts_3,  /* 669 */
  ISEL_nts_3,  /* 670 */
  ISEL_nts_3,  /* 671 */
  ISEL_nts_3,  /* 672 */
  ISEL_nts_61,  /* 673 */
  ISEL_nts_61,  /* 674 */
  ISEL_nts_61,  /* 675 */
  ISEL_nts_61,  /* 676 */
  ISEL_nts_61,  /* 677 */
  ISEL_nts_3,  /* 678 */
  ISEL_nts_3,  /* 679 */
  ISEL_nts_3,  /* 680 */
  ISEL_nts_3,  /* 681 */
  ISEL_nts_3,  /* 682 */
  ISEL_nts_61,  /* 683 */
  ISEL_nts_61,  /* 684 */
  ISEL_nts_61,  /* 685 */
  ISEL_nts_61,  /* 686 */
  ISEL_nts_61,  /* 687 */
  ISEL_nts_64,  /* 688 */
  ISEL_nts_64,  /* 689 */
  ISEL_nts_64,  /* 690 */
  ISEL_nts_64,  /* 691 */
  ISEL_nts_64,  /* 692 */
  ISEL_nts_64,  /* 693 */
  ISEL_nts_64,  /* 694 */
  ISEL_nts_64,  /* 695 */
  ISEL_nts_64,  /* 696 */
  ISEL_nts_64,  /* 697 */
  ISEL_nts_64,  /* 698 */
  ISEL_nts_5,  /* 699 */
  ISEL_nts_5,  /* 700 */
  ISEL_nts_1,  /* 701 */
  ISEL_nts_1,  /* 702 */
  ISEL_nts_1,  /* 703 */
  ISEL_nts_1,  /* 704 */
  ISEL_nts_1,  /* 705 */
};


char *ISEL_string[] = {
  /* 0 */  "stmt: expr",
  /* 1 */  "stmt: OPC_EVAL(expr)",
  /* 2 */  "stmt: OPC_ASM_STMT",
  /* 3 */  "areg: OPC_U4ALLOCA(areg_or_simm8)",
  /* 4 */  "stmt: OPC_DEALLOCA(areg)",
  /* 5 */  "stmt: OPC_FORWARD_BARRIER",
  /* 6 */  "stmt: OPC_BACKWARD_BARRIER",
  /* 7 */  "stmt: OPC_VINTRINSIC_CALL",
  /* 8 */  "stmt: OPC_I4INTRINSIC_CALL",
  /* 9 */  "stmt: OPC_VCALL",
  /* 10 */  "stmt: OPC_I1CALL",
  /* 11 */  "stmt: OPC_U1CALL",
  /* 12 */  "stmt: OPC_I2CALL",
  /* 13 */  "stmt: OPC_U2CALL",
  /* 14 */  "stmt: OPC_I4CALL",
  /* 15 */  "stmt: OPC_F4CALL",
  /* 16 */  "stmt: OPC_U4CALL",
  /* 17 */  "stmt: OPC_F8CALL",
  /* 18 */  "stmt: OPC_I8CALL",
  /* 19 */  "stmt: OPC_U8CALL",
  /* 20 */  "stmt: OPC_MCALL",
  /* 21 */  "stmt: OPC_VICALL",
  /* 22 */  "stmt: OPC_I1ICALL",
  /* 23 */  "stmt: OPC_U1ICALL",
  /* 24 */  "stmt: OPC_I2ICALL",
  /* 25 */  "stmt: OPC_U2ICALL",
  /* 26 */  "stmt: OPC_I4ICALL",
  /* 27 */  "stmt: OPC_F4ICALL",
  /* 28 */  "stmt: OPC_U4ICALL",
  /* 29 */  "stmt: OPC_F8ICALL",
  /* 30 */  "stmt: OPC_I8ICALL",
  /* 31 */  "stmt: OPC_U8ICALL",
  /* 32 */  "stmt: OPC_MICALL",
  /* 33 */  "stmt: OPC_REGION_EXIT",
  /* 34 */  "stmt: OPC_GOTO",
  /* 35 */  "stmt: OPC_XGOTO(areg)",
  /* 36 */  "stmt: OPC_AGOTO(areg)",
  /* 37 */  "stmt: OPC_TRUEBR(one)",
  /* 38 */  "stmt: OPC_TRUEBR(areg)",
  /* 39 */  "stmt: OPC_FALSEBR(areg)",
  /* 40 */  "stmt: OPC_TRUEBR(b1reg)",
  /* 41 */  "stmt: OPC_TRUEBR(OPC_U4F4NE(freg,freg))",
  /* 42 */  "stmt: OPC_TRUEBR(OPC_I4F4NE(freg,freg))",
  /* 43 */  "stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(b1reg))",
  /* 44 */  "stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(OPC_XTBOOLBNOT(b1reg)))",
  /* 45 */  "stmt: OPC_FALSEBR(b1reg)",
  /* 46 */  "stmt: OPC_FALSEBR(OPC_U4F4NE(freg,freg))",
  /* 47 */  "stmt: OPC_FALSEBR(OPC_I4F4NE(freg,freg))",
  /* 48 */  "stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(b1reg))",
  /* 49 */  "stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(OPC_XTBOOLBNOT(b1reg)))",
  /* 50 */  "stmt: OPC_TRUEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const))",
  /* 51 */  "stmt: OPC_TRUEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const))",
  /* 52 */  "stmt: OPC_TRUEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu))",
  /* 53 */  "stmt: OPC_TRUEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu))",
  /* 54 */  "stmt: OPC_TRUEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu))",
  /* 55 */  "stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(b1reg))",
  /* 56 */  "stmt: OPC_TRUEBR(OPC_XTBOOLBNOT(b1reg))",
  /* 57 */  "stmt: OPC_FALSEBR(b1reg)",
  /* 58 */  "stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(b1reg))",
  /* 59 */  "stmt: OPC_FALSEBR(OPC_XTBOOLBNOT(b1reg))",
  /* 60 */  "stmt: OPC_TRUEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const))",
  /* 61 */  "stmt: OPC_TRUEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const))",
  /* 62 */  "stmt: OPC_TRUEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu))",
  /* 63 */  "stmt: OPC_TRUEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu))",
  /* 64 */  "stmt: OPC_TRUEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu))",
  /* 65 */  "stmt: OPC_TRUEBR(OPC_I4U4LE(areg_or_b4constu,areg_or_b4constu))",
  /* 66 */  "stmt: OPC_FALSEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const))",
  /* 67 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const))",
  /* 68 */  "stmt: OPC_FALSEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu))",
  /* 69 */  "stmt: OPC_FALSEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu))",
  /* 70 */  "stmt: OPC_FALSEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu))",
  /* 71 */  "stmt: OPC_FALSEBR(OPC_I4U4LE(areg_or_b4constu,areg_or_b4constu))",
  /* 72 */  "stmt: OPC_TRUEBR(OPC_U4U4EQ(areg_or_b4const,areg_or_b4const))",
  /* 73 */  "stmt: OPC_TRUEBR(OPC_U4U4NE(areg_or_b4const,areg_or_b4const))",
  /* 74 */  "stmt: OPC_TRUEBR(OPC_U4U4GT(areg_or_b4constu,areg_or_b4constu))",
  /* 75 */  "stmt: OPC_TRUEBR(OPC_U4U4GE(areg_or_b4constu,areg_or_b4constu))",
  /* 76 */  "stmt: OPC_TRUEBR(OPC_U4U4LT(areg_or_b4constu,areg_or_b4constu))",
  /* 77 */  "stmt: OPC_TRUEBR(OPC_U4U4LE(areg_or_b4constu,areg_or_b4constu))",
  /* 78 */  "stmt: OPC_FALSEBR(OPC_U4U4EQ(areg_or_b4const,areg_or_b4const))",
  /* 79 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(areg_or_b4const,areg_or_b4const))",
  /* 80 */  "stmt: OPC_FALSEBR(OPC_U4U4GT(areg_or_b4constu,areg_or_b4constu))",
  /* 81 */  "stmt: OPC_FALSEBR(OPC_U4U4GE(areg_or_b4constu,areg_or_b4constu))",
  /* 82 */  "stmt: OPC_FALSEBR(OPC_U4U4LT(areg_or_b4constu,areg_or_b4constu))",
  /* 83 */  "stmt: OPC_FALSEBR(OPC_U4U4LE(areg_or_b4constu,areg_or_b4constu))",
  /* 84 */  "stmt: OPC_TRUEBR(OPC_I4I4EQ(areg_or_b4const,areg_or_b4const))",
  /* 85 */  "stmt: OPC_TRUEBR(OPC_I4I4NE(areg_or_b4const,areg_or_b4const))",
  /* 86 */  "stmt: OPC_TRUEBR(OPC_I4I4GT(areg_or_b4const,areg_or_b4const))",
  /* 87 */  "stmt: OPC_TRUEBR(OPC_I4I4GE(areg_or_b4const,areg_or_b4const))",
  /* 88 */  "stmt: OPC_TRUEBR(OPC_I4I4LT(areg_or_b4const,areg_or_b4const))",
  /* 89 */  "stmt: OPC_TRUEBR(OPC_I4I4LE(areg_or_b4const,areg_or_b4const))",
  /* 90 */  "stmt: OPC_FALSEBR(OPC_I4I4EQ(areg_or_b4const,areg_or_b4const))",
  /* 91 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(areg_or_b4const,areg_or_b4const))",
  /* 92 */  "stmt: OPC_FALSEBR(OPC_I4I4GT(areg_or_b4const,areg_or_b4const))",
  /* 93 */  "stmt: OPC_FALSEBR(OPC_I4I4GE(areg_or_b4const,areg_or_b4const))",
  /* 94 */  "stmt: OPC_FALSEBR(OPC_I4I4LT(areg_or_b4const,areg_or_b4const))",
  /* 95 */  "stmt: OPC_FALSEBR(OPC_I4I4LE(areg_or_b4const,areg_or_b4const))",
  /* 96 */  "stmt: OPC_TRUEBR(OPC_U4I4EQ(areg_or_b4const,areg_or_b4const))",
  /* 97 */  "stmt: OPC_TRUEBR(OPC_U4I4NE(areg_or_b4const,areg_or_b4const))",
  /* 98 */  "stmt: OPC_TRUEBR(OPC_U4I4GT(areg_or_b4const,areg_or_b4const))",
  /* 99 */  "stmt: OPC_TRUEBR(OPC_U4I4GE(areg_or_b4const,areg_or_b4const))",
  /* 100 */  "stmt: OPC_TRUEBR(OPC_U4I4LT(areg_or_b4const,areg_or_b4const))",
  /* 101 */  "stmt: OPC_TRUEBR(OPC_U4I4LE(areg_or_b4const,areg_or_b4const))",
  /* 102 */  "stmt: OPC_FALSEBR(OPC_U4I4EQ(areg_or_b4const,areg_or_b4const))",
  /* 103 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(areg_or_b4const,areg_or_b4const))",
  /* 104 */  "stmt: OPC_FALSEBR(OPC_U4I4GT(areg_or_b4const,areg_or_b4const))",
  /* 105 */  "stmt: OPC_FALSEBR(OPC_U4I4GE(areg_or_b4const,areg_or_b4const))",
  /* 106 */  "stmt: OPC_FALSEBR(OPC_U4I4LT(areg_or_b4const,areg_or_b4const))",
  /* 107 */  "stmt: OPC_FALSEBR(OPC_U4I4LE(areg_or_b4const,areg_or_b4const))",
  /* 108 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(areg,logical_and_immed),zero))",
  /* 109 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(logical_and_immed,areg),zero))",
  /* 110 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(areg,logical_and_immed)))",
  /* 111 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(logical_and_immed,areg)))",
  /* 112 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(areg,areg)))",
  /* 113 */  "stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(areg,areg),zero))",
  /* 114 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(areg,logical_and_immed),zero))",
  /* 115 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(logical_and_immed,areg),zero))",
  /* 116 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(areg,logical_and_immed)))",
  /* 117 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(logical_and_immed,areg)))",
  /* 118 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(areg,areg)))",
  /* 119 */  "stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(areg,areg),zero))",
  /* 120 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(areg,logical_and_immed),zero))",
  /* 121 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(logical_and_immed,areg),zero))",
  /* 122 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(areg,logical_and_immed)))",
  /* 123 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(logical_and_immed,areg)))",
  /* 124 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(areg,areg)))",
  /* 125 */  "stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(areg,areg),zero))",
  /* 126 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(areg,logical_and_immed),zero))",
  /* 127 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(logical_and_immed,areg),zero))",
  /* 128 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(areg,logical_and_immed)))",
  /* 129 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(logical_and_immed,areg)))",
  /* 130 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(areg,areg)))",
  /* 131 */  "stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(areg,areg),zero))",
  /* 132 */  "stmt: OPC_FALSEBR(OPC_I4I4EQ(OPC_I4BAND(areg,logical_and_immed),zero))",
  /* 133 */  "stmt: OPC_FALSEBR(OPC_I4I4EQ(OPC_I4BAND(logical_and_immed,areg),zero))",
  /* 134 */  "stmt: OPC_FALSEBR(OPC_I4I4EQ(zero,OPC_I4BAND(areg,logical_and_immed)))",
  /* 135 */  "stmt: OPC_FALSEBR(OPC_I4I4EQ(zero,OPC_I4BAND(logical_and_immed,areg)))",
  /* 136 */  "stmt: OPC_FALSEBR(OPC_I4U4EQ(OPC_U4BAND(areg,logical_and_immed),zero))",
  /* 137 */  "stmt: OPC_FALSEBR(OPC_I4U4EQ(OPC_U4BAND(logical_and_immed,areg),zero))",
  /* 138 */  "stmt: OPC_FALSEBR(OPC_I4U4EQ(zero,OPC_U4BAND(areg,logical_and_immed)))",
  /* 139 */  "stmt: OPC_FALSEBR(OPC_I4U4EQ(zero,OPC_U4BAND(logical_and_immed,areg)))",
  /* 140 */  "stmt: OPC_FALSEBR(OPC_U4I4EQ(OPC_I4BAND(areg,logical_and_immed),zero))",
  /* 141 */  "stmt: OPC_FALSEBR(OPC_U4I4EQ(OPC_I4BAND(logical_and_immed,areg),zero))",
  /* 142 */  "stmt: OPC_FALSEBR(OPC_U4I4EQ(zero,OPC_I4BAND(areg,logical_and_immed)))",
  /* 143 */  "stmt: OPC_FALSEBR(OPC_U4I4EQ(zero,OPC_I4BAND(logical_and_immed,areg)))",
  /* 144 */  "stmt: OPC_FALSEBR(OPC_U4U4EQ(OPC_U4BAND(areg,logical_and_immed),zero))",
  /* 145 */  "stmt: OPC_FALSEBR(OPC_U4U4EQ(OPC_U4BAND(logical_and_immed,areg),zero))",
  /* 146 */  "stmt: OPC_FALSEBR(OPC_U4U4EQ(zero,OPC_U4BAND(areg,logical_and_immed)))",
  /* 147 */  "stmt: OPC_FALSEBR(OPC_U4U4EQ(zero,OPC_U4BAND(logical_and_immed,areg)))",
  /* 148 */  "areg: OPC_I4I4LT(areg,areg)",
  /* 149 */  "areg: OPC_I4I4GT(areg,areg)",
  /* 150 */  "areg: OPC_I4I4NE(areg,areg)",
  /* 151 */  "areg: OPC_I4I4EQ(areg,areg)",
  /* 152 */  "areg: OPC_I4I4GE(areg,areg)",
  /* 153 */  "areg: OPC_I4I4LE(areg,areg)",
  /* 154 */  "areg: OPC_U4I4LT(areg,areg)",
  /* 155 */  "areg: OPC_U4I4GT(areg,areg)",
  /* 156 */  "areg: OPC_U4I4NE(areg,areg)",
  /* 157 */  "areg: OPC_U4I4EQ(areg,areg)",
  /* 158 */  "areg: OPC_U4I4GE(areg,areg)",
  /* 159 */  "areg: OPC_U4I4LE(areg,areg)",
  /* 160 */  "areg: OPC_I4U4LT(areg,areg)",
  /* 161 */  "areg: OPC_I4U4GT(areg,areg)",
  /* 162 */  "areg: OPC_I4U4NE(areg,areg)",
  /* 163 */  "areg: OPC_I4U4EQ(areg,areg)",
  /* 164 */  "areg: OPC_I4U4GE(areg,areg)",
  /* 165 */  "areg: OPC_I4U4LE(areg,areg)",
  /* 166 */  "areg: OPC_U4U4LT(areg,areg)",
  /* 167 */  "areg: OPC_U4U4GT(areg,areg)",
  /* 168 */  "areg: OPC_U4U4NE(areg,areg)",
  /* 169 */  "areg: OPC_U4U4EQ(areg,areg)",
  /* 170 */  "areg: OPC_U4U4GE(areg,areg)",
  /* 171 */  "areg: OPC_U4U4LE(areg,areg)",
  /* 172 */  "areg: OPC_I4I4NE(OPC_I4BAND(areg,bbci_bbsi_imm),zero)",
  /* 173 */  "areg: OPC_I4U4NE(OPC_U4BAND(areg,bbci_bbsi_imm),zero)",
  /* 174 */  "areg: OPC_I4SELECT(areg,areg,areg)",
  /* 175 */  "areg: OPC_U4SELECT(areg,areg,areg)",
  /* 176 */  "areg: OPC_F4SELECT(areg,areg,areg)",
  /* 177 */  "freg: OPC_F4SELECT(areg,freg,freg)",
  /* 178 */  "areg: OPC_I4SELECT(OPC_I4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 179 */  "areg: OPC_I4SELECT(OPC_I4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 180 */  "areg: OPC_I4SELECT(OPC_I4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 181 */  "areg: OPC_I4SELECT(OPC_I4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 182 */  "areg: OPC_I4SELECT(OPC_I4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 183 */  "areg: OPC_I4SELECT(OPC_I4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 184 */  "areg: OPC_I4SELECT(OPC_I4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 185 */  "areg: OPC_I4SELECT(OPC_I4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 186 */  "areg: OPC_I4SELECT(OPC_I4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 187 */  "areg: OPC_I4SELECT(OPC_I4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 188 */  "areg: OPC_I4SELECT(OPC_I4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 189 */  "areg: OPC_I4SELECT(OPC_I4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 190 */  "areg: OPC_I4SELECT(OPC_U4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 191 */  "areg: OPC_I4SELECT(OPC_U4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 192 */  "areg: OPC_I4SELECT(OPC_U4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 193 */  "areg: OPC_I4SELECT(OPC_U4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 194 */  "areg: OPC_I4SELECT(OPC_U4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 195 */  "areg: OPC_I4SELECT(OPC_U4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 196 */  "areg: OPC_I4SELECT(OPC_U4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 197 */  "areg: OPC_I4SELECT(OPC_U4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 198 */  "areg: OPC_I4SELECT(OPC_U4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 199 */  "areg: OPC_I4SELECT(OPC_U4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 200 */  "areg: OPC_I4SELECT(OPC_U4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 201 */  "areg: OPC_I4SELECT(OPC_U4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 202 */  "areg: OPC_U4SELECT(OPC_U4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 203 */  "areg: OPC_U4SELECT(OPC_U4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 204 */  "areg: OPC_U4SELECT(OPC_U4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 205 */  "areg: OPC_U4SELECT(OPC_U4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 206 */  "areg: OPC_U4SELECT(OPC_U4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 207 */  "areg: OPC_U4SELECT(OPC_U4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 208 */  "areg: OPC_U4SELECT(OPC_U4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 209 */  "areg: OPC_U4SELECT(OPC_U4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 210 */  "areg: OPC_U4SELECT(OPC_U4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 211 */  "areg: OPC_U4SELECT(OPC_U4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 212 */  "areg: OPC_U4SELECT(OPC_U4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 213 */  "areg: OPC_U4SELECT(OPC_U4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 214 */  "areg: OPC_U4SELECT(OPC_I4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 215 */  "areg: OPC_U4SELECT(OPC_I4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 216 */  "areg: OPC_U4SELECT(OPC_I4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 217 */  "areg: OPC_U4SELECT(OPC_I4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 218 */  "areg: OPC_U4SELECT(OPC_I4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 219 */  "areg: OPC_U4SELECT(OPC_I4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 220 */  "areg: OPC_U4SELECT(OPC_I4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 221 */  "areg: OPC_U4SELECT(OPC_I4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 222 */  "areg: OPC_U4SELECT(OPC_I4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 223 */  "areg: OPC_U4SELECT(OPC_I4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 224 */  "areg: OPC_U4SELECT(OPC_I4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 225 */  "areg: OPC_U4SELECT(OPC_I4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12)",
  /* 226 */  "areg: OPC_I4SELECT(b1reg,areg,areg)",
  /* 227 */  "areg: OPC_U4SELECT(b1reg,areg,areg)",
  /* 228 */  "areg: OPC_F4SELECT(b1reg,areg,areg)",
  /* 229 */  "freg: OPC_F4SELECT(b1reg,freg,freg)",
  /* 230 */  "areg: OPC_I4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg)",
  /* 231 */  "areg: OPC_U4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg)",
  /* 232 */  "areg: OPC_F4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg)",
  /* 233 */  "freg: OPC_F4SELECT(OPC_XTBOOLBNOT(b1reg),freg,freg)",
  /* 234 */  "freg: OPC_F4SELECT(OPC_I4F4NE(freg,freg),freg,freg)",
  /* 235 */  "breg: OPC_XTBOOLSELECT(areg,breg,breg)",
  /* 236 */  "breg: OPC_XTBOOL2SELECT(areg,breg,breg)",
  /* 237 */  "breg: OPC_XTBOOL4SELECT(areg,breg,breg)",
  /* 238 */  "breg: OPC_XTBOOL8SELECT(areg,breg,breg)",
  /* 239 */  "breg: OPC_XTBOOL16SELECT(areg,breg,breg)",
  /* 240 */  "expr: OPC_I4STID(areg)",
  /* 241 */  "expr: OPC_U4STID(areg)",
  /* 242 */  "expr: OPC_F4STID(areg)",
  /* 243 */  "expr: OPC_F4STID(freg)",
  /* 244 */  "expr: OPC_I2STID(areg)",
  /* 245 */  "expr: OPC_U2STID(areg)",
  /* 246 */  "expr: OPC_I1STID(areg)",
  /* 247 */  "expr: OPC_U1STID(areg)",
  /* 248 */  "expr: OPC_I4STID(areg)",
  /* 249 */  "expr: OPC_U4STID(areg)",
  /* 250 */  "expr: OPC_I2STID(areg)",
  /* 251 */  "expr: OPC_U2STID(areg)",
  /* 252 */  "expr: OPC_I1STID(areg)",
  /* 253 */  "expr: OPC_U1STID(areg)",
  /* 254 */  "expr: OPC_F4STID(areg)",
  /* 255 */  "expr: OPC_F4STID(freg)",
  /* 256 */  "expr: OPC_U4ISTORE(areg,areg)",
  /* 257 */  "expr: OPC_U2ISTORE(areg,areg)",
  /* 258 */  "expr: OPC_U1ISTORE(areg,areg)",
  /* 259 */  "expr: OPC_I4ISTORE(areg,areg)",
  /* 260 */  "expr: OPC_I2ISTORE(areg,areg)",
  /* 261 */  "expr: OPC_I1ISTORE(areg,areg)",
  /* 262 */  "expr: OPC_F4ISTORE(areg,areg)",
  /* 263 */  "expr: OPC_F4ISTORE(freg,areg)",
  /* 264 */  "expr: areg",
  /* 265 */  "expr: tie_reg",
  /* 266 */  "expr: tie_cvt_reg",
  /* 267 */  "expr: ll_cvt_areg",
  /* 268 */  "expr: breg",
  /* 269 */  "expr: freg",
  /* 270 */  "areg: OPC_I4I4LDID",
  /* 271 */  "areg: OPC_I4I2LDID",
  /* 272 */  "areg: OPC_I4I1LDID",
  /* 273 */  "areg: OPC_U4U4LDID",
  /* 274 */  "areg: OPC_U4U2LDID",
  /* 275 */  "areg: OPC_U4U1LDID",
  /* 276 */  "areg: OPC_F4F4LDID",
  /* 277 */  "freg: OPC_F4F4LDID",
  /* 278 */  "areg: OPC_I4I4LDID",
  /* 279 */  "areg: OPC_I4I2LDID",
  /* 280 */  "areg: OPC_I4I1LDID",
  /* 281 */  "areg: OPC_U4U4LDID",
  /* 282 */  "areg: OPC_U4U2LDID",
  /* 283 */  "areg: OPC_U4U1LDID",
  /* 284 */  "areg: OPC_F4F4LDID",
  /* 285 */  "freg: OPC_F4F4LDID",
  /* 286 */  "areg: OPC_I4I4ILOAD(areg)",
  /* 287 */  "areg: OPC_I4I2ILOAD(areg)",
  /* 288 */  "areg: OPC_I4I1ILOAD(areg)",
  /* 289 */  "areg: OPC_U4U4ILOAD(areg)",
  /* 290 */  "areg: OPC_U4U2ILOAD(areg)",
  /* 291 */  "areg: OPC_U4U1ILOAD(areg)",
  /* 292 */  "areg: OPC_F4F4ILOAD(areg)",
  /* 293 */  "freg: OPC_F4F4ILOAD(areg)",
  /* 294 */  "areg: OPC_U4LDA",
  /* 295 */  "areg: OPC_U4LDA_LABEL",
  /* 296 */  "areg: OPC_U4LDA",
  /* 297 */  "areg: OPC_I4I8LDID",
  /* 298 */  "ll_cvt_areg: OPC_I8I8LDID",
  /* 299 */  "areg: OPC_U4U8LDID",
  /* 300 */  "ll_cvt_areg: OPC_U8U8LDID",
  /* 301 */  "areg: OPC_I4I8LDID",
  /* 302 */  "areg: OPC_U4U8LDID",
  /* 303 */  "areg: OPC_I4I8ILOAD(areg)",
  /* 304 */  "areg: OPC_U4U8ILOAD(areg)",
  /* 305 */  "expr: OPC_I8STID(areg)",
  /* 306 */  "expr: OPC_U8STID(areg)",
  /* 307 */  "areg: OPC_I4ADD(areg,areg_or_simm8)",
  /* 308 */  "areg: OPC_I4ADD(simm8,areg)",
  /* 309 */  "areg: OPC_I4ADD(areg,simm8x256)",
  /* 310 */  "areg: OPC_I4ADD(simm8x256,areg)",
  /* 311 */  "areg: OPC_U4ADD(areg,areg_or_simm8)",
  /* 312 */  "areg: OPC_U4ADD(simm8,areg)",
  /* 313 */  "areg: OPC_U4ADD(areg,simm8x256)",
  /* 314 */  "areg: OPC_U4ADD(simm8x256,areg)",
  /* 315 */  "areg: OPC_I4SUB(areg,areg_or_simm8)",
  /* 316 */  "areg: OPC_I4SUB(areg,simm8x256)",
  /* 317 */  "areg: OPC_U4SUB(areg,areg_or_simm8)",
  /* 318 */  "areg: OPC_U4SUB(areg,simm8x256)",
  /* 319 */  "areg: OPC_I4MPY(areg,areg)",
  /* 320 */  "areg: OPC_U4MPY(areg,areg)",
  /* 321 */  "areg: OPC_I4DIV(areg,areg)",
  /* 322 */  "areg: OPC_U4DIV(areg,areg)",
  /* 323 */  "areg: OPC_I4REM(areg,areg)",
  /* 324 */  "areg: OPC_U4REM(areg,areg)",
  /* 325 */  "areg: OPC_I4MOD(areg,areg)",
  /* 326 */  "areg: OPC_U4MOD(areg,areg)",
  /* 327 */  "areg: OPC_I4MAX(areg,areg)",
  /* 328 */  "areg: OPC_U4MAX(areg,areg)",
  /* 329 */  "areg: OPC_I4MIN(areg,areg)",
  /* 330 */  "areg: OPC_U4MIN(areg,areg)",
  /* 331 */  "areg: OPC_I4MIN(OPC_I4MAX(areg,clamps_const),clamps_const)",
  /* 332 */  "areg: OPC_I4MIN(clamps_const,OPC_I4MAX(areg,clamps_const))",
  /* 333 */  "areg: OPC_I4MIN(OPC_I4MAX(clamps_const,areg),clamps_const)",
  /* 334 */  "areg: OPC_I4MIN(clamps_const,OPC_I4MAX(clamps_const,areg))",
  /* 335 */  "areg: OPC_I4MAX(OPC_I4MIN(areg,clamps_const),clamps_const)",
  /* 336 */  "areg: OPC_I4MAX(clamps_const,OPC_I4MIN(areg,clamps_const))",
  /* 337 */  "areg: OPC_I4MAX(OPC_I4MIN(clamps_const,areg),clamps_const)",
  /* 338 */  "areg: OPC_I4MAX(clamps_const,OPC_I4MIN(clamps_const,areg))",
  /* 339 */  "areg: OPC_I4ABS(areg)",
  /* 340 */  "areg: OPC_I4NEG(areg)",
  /* 341 */  "areg: OPC_U4NEG(areg)",
  /* 342 */  "freg: OPC_F4ADD(freg,freg)",
  /* 343 */  "freg: OPC_F4SUB(freg,freg)",
  /* 344 */  "freg: OPC_F4MPY(freg,freg)",
  /* 345 */  "freg: OPC_F4DIV(freg,freg)",
  /* 346 */  "freg: OPC_F4MADD(freg,freg,freg)",
  /* 347 */  "freg: OPC_F4NMADD(freg,freg,freg)",
  /* 348 */  "freg: OPC_F4NMSUB(freg,freg,freg)",
  /* 349 */  "freg: OPC_F4MSUB(freg,freg,freg)",
  /* 350 */  "freg: OPC_F4ABS(freg)",
  /* 351 */  "freg: OPC_F4NEG(freg)",
  /* 352 */  "freg: OPC_F4RECIP(freg)",
  /* 353 */  "freg: OPC_F4RSQRT(freg)",
  /* 354 */  "freg: OPC_F4I4CVT(areg)",
  /* 355 */  "freg: OPC_F4U4CVT(areg)",
  /* 356 */  "areg: OPC_I4F4CVT(freg)",
  /* 357 */  "areg: OPC_I4F4TRUNC(freg)",
  /* 358 */  "areg: OPC_U4F4CVT(freg)",
  /* 359 */  "areg: OPC_U4F4TRUNC(freg)",
  /* 360 */  "areg: OPC_I4F4LT(freg,freg)",
  /* 361 */  "b1reg: OPC_I4F4LT(freg,freg)",
  /* 362 */  "areg: OPC_I4F4GT(freg,freg)",
  /* 363 */  "b1reg: OPC_I4F4GT(freg,freg)",
  /* 364 */  "areg: OPC_I4F4LE(freg,freg)",
  /* 365 */  "b1reg: OPC_I4F4LE(freg,freg)",
  /* 366 */  "areg: OPC_I4F4GE(freg,freg)",
  /* 367 */  "b1reg: OPC_I4F4GE(freg,freg)",
  /* 368 */  "areg: OPC_I4F4EQ(freg,freg)",
  /* 369 */  "b1reg: OPC_I4F4EQ(freg,freg)",
  /* 370 */  "areg: OPC_I4F4NE(freg,freg)",
  /* 371 */  "areg: OPC_U4F4LT(freg,freg)",
  /* 372 */  "b1reg: OPC_U4F4LT(freg,freg)",
  /* 373 */  "areg: OPC_U4F4GT(freg,freg)",
  /* 374 */  "b1reg: OPC_U4F4GT(freg,freg)",
  /* 375 */  "areg: OPC_U4F4LE(freg,freg)",
  /* 376 */  "b1reg: OPC_U4F4LE(freg,freg)",
  /* 377 */  "areg: OPC_U4F4GE(freg,freg)",
  /* 378 */  "b1reg: OPC_U4F4GE(freg,freg)",
  /* 379 */  "areg: OPC_U4F4EQ(freg,freg)",
  /* 380 */  "b1reg: OPC_U4F4EQ(freg,freg)",
  /* 381 */  "areg: OPC_U4F4NE(freg,freg)",
  /* 382 */  "areg: OPC_I4BAND(areg,areg)",
  /* 383 */  "areg: OPC_I4BAND(areg,extui_mask)",
  /* 384 */  "areg: OPC_I4BAND(extui_mask,areg)",
  /* 385 */  "areg: OPC_U4BAND(areg,areg)",
  /* 386 */  "areg: OPC_U4BAND(areg,extui_mask)",
  /* 387 */  "areg: OPC_U4BAND(extui_mask,areg)",
  /* 388 */  "areg: OPC_I4BIOR(areg,areg)",
  /* 389 */  "areg: OPC_U4BIOR(areg,areg)",
  /* 390 */  "areg: OPC_I4BIOR(OPC_I4SHL(areg,one),one)",
  /* 391 */  "areg: OPC_U4BIOR(OPC_U4SHL(areg,one),one)",
  /* 392 */  "areg: OPC_I4BXOR(areg,areg)",
  /* 393 */  "areg: OPC_U4BXOR(areg,areg)",
  /* 394 */  "areg: OPC_I4BNOT(areg)",
  /* 395 */  "areg: OPC_U4BNOT(areg)",
  /* 396 */  "areg: OPC_I4LNOT(areg)",
  /* 397 */  "areg: OPC_U4LNOT(areg)",
  /* 398 */  "areg: OPC_I4SHL(areg,msalp32)",
  /* 399 */  "areg: OPC_U4SHL(areg,msalp32)",
  /* 400 */  "areg: OPC_I4ASHR(areg,uimm5)",
  /* 401 */  "areg: OPC_U4ASHR(areg,uimm5)",
  /* 402 */  "areg: OPC_I4LSHR(areg,uimm4)",
  /* 403 */  "areg: OPC_U4LSHR(areg,uimm4)",
  /* 404 */  "areg: OPC_I4LSHR(areg,uimm5)",
  /* 405 */  "areg: OPC_U4LSHR(areg,uimm5)",
  /* 406 */  "areg: OPC_I4SHL(areg,sar_left)",
  /* 407 */  "areg: OPC_U4SHL(areg,sar_left)",
  /* 408 */  "areg: OPC_I4ASHR(areg,sar_right)",
  /* 409 */  "areg: OPC_U4ASHR(areg,sar_right)",
  /* 410 */  "areg: OPC_I4LSHR(areg,sar_right)",
  /* 411 */  "areg: OPC_U4LSHR(areg,sar_right)",
  /* 412 */  "areg: OPC_U4BIOR(OPC_U4LSHR(areg,wsar),OPC_U4SHL(areg,OPC_I4SUB(thirtytwo,areg)))",
  /* 413 */  "areg: OPC_U4BIOR(OPC_U4LSHR(areg,wsar),OPC_I4SHL(areg,OPC_I4SUB(thirtytwo,areg)))",
  /* 414 */  "areg: OPC_U4BIOR(OPC_U4SHL(areg,OPC_I4SUB(thirtytwo,areg)),OPC_U4LSHR(areg,wsar))",
  /* 415 */  "areg: OPC_U4BIOR(OPC_I4SHL(areg,OPC_I4SUB(thirtytwo,areg)),OPC_U4LSHR(areg,wsar))",
  /* 416 */  "areg: OPC_I4ADD(areg,OPC_I4SHL(areg,msalp32))",
  /* 417 */  "areg: OPC_I4ADD(OPC_I4SHL(areg,msalp32),areg)",
  /* 418 */  "areg: OPC_U4ADD(areg,OPC_U4SHL(areg,msalp32))",
  /* 419 */  "areg: OPC_U4ADD(OPC_U4SHL(areg,msalp32),areg)",
  /* 420 */  "areg: OPC_I4SUB(OPC_I4SHL(areg,msalp32),areg)",
  /* 421 */  "areg: OPC_U4SUB(OPC_U4SHL(areg,msalp32),areg)",
  /* 422 */  "acc_reg: OPC_I4MPY(areg,areg)",
  /* 423 */  "acc_reg: OPC_U4MPY(areg,areg)",
  /* 424 */  "acc_reg: OPC_I4ADD(acc_reg,OPC_I4MPY(areg,areg))",
  /* 425 */  "acc_reg: OPC_I4ADD(OPC_I4MPY(areg,areg),acc_reg)",
  /* 426 */  "acc_reg: OPC_U4ADD(acc_reg,OPC_I4MPY(areg,areg))",
  /* 427 */  "acc_reg: OPC_U4ADD(OPC_I4MPY(areg,areg),acc_reg)",
  /* 428 */  "acc_reg: OPC_I4SUB(acc_reg,OPC_I4MPY(areg,areg))",
  /* 429 */  "acc_reg: OPC_U4SUB(acc_reg,OPC_I4MPY(areg,areg))",
  /* 430 */  "areg: OPC_I4COMPOSE_BITS(areg,areg)",
  /* 431 */  "areg: OPC_U4COMPOSE_BITS(areg,areg)",
  /* 432 */  "areg: OPC_I4EXTRACT_BITS(areg)",
  /* 433 */  "areg: OPC_U4EXTRACT_BITS(areg)",
  /* 434 */  "areg: OPC_U4STBITS(areg)",
  /* 435 */  "areg: OPC_U2STBITS(areg)",
  /* 436 */  "areg: OPC_U1STBITS(areg)",
  /* 437 */  "areg: OPC_I4STBITS(areg)",
  /* 438 */  "areg: OPC_I2STBITS(areg)",
  /* 439 */  "areg: OPC_I1STBITS(areg)",
  /* 440 */  "areg: OPC_U4STBITS(areg)",
  /* 441 */  "areg: OPC_U2STBITS(areg)",
  /* 442 */  "areg: OPC_U1STBITS(areg)",
  /* 443 */  "areg: OPC_I4STBITS(areg)",
  /* 444 */  "areg: OPC_I2STBITS(areg)",
  /* 445 */  "areg: OPC_I1STBITS(areg)",
  /* 446 */  "areg: OPC_U4ISTBITS(areg,OPC_U4LDA)",
  /* 447 */  "areg: OPC_U2ISTBITS(areg,OPC_U4LDA)",
  /* 448 */  "areg: OPC_U1ISTBITS(areg,OPC_U4LDA)",
  /* 449 */  "areg: OPC_I4ISTBITS(areg,OPC_U4LDA)",
  /* 450 */  "areg: OPC_I2ISTBITS(areg,OPC_U4LDA)",
  /* 451 */  "areg: OPC_I1ISTBITS(areg,OPC_U4LDA)",
  /* 452 */  "areg: OPC_U4ISTBITS(areg,areg)",
  /* 453 */  "areg: OPC_U2ISTBITS(areg,areg)",
  /* 454 */  "areg: OPC_U1ISTBITS(areg,areg)",
  /* 455 */  "areg: OPC_I4ISTBITS(areg,areg)",
  /* 456 */  "areg: OPC_I2ISTBITS(areg,areg)",
  /* 457 */  "areg: OPC_I1ISTBITS(areg,areg)",
  /* 458 */  "areg: OPC_U4U4LDBITS",
  /* 459 */  "areg: OPC_U4U2LDBITS",
  /* 460 */  "areg: OPC_U4U1LDBITS",
  /* 461 */  "areg: OPC_U4I4LDBITS",
  /* 462 */  "areg: OPC_U4I2LDBITS",
  /* 463 */  "areg: OPC_U4I1LDBITS",
  /* 464 */  "areg: OPC_I4U4LDBITS",
  /* 465 */  "areg: OPC_I4U2LDBITS",
  /* 466 */  "areg: OPC_I4U1LDBITS",
  /* 467 */  "areg: OPC_I4I4LDBITS",
  /* 468 */  "areg: OPC_I4I2LDBITS",
  /* 469 */  "areg: OPC_I4I1LDBITS",
  /* 470 */  "areg: OPC_U4U4LDBITS",
  /* 471 */  "areg: OPC_U4U2LDBITS",
  /* 472 */  "areg: OPC_U4U1LDBITS",
  /* 473 */  "areg: OPC_U4I4LDBITS",
  /* 474 */  "areg: OPC_U4I2LDBITS",
  /* 475 */  "areg: OPC_U4I1LDBITS",
  /* 476 */  "areg: OPC_I4U4LDBITS",
  /* 477 */  "areg: OPC_I4U2LDBITS",
  /* 478 */  "areg: OPC_I4U1LDBITS",
  /* 479 */  "areg: OPC_I4I4LDBITS",
  /* 480 */  "areg: OPC_I4I2LDBITS",
  /* 481 */  "areg: OPC_I4I1LDBITS",
  /* 482 */  "areg: OPC_U4U4ILDBITS(OPC_U4LDA)",
  /* 483 */  "areg: OPC_U4U2ILDBITS(OPC_U4LDA)",
  /* 484 */  "areg: OPC_U4U1ILDBITS(OPC_U4LDA)",
  /* 485 */  "areg: OPC_U4I4ILDBITS(OPC_U4LDA)",
  /* 486 */  "areg: OPC_U4I2ILDBITS(OPC_U4LDA)",
  /* 487 */  "areg: OPC_U4I1ILDBITS(OPC_U4LDA)",
  /* 488 */  "areg: OPC_I4U4ILDBITS(OPC_U4LDA)",
  /* 489 */  "areg: OPC_I4U2ILDBITS(OPC_U4LDA)",
  /* 490 */  "areg: OPC_I4U1ILDBITS(OPC_U4LDA)",
  /* 491 */  "areg: OPC_I4I4ILDBITS(OPC_U4LDA)",
  /* 492 */  "areg: OPC_I4I2ILDBITS(OPC_U4LDA)",
  /* 493 */  "areg: OPC_I4I1ILDBITS(OPC_U4LDA)",
  /* 494 */  "areg: OPC_U4U4ILDBITS(areg)",
  /* 495 */  "areg: OPC_U4U2ILDBITS(areg)",
  /* 496 */  "areg: OPC_U4U1ILDBITS(areg)",
  /* 497 */  "areg: OPC_U4I4ILDBITS(areg)",
  /* 498 */  "areg: OPC_U4I2ILDBITS(areg)",
  /* 499 */  "areg: OPC_U4I1ILDBITS(areg)",
  /* 500 */  "areg: OPC_I4U4ILDBITS(areg)",
  /* 501 */  "areg: OPC_I4U2ILDBITS(areg)",
  /* 502 */  "areg: OPC_I4U1ILDBITS(areg)",
  /* 503 */  "areg: OPC_I4I4ILDBITS(areg)",
  /* 504 */  "areg: OPC_I4I2ILDBITS(areg)",
  /* 505 */  "areg: OPC_I4I1ILDBITS(areg)",
  /* 506 */  "areg: OPC_U4CVTL(areg)",
  /* 507 */  "areg: OPC_I4CVTL(areg)",
  /* 508 */  "areg: OPC_U4CVTL(areg)",
  /* 509 */  "areg: OPC_I4CVTL(areg)",
  /* 510 */  "areg: OPC_I4U4CVT(areg)",
  /* 511 */  "areg: OPC_U4I4CVT(areg)",
  /* 512 */  "sar_left: areg",
  /* 513 */  "sar_right: areg",
  /* 514 */  "wsar: areg",
  /* 515 */  "areg: OPC_TN",
  /* 516 */  "tie_reg: OPC_TN",
  /* 517 */  "breg: OPC_TN",
  /* 518 */  "acc_reg: areg",
  /* 519 */  "areg: acc_reg",
  /* 520 */  "freg: OPC_TN",
  /* 521 */  "freg: areg",
  /* 522 */  "areg: freg",
  /* 523 */  "areg: simm12",
  /* 524 */  "areg: simm32",
  /* 525 */  "areg: float_const",
  /* 526 */  "areg_or_simm12: areg",
  /* 527 */  "areg_or_simm12: simm12",
  /* 528 */  "areg_or_simm8: areg",
  /* 529 */  "areg_or_simm8: simm8",
  /* 530 */  "areg_or_b4const: areg",
  /* 531 */  "areg_or_b4const: b4const",
  /* 532 */  "areg_or_b4constu: areg",
  /* 533 */  "areg_or_b4constu: b4constu",
  /* 534 */  "zero: OPC_I4INTCONST",
  /* 535 */  "zero: OPC_U4INTCONST",
  /* 536 */  "one: OPC_I4INTCONST",
  /* 537 */  "one: OPC_U4INTCONST",
  /* 538 */  "one: OPC_I4I4LDID",
  /* 539 */  "one: OPC_U4U4LDID",
  /* 540 */  "thirtytwo: OPC_I4INTCONST",
  /* 541 */  "thirtytwo: OPC_U4INTCONST",
  /* 542 */  "thirtytwo: OPC_I4I4LDID",
  /* 543 */  "one: OPC_U4U4LDID",
  /* 544 */  "float_const: OPC_F4CONST",
  /* 545 */  "extui_mask: OPC_I4INTCONST",
  /* 546 */  "extui_mask: OPC_U4INTCONST",
  /* 547 */  "extui_mask: OPC_I4I4LDID",
  /* 548 */  "extui_mask: OPC_U4U4LDID",
  /* 549 */  "bbci_bbsi_imm: OPC_I4INTCONST",
  /* 550 */  "bbci_bbsi_imm: OPC_U4INTCONST",
  /* 551 */  "bbci_bbsi_imm: OPC_I4I4LDID",
  /* 552 */  "bbci_bbsi_imm: OPC_U4U4LDID",
  /* 553 */  "logical_and_immed: OPC_I4INTCONST",
  /* 554 */  "logical_and_immed: OPC_U4INTCONST",
  /* 555 */  "logical_and_immed: OPC_I4I4LDID",
  /* 556 */  "logical_and_immed: OPC_U4U4LDID",
  /* 557 */  "logical_and_immed: OPC_I4SHL(one,areg)",
  /* 558 */  "logical_and_immed: OPC_U4SHL(one,areg)",
  /* 559 */  "clamps_const: OPC_I4INTCONST",
  /* 560 */  "clamps_const: OPC_U4INTCONST",
  /* 561 */  "clamps_const: OPC_I4I4LDID",
  /* 562 */  "clamps_const: OPC_U4U4LDID",
  /* 563 */  "simm8x256: OPC_I4INTCONST",
  /* 564 */  "simm8x256: OPC_U4INTCONST",
  /* 565 */  "simm8x256: OPC_TN",
  /* 566 */  "simm8x256: OPC_I4I4LDID",
  /* 567 */  "simm8x256: OPC_U4U4LDID",
  /* 568 */  "simm8: OPC_I4INTCONST",
  /* 569 */  "simm8: OPC_U4INTCONST",
  /* 570 */  "simm8: OPC_TN",
  /* 571 */  "simm8: OPC_I4I4LDID",
  /* 572 */  "simm8: OPC_U4U4LDID",
  /* 573 */  "simm12: OPC_I4INTCONST",
  /* 574 */  "simm12: OPC_U4INTCONST",
  /* 575 */  "simm12: OPC_TN",
  /* 576 */  "simm32: OPC_I4INTCONST",
  /* 577 */  "simm32: OPC_U4INTCONST",
  /* 578 */  "simm32: OPC_TN",
  /* 579 */  "tie_imm: OPC_I4INTCONST",
  /* 580 */  "tie_imm: OPC_U4INTCONST",
  /* 581 */  "tie_imm: OPC_TN",
  /* 582 */  "expr: tie_imm",
  /* 583 */  "uimm4: OPC_I4INTCONST",
  /* 584 */  "uimm4: OPC_U4INTCONST",
  /* 585 */  "uimm4: OPC_TN",
  /* 586 */  "uimm4: OPC_I4I4LDID",
  /* 587 */  "uimm4: OPC_U4U4LDID",
  /* 588 */  "uimm5: OPC_I4INTCONST",
  /* 589 */  "uimm5: OPC_U4INTCONST",
  /* 590 */  "uimm5: OPC_TN",
  /* 591 */  "uimm5: OPC_I4I4LDID",
  /* 592 */  "uimm5: OPC_U4U4LDID",
  /* 593 */  "b4constu: OPC_I4INTCONST",
  /* 594 */  "b4constu: OPC_U4INTCONST",
  /* 595 */  "b4constu: OPC_TN",
  /* 596 */  "b4constu: OPC_I4I4LDID",
  /* 597 */  "b4constu: OPC_U4U4LDID",
  /* 598 */  "b4const: OPC_I4INTCONST",
  /* 599 */  "b4const: OPC_U4INTCONST",
  /* 600 */  "b4const: OPC_TN",
  /* 601 */  "b4const: OPC_I4I4LDID",
  /* 602 */  "b4const: OPC_U4U4LDID",
  /* 603 */  "msalp32: OPC_I4INTCONST",
  /* 604 */  "msalp32: OPC_U4INTCONST",
  /* 605 */  "msalp32: OPC_TN",
  /* 606 */  "msalp32: OPC_I4I4LDID",
  /* 607 */  "msalp32: OPC_U4U4LDID",
  /* 608 */  "b1reg: OPC_XTBOOLXTBOOLLDID",
  /* 609 */  "breg: OPC_XTBOOL2XTBOOL2LDID",
  /* 610 */  "breg: OPC_XTBOOL4XTBOOL4LDID",
  /* 611 */  "breg: OPC_XTBOOL8XTBOOL8LDID",
  /* 612 */  "breg: OPC_XTBOOL16XTBOOL16LDID",
  /* 613 */  "breg: OPC_XTBOOLXTBOOLLDID",
  /* 614 */  "breg: OPC_XTBOOL2XTBOOL2LDID",
  /* 615 */  "breg: OPC_XTBOOL4XTBOOL4LDID",
  /* 616 */  "breg: OPC_XTBOOL8XTBOOL8LDID",
  /* 617 */  "breg: OPC_XTBOOL16XTBOOL16LDID",
  /* 618 */  "b1reg: OPC_XTBOOLI4CVT(b1reg)",
  /* 619 */  "bareg: OPC_XTBOOLXTBOOLLDID",
  /* 620 */  "bareg: OPC_XTBOOL2XTBOOL2LDID",
  /* 621 */  "bareg: OPC_XTBOOL4XTBOOL4LDID",
  /* 622 */  "bareg: OPC_XTBOOL8XTBOOL8LDID",
  /* 623 */  "bareg: OPC_XTBOOL16XTBOOL16LDID",
  /* 624 */  "bareg: breg",
  /* 625 */  "breg: b1reg",
  /* 626 */  "b1reg: bareg",
  /* 627 */  "breg: bareg",
  /* 628 */  "expr: OPC_XTBOOLSTID(b1reg)",
  /* 629 */  "expr: OPC_XTBOOL2STID(breg)",
  /* 630 */  "expr: OPC_XTBOOL4STID(breg)",
  /* 631 */  "expr: OPC_XTBOOL8STID(breg)",
  /* 632 */  "expr: OPC_XTBOOL16STID(breg)",
  /* 633 */  "expr: OPC_XTBOOLSTID(bareg)",
  /* 634 */  "expr: OPC_XTBOOL2STID(bareg)",
  /* 635 */  "expr: OPC_XTBOOL4STID(bareg)",
  /* 636 */  "expr: OPC_XTBOOL8STID(bareg)",
  /* 637 */  "expr: OPC_XTBOOL16STID(bareg)",
  /* 638 */  "expr: OPC_XTBOOLSTID(breg)",
  /* 639 */  "expr: OPC_XTBOOL2STID(breg)",
  /* 640 */  "expr: OPC_XTBOOL4STID(breg)",
  /* 641 */  "expr: OPC_XTBOOL8STID(breg)",
  /* 642 */  "expr: OPC_XTBOOL16STID(breg)",
  /* 643 */  "expr: OPC_XTBOOLSTID(bareg)",
  /* 644 */  "expr: OPC_XTBOOL2STID(bareg)",
  /* 645 */  "expr: OPC_XTBOOL4STID(bareg)",
  /* 646 */  "expr: OPC_XTBOOL8STID(bareg)",
  /* 647 */  "expr: OPC_XTBOOL16STID(bareg)",
  /* 648 */  "breg: OPC_XTBOOLXTBOOLILOAD(areg)",
  /* 649 */  "breg: OPC_XTBOOL2XTBOOL2ILOAD(areg)",
  /* 650 */  "breg: OPC_XTBOOL4XTBOOL4ILOAD(areg)",
  /* 651 */  "breg: OPC_XTBOOL8XTBOOL8ILOAD(areg)",
  /* 652 */  "breg: OPC_XTBOOL16XTBOOL16ILOAD(areg)",
  /* 653 */  "bareg: OPC_XTBOOLXTBOOLILOAD(areg)",
  /* 654 */  "bareg: OPC_XTBOOL2XTBOOL2ILOAD(areg)",
  /* 655 */  "bareg: OPC_XTBOOL4XTBOOL4ILOAD(areg)",
  /* 656 */  "bareg: OPC_XTBOOL8XTBOOL8ILOAD(areg)",
  /* 657 */  "bareg: OPC_XTBOOL16XTBOOL16ILOAD(areg)",
  /* 658 */  "expr: OPC_XTBOOLISTORE(breg,areg)",
  /* 659 */  "expr: OPC_XTBOOL2ISTORE(breg,areg)",
  /* 660 */  "expr: OPC_XTBOOL4ISTORE(breg,areg)",
  /* 661 */  "expr: OPC_XTBOOL8ISTORE(breg,areg)",
  /* 662 */  "expr: OPC_XTBOOL16ISTORE(breg,areg)",
  /* 663 */  "expr: OPC_XTBOOLISTORE(bareg,areg)",
  /* 664 */  "expr: OPC_XTBOOL2ISTORE(bareg,areg)",
  /* 665 */  "expr: OPC_XTBOOL4ISTORE(bareg,areg)",
  /* 666 */  "expr: OPC_XTBOOL8ISTORE(bareg,areg)",
  /* 667 */  "expr: OPC_XTBOOL16ISTORE(bareg,areg)",
  /* 668 */  "bareg: OPC_XTBOOLI4CVT(areg)",
  /* 669 */  "bareg: OPC_XTBOOL2I4CVT(areg)",
  /* 670 */  "bareg: OPC_XTBOOL4I4CVT(areg)",
  /* 671 */  "bareg: OPC_XTBOOL8I4CVT(areg)",
  /* 672 */  "bareg: OPC_XTBOOL16I4CVT(areg)",
  /* 673 */  "areg: OPC_I4XTBOOLCVT(bareg)",
  /* 674 */  "areg: OPC_I4XTBOOL2CVT(bareg)",
  /* 675 */  "areg: OPC_I4XTBOOL4CVT(bareg)",
  /* 676 */  "areg: OPC_I4XTBOOL8CVT(bareg)",
  /* 677 */  "areg: OPC_I4XTBOOL16CVT(bareg)",
  /* 678 */  "bareg: OPC_XTBOOLU4CVT(areg)",
  /* 679 */  "bareg: OPC_XTBOOL2U4CVT(areg)",
  /* 680 */  "bareg: OPC_XTBOOL4U4CVT(areg)",
  /* 681 */  "bareg: OPC_XTBOOL8U4CVT(areg)",
  /* 682 */  "bareg: OPC_XTBOOL16U4CVT(areg)",
  /* 683 */  "areg: OPC_U4XTBOOLCVT(bareg)",
  /* 684 */  "areg: OPC_U4XTBOOL2CVT(bareg)",
  /* 685 */  "areg: OPC_U4XTBOOL4CVT(bareg)",
  /* 686 */  "areg: OPC_U4XTBOOL8CVT(bareg)",
  /* 687 */  "areg: OPC_U4XTBOOL16CVT(bareg)",
  /* 688 */  "b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg))",
  /* 689 */  "b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)))",
  /* 690 */  "b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg))",
  /* 691 */  "b1reg: OPC_I4BAND(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)),OPC_I4XTBOOLCVT(b1reg))",
  /* 692 */  "b1reg: OPC_I4BAND(OPC_XTBOOLBNOT(b1reg),OPC_I4XTBOOLCVT(b1reg))",
  /* 693 */  "b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg))",
  /* 694 */  "b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)))",
  /* 695 */  "b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg))",
  /* 696 */  "b1reg: OPC_I4BIOR(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)),OPC_I4XTBOOLCVT(b1reg))",
  /* 697 */  "b1reg: OPC_I4BIOR(OPC_XTBOOLBNOT(b1reg),OPC_I4XTBOOLCVT(b1reg))",
  /* 698 */  "b1reg: OPC_I4BXOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg))",
  /* 699 */  "b1reg: OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))",
  /* 700 */  "b1reg: OPC_XTBOOLBNOT(b1reg)",
  /* 701 */  "stmt: OPC_XTBOOLCALL",
  /* 702 */  "stmt: OPC_XTBOOL2CALL",
  /* 703 */  "stmt: OPC_XTBOOL4CALL",
  /* 704 */  "stmt: OPC_XTBOOL8CALL",
  /* 705 */  "stmt: OPC_XTBOOL16CALL",
};


char *ISEL_files[] = {
"/build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat",
};

int ISEL_file_numbers[] = {
  /* 0 */  0,
  /* 1 */  0,
  /* 2 */  0,
  /* 3 */  0,
  /* 4 */  0,
  /* 5 */  0,
  /* 6 */  0,
  /* 7 */  0,
  /* 8 */  0,
  /* 9 */  0,
  /* 10 */  0,
  /* 11 */  0,
  /* 12 */  0,
  /* 13 */  0,
  /* 14 */  0,
  /* 15 */  0,
  /* 16 */  0,
  /* 17 */  0,
  /* 18 */  0,
  /* 19 */  0,
  /* 20 */  0,
  /* 21 */  0,
  /* 22 */  0,
  /* 23 */  0,
  /* 24 */  0,
  /* 25 */  0,
  /* 26 */  0,
  /* 27 */  0,
  /* 28 */  0,
  /* 29 */  0,
  /* 30 */  0,
  /* 31 */  0,
  /* 32 */  0,
  /* 33 */  0,
  /* 34 */  0,
  /* 35 */  0,
  /* 36 */  0,
  /* 37 */  0,
  /* 38 */  0,
  /* 39 */  0,
  /* 40 */  0,
  /* 41 */  0,
  /* 42 */  0,
  /* 43 */  0,
  /* 44 */  0,
  /* 45 */  0,
  /* 46 */  0,
  /* 47 */  0,
  /* 48 */  0,
  /* 49 */  0,
  /* 50 */  0,
  /* 51 */  0,
  /* 52 */  0,
  /* 53 */  0,
  /* 54 */  0,
  /* 55 */  0,
  /* 56 */  0,
  /* 57 */  0,
  /* 58 */  0,
  /* 59 */  0,
  /* 60 */  0,
  /* 61 */  0,
  /* 62 */  0,
  /* 63 */  0,
  /* 64 */  0,
  /* 65 */  0,
  /* 66 */  0,
  /* 67 */  0,
  /* 68 */  0,
  /* 69 */  0,
  /* 70 */  0,
  /* 71 */  0,
  /* 72 */  0,
  /* 73 */  0,
  /* 74 */  0,
  /* 75 */  0,
  /* 76 */  0,
  /* 77 */  0,
  /* 78 */  0,
  /* 79 */  0,
  /* 80 */  0,
  /* 81 */  0,
  /* 82 */  0,
  /* 83 */  0,
  /* 84 */  0,
  /* 85 */  0,
  /* 86 */  0,
  /* 87 */  0,
  /* 88 */  0,
  /* 89 */  0,
  /* 90 */  0,
  /* 91 */  0,
  /* 92 */  0,
  /* 93 */  0,
  /* 94 */  0,
  /* 95 */  0,
  /* 96 */  0,
  /* 97 */  0,
  /* 98 */  0,
  /* 99 */  0,
  /* 100 */  0,
  /* 101 */  0,
  /* 102 */  0,
  /* 103 */  0,
  /* 104 */  0,
  /* 105 */  0,
  /* 106 */  0,
  /* 107 */  0,
  /* 108 */  0,
  /* 109 */  0,
  /* 110 */  0,
  /* 111 */  0,
  /* 112 */  0,
  /* 113 */  0,
  /* 114 */  0,
  /* 115 */  0,
  /* 116 */  0,
  /* 117 */  0,
  /* 118 */  0,
  /* 119 */  0,
  /* 120 */  0,
  /* 121 */  0,
  /* 122 */  0,
  /* 123 */  0,
  /* 124 */  0,
  /* 125 */  0,
  /* 126 */  0,
  /* 127 */  0,
  /* 128 */  0,
  /* 129 */  0,
  /* 130 */  0,
  /* 131 */  0,
  /* 132 */  0,
  /* 133 */  0,
  /* 134 */  0,
  /* 135 */  0,
  /* 136 */  0,
  /* 137 */  0,
  /* 138 */  0,
  /* 139 */  0,
  /* 140 */  0,
  /* 141 */  0,
  /* 142 */  0,
  /* 143 */  0,
  /* 144 */  0,
  /* 145 */  0,
  /* 146 */  0,
  /* 147 */  0,
  /* 148 */  0,
  /* 149 */  0,
  /* 150 */  0,
  /* 151 */  0,
  /* 152 */  0,
  /* 153 */  0,
  /* 154 */  0,
  /* 155 */  0,
  /* 156 */  0,
  /* 157 */  0,
  /* 158 */  0,
  /* 159 */  0,
  /* 160 */  0,
  /* 161 */  0,
  /* 162 */  0,
  /* 163 */  0,
  /* 164 */  0,
  /* 165 */  0,
  /* 166 */  0,
  /* 167 */  0,
  /* 168 */  0,
  /* 169 */  0,
  /* 170 */  0,
  /* 171 */  0,
  /* 172 */  0,
  /* 173 */  0,
  /* 174 */  0,
  /* 175 */  0,
  /* 176 */  0,
  /* 177 */  0,
  /* 178 */  0,
  /* 179 */  0,
  /* 180 */  0,
  /* 181 */  0,
  /* 182 */  0,
  /* 183 */  0,
  /* 184 */  0,
  /* 185 */  0,
  /* 186 */  0,
  /* 187 */  0,
  /* 188 */  0,
  /* 189 */  0,
  /* 190 */  0,
  /* 191 */  0,
  /* 192 */  0,
  /* 193 */  0,
  /* 194 */  0,
  /* 195 */  0,
  /* 196 */  0,
  /* 197 */  0,
  /* 198 */  0,
  /* 199 */  0,
  /* 200 */  0,
  /* 201 */  0,
  /* 202 */  0,
  /* 203 */  0,
  /* 204 */  0,
  /* 205 */  0,
  /* 206 */  0,
  /* 207 */  0,
  /* 208 */  0,
  /* 209 */  0,
  /* 210 */  0,
  /* 211 */  0,
  /* 212 */  0,
  /* 213 */  0,
  /* 214 */  0,
  /* 215 */  0,
  /* 216 */  0,
  /* 217 */  0,
  /* 218 */  0,
  /* 219 */  0,
  /* 220 */  0,
  /* 221 */  0,
  /* 222 */  0,
  /* 223 */  0,
  /* 224 */  0,
  /* 225 */  0,
  /* 226 */  0,
  /* 227 */  0,
  /* 228 */  0,
  /* 229 */  0,
  /* 230 */  0,
  /* 231 */  0,
  /* 232 */  0,
  /* 233 */  0,
  /* 234 */  0,
  /* 235 */  0,
  /* 236 */  0,
  /* 237 */  0,
  /* 238 */  0,
  /* 239 */  0,
  /* 240 */  0,
  /* 241 */  0,
  /* 242 */  0,
  /* 243 */  0,
  /* 244 */  0,
  /* 245 */  0,
  /* 246 */  0,
  /* 247 */  0,
  /* 248 */  0,
  /* 249 */  0,
  /* 250 */  0,
  /* 251 */  0,
  /* 252 */  0,
  /* 253 */  0,
  /* 254 */  0,
  /* 255 */  0,
  /* 256 */  0,
  /* 257 */  0,
  /* 258 */  0,
  /* 259 */  0,
  /* 260 */  0,
  /* 261 */  0,
  /* 262 */  0,
  /* 263 */  0,
  /* 264 */  0,
  /* 265 */  0,
  /* 266 */  0,
  /* 267 */  0,
  /* 268 */  0,
  /* 269 */  0,
  /* 270 */  0,
  /* 271 */  0,
  /* 272 */  0,
  /* 273 */  0,
  /* 274 */  0,
  /* 275 */  0,
  /* 276 */  0,
  /* 277 */  0,
  /* 278 */  0,
  /* 279 */  0,
  /* 280 */  0,
  /* 281 */  0,
  /* 282 */  0,
  /* 283 */  0,
  /* 284 */  0,
  /* 285 */  0,
  /* 286 */  0,
  /* 287 */  0,
  /* 288 */  0,
  /* 289 */  0,
  /* 290 */  0,
  /* 291 */  0,
  /* 292 */  0,
  /* 293 */  0,
  /* 294 */  0,
  /* 295 */  0,
  /* 296 */  0,
  /* 297 */  0,
  /* 298 */  0,
  /* 299 */  0,
  /* 300 */  0,
  /* 301 */  0,
  /* 302 */  0,
  /* 303 */  0,
  /* 304 */  0,
  /* 305 */  0,
  /* 306 */  0,
  /* 307 */  0,
  /* 308 */  0,
  /* 309 */  0,
  /* 310 */  0,
  /* 311 */  0,
  /* 312 */  0,
  /* 313 */  0,
  /* 314 */  0,
  /* 315 */  0,
  /* 316 */  0,
  /* 317 */  0,
  /* 318 */  0,
  /* 319 */  0,
  /* 320 */  0,
  /* 321 */  0,
  /* 322 */  0,
  /* 323 */  0,
  /* 324 */  0,
  /* 325 */  0,
  /* 326 */  0,
  /* 327 */  0,
  /* 328 */  0,
  /* 329 */  0,
  /* 330 */  0,
  /* 331 */  0,
  /* 332 */  0,
  /* 333 */  0,
  /* 334 */  0,
  /* 335 */  0,
  /* 336 */  0,
  /* 337 */  0,
  /* 338 */  0,
  /* 339 */  0,
  /* 340 */  0,
  /* 341 */  0,
  /* 342 */  0,
  /* 343 */  0,
  /* 344 */  0,
  /* 345 */  0,
  /* 346 */  0,
  /* 347 */  0,
  /* 348 */  0,
  /* 349 */  0,
  /* 350 */  0,
  /* 351 */  0,
  /* 352 */  0,
  /* 353 */  0,
  /* 354 */  0,
  /* 355 */  0,
  /* 356 */  0,
  /* 357 */  0,
  /* 358 */  0,
  /* 359 */  0,
  /* 360 */  0,
  /* 361 */  0,
  /* 362 */  0,
  /* 363 */  0,
  /* 364 */  0,
  /* 365 */  0,
  /* 366 */  0,
  /* 367 */  0,
  /* 368 */  0,
  /* 369 */  0,
  /* 370 */  0,
  /* 371 */  0,
  /* 372 */  0,
  /* 373 */  0,
  /* 374 */  0,
  /* 375 */  0,
  /* 376 */  0,
  /* 377 */  0,
  /* 378 */  0,
  /* 379 */  0,
  /* 380 */  0,
  /* 381 */  0,
  /* 382 */  0,
  /* 383 */  0,
  /* 384 */  0,
  /* 385 */  0,
  /* 386 */  0,
  /* 387 */  0,
  /* 388 */  0,
  /* 389 */  0,
  /* 390 */  0,
  /* 391 */  0,
  /* 392 */  0,
  /* 393 */  0,
  /* 394 */  0,
  /* 395 */  0,
  /* 396 */  0,
  /* 397 */  0,
  /* 398 */  0,
  /* 399 */  0,
  /* 400 */  0,
  /* 401 */  0,
  /* 402 */  0,
  /* 403 */  0,
  /* 404 */  0,
  /* 405 */  0,
  /* 406 */  0,
  /* 407 */  0,
  /* 408 */  0,
  /* 409 */  0,
  /* 410 */  0,
  /* 411 */  0,
  /* 412 */  0,
  /* 413 */  0,
  /* 414 */  0,
  /* 415 */  0,
  /* 416 */  0,
  /* 417 */  0,
  /* 418 */  0,
  /* 419 */  0,
  /* 420 */  0,
  /* 421 */  0,
  /* 422 */  0,
  /* 423 */  0,
  /* 424 */  0,
  /* 425 */  0,
  /* 426 */  0,
  /* 427 */  0,
  /* 428 */  0,
  /* 429 */  0,
  /* 430 */  0,
  /* 431 */  0,
  /* 432 */  0,
  /* 433 */  0,
  /* 434 */  0,
  /* 435 */  0,
  /* 436 */  0,
  /* 437 */  0,
  /* 438 */  0,
  /* 439 */  0,
  /* 440 */  0,
  /* 441 */  0,
  /* 442 */  0,
  /* 443 */  0,
  /* 444 */  0,
  /* 445 */  0,
  /* 446 */  0,
  /* 447 */  0,
  /* 448 */  0,
  /* 449 */  0,
  /* 450 */  0,
  /* 451 */  0,
  /* 452 */  0,
  /* 453 */  0,
  /* 454 */  0,
  /* 455 */  0,
  /* 456 */  0,
  /* 457 */  0,
  /* 458 */  0,
  /* 459 */  0,
  /* 460 */  0,
  /* 461 */  0,
  /* 462 */  0,
  /* 463 */  0,
  /* 464 */  0,
  /* 465 */  0,
  /* 466 */  0,
  /* 467 */  0,
  /* 468 */  0,
  /* 469 */  0,
  /* 470 */  0,
  /* 471 */  0,
  /* 472 */  0,
  /* 473 */  0,
  /* 474 */  0,
  /* 475 */  0,
  /* 476 */  0,
  /* 477 */  0,
  /* 478 */  0,
  /* 479 */  0,
  /* 480 */  0,
  /* 481 */  0,
  /* 482 */  0,
  /* 483 */  0,
  /* 484 */  0,
  /* 485 */  0,
  /* 486 */  0,
  /* 487 */  0,
  /* 488 */  0,
  /* 489 */  0,
  /* 490 */  0,
  /* 491 */  0,
  /* 492 */  0,
  /* 493 */  0,
  /* 494 */  0,
  /* 495 */  0,
  /* 496 */  0,
  /* 497 */  0,
  /* 498 */  0,
  /* 499 */  0,
  /* 500 */  0,
  /* 501 */  0,
  /* 502 */  0,
  /* 503 */  0,
  /* 504 */  0,
  /* 505 */  0,
  /* 506 */  0,
  /* 507 */  0,
  /* 508 */  0,
  /* 509 */  0,
  /* 510 */  0,
  /* 511 */  0,
  /* 512 */  0,
  /* 513 */  0,
  /* 514 */  0,
  /* 515 */  0,
  /* 516 */  0,
  /* 517 */  0,
  /* 518 */  0,
  /* 519 */  0,
  /* 520 */  0,
  /* 521 */  0,
  /* 522 */  0,
  /* 523 */  0,
  /* 524 */  0,
  /* 525 */  0,
  /* 526 */  0,
  /* 527 */  0,
  /* 528 */  0,
  /* 529 */  0,
  /* 530 */  0,
  /* 531 */  0,
  /* 532 */  0,
  /* 533 */  0,
  /* 534 */  0,
  /* 535 */  0,
  /* 536 */  0,
  /* 537 */  0,
  /* 538 */  0,
  /* 539 */  0,
  /* 540 */  0,
  /* 541 */  0,
  /* 542 */  0,
  /* 543 */  0,
  /* 544 */  0,
  /* 545 */  0,
  /* 546 */  0,
  /* 547 */  0,
  /* 548 */  0,
  /* 549 */  0,
  /* 550 */  0,
  /* 551 */  0,
  /* 552 */  0,
  /* 553 */  0,
  /* 554 */  0,
  /* 555 */  0,
  /* 556 */  0,
  /* 557 */  0,
  /* 558 */  0,
  /* 559 */  0,
  /* 560 */  0,
  /* 561 */  0,
  /* 562 */  0,
  /* 563 */  0,
  /* 564 */  0,
  /* 565 */  0,
  /* 566 */  0,
  /* 567 */  0,
  /* 568 */  0,
  /* 569 */  0,
  /* 570 */  0,
  /* 571 */  0,
  /* 572 */  0,
  /* 573 */  0,
  /* 574 */  0,
  /* 575 */  0,
  /* 576 */  0,
  /* 577 */  0,
  /* 578 */  0,
  /* 579 */  0,
  /* 580 */  0,
  /* 581 */  0,
  /* 582 */  0,
  /* 583 */  0,
  /* 584 */  0,
  /* 585 */  0,
  /* 586 */  0,
  /* 587 */  0,
  /* 588 */  0,
  /* 589 */  0,
  /* 590 */  0,
  /* 591 */  0,
  /* 592 */  0,
  /* 593 */  0,
  /* 594 */  0,
  /* 595 */  0,
  /* 596 */  0,
  /* 597 */  0,
  /* 598 */  0,
  /* 599 */  0,
  /* 600 */  0,
  /* 601 */  0,
  /* 602 */  0,
  /* 603 */  0,
  /* 604 */  0,
  /* 605 */  0,
  /* 606 */  0,
  /* 607 */  0,
  /* 608 */  0,
  /* 609 */  0,
  /* 610 */  0,
  /* 611 */  0,
  /* 612 */  0,
  /* 613 */  0,
  /* 614 */  0,
  /* 615 */  0,
  /* 616 */  0,
  /* 617 */  0,
  /* 618 */  0,
  /* 619 */  0,
  /* 620 */  0,
  /* 621 */  0,
  /* 622 */  0,
  /* 623 */  0,
  /* 624 */  0,
  /* 625 */  0,
  /* 626 */  0,
  /* 627 */  0,
  /* 628 */  0,
  /* 629 */  0,
  /* 630 */  0,
  /* 631 */  0,
  /* 632 */  0,
  /* 633 */  0,
  /* 634 */  0,
  /* 635 */  0,
  /* 636 */  0,
  /* 637 */  0,
  /* 638 */  0,
  /* 639 */  0,
  /* 640 */  0,
  /* 641 */  0,
  /* 642 */  0,
  /* 643 */  0,
  /* 644 */  0,
  /* 645 */  0,
  /* 646 */  0,
  /* 647 */  0,
  /* 648 */  0,
  /* 649 */  0,
  /* 650 */  0,
  /* 651 */  0,
  /* 652 */  0,
  /* 653 */  0,
  /* 654 */  0,
  /* 655 */  0,
  /* 656 */  0,
  /* 657 */  0,
  /* 658 */  0,
  /* 659 */  0,
  /* 660 */  0,
  /* 661 */  0,
  /* 662 */  0,
  /* 663 */  0,
  /* 664 */  0,
  /* 665 */  0,
  /* 666 */  0,
  /* 667 */  0,
  /* 668 */  0,
  /* 669 */  0,
  /* 670 */  0,
  /* 671 */  0,
  /* 672 */  0,
  /* 673 */  0,
  /* 674 */  0,
  /* 675 */  0,
  /* 676 */  0,
  /* 677 */  0,
  /* 678 */  0,
  /* 679 */  0,
  /* 680 */  0,
  /* 681 */  0,
  /* 682 */  0,
  /* 683 */  0,
  /* 684 */  0,
  /* 685 */  0,
  /* 686 */  0,
  /* 687 */  0,
  /* 688 */  0,
  /* 689 */  0,
  /* 690 */  0,
  /* 691 */  0,
  /* 692 */  0,
  /* 693 */  0,
  /* 694 */  0,
  /* 695 */  0,
  /* 696 */  0,
  /* 697 */  0,
  /* 698 */  0,
  /* 699 */  0,
  /* 700 */  0,
  /* 701 */  0,
  /* 702 */  0,
  /* 703 */  0,
  /* 704 */  0,
  /* 705 */  0,
};

int ISEL_line_numbers[] = {
  /* 0 */  2294,
  /* 1 */  2298,
  /* 2 */  2309,
  /* 3 */  2320,
  /* 4 */  2326,
  /* 5 */  2340,
  /* 6 */  2348,
  /* 7 */  2396,
  /* 8 */  2468,
  /* 9 */  2503,
  /* 10 */  2507,
  /* 11 */  2511,
  /* 12 */  2515,
  /* 13 */  2519,
  /* 14 */  2523,
  /* 15 */  2527,
  /* 16 */  2531,
  /* 17 */  2535,
  /* 18 */  2539,
  /* 19 */  2543,
  /* 20 */  2547,
  /* 21 */  2558,
  /* 22 */  2562,
  /* 23 */  2566,
  /* 24 */  2570,
  /* 25 */  2574,
  /* 26 */  2578,
  /* 27 */  2582,
  /* 28 */  2586,
  /* 29 */  2590,
  /* 30 */  2594,
  /* 31 */  2598,
  /* 32 */  2602,
  /* 33 */  2613,
  /* 34 */  2622,
  /* 35 */  2631,
  /* 36 */  2651,
  /* 37 */  2660,
  /* 38 */  2668,
  /* 39 */  2676,
  /* 40 */  2690,
  /* 41 */  2700,
  /* 42 */  2712,
  /* 43 */  2724,
  /* 44 */  2734,
  /* 45 */  2744,
  /* 46 */  2754,
  /* 47 */  2766,
  /* 48 */  2778,
  /* 49 */  2788,
  /* 50 */  2807,
  /* 51 */  2817,
  /* 52 */  2827,
  /* 53 */  2837,
  /* 54 */  2847,
  /* 55 */  2857,
  /* 56 */  2867,
  /* 57 */  2877,
  /* 58 */  2887,
  /* 59 */  2897,
  /* 60 */  2916,
  /* 61 */  2926,
  /* 62 */  2936,
  /* 63 */  2946,
  /* 64 */  2956,
  /* 65 */  2966,
  /* 66 */  2976,
  /* 67 */  2986,
  /* 68 */  2996,
  /* 69 */  3006,
  /* 70 */  3016,
  /* 71 */  3026,
  /* 72 */  3038,
  /* 73 */  3048,
  /* 74 */  3058,
  /* 75 */  3068,
  /* 76 */  3078,
  /* 77 */  3088,
  /* 78 */  3098,
  /* 79 */  3108,
  /* 80 */  3118,
  /* 81 */  3128,
  /* 82 */  3138,
  /* 83 */  3148,
  /* 84 */  3166,
  /* 85 */  3176,
  /* 86 */  3186,
  /* 87 */  3196,
  /* 88 */  3206,
  /* 89 */  3216,
  /* 90 */  3226,
  /* 91 */  3236,
  /* 92 */  3246,
  /* 93 */  3256,
  /* 94 */  3266,
  /* 95 */  3276,
  /* 96 */  3288,
  /* 97 */  3298,
  /* 98 */  3308,
  /* 99 */  3318,
  /* 100 */  3328,
  /* 101 */  3338,
  /* 102 */  3348,
  /* 103 */  3358,
  /* 104 */  3368,
  /* 105 */  3378,
  /* 106 */  3388,
  /* 107 */  3398,
  /* 108 */  3424,
  /* 109 */  3434,
  /* 110 */  3444,
  /* 111 */  3454,
  /* 112 */  3461,
  /* 113 */  3469,
  /* 114 */  3480,
  /* 115 */  3490,
  /* 116 */  3500,
  /* 117 */  3510,
  /* 118 */  3517,
  /* 119 */  3525,
  /* 120 */  3536,
  /* 121 */  3546,
  /* 122 */  3556,
  /* 123 */  3566,
  /* 124 */  3573,
  /* 125 */  3581,
  /* 126 */  3592,
  /* 127 */  3602,
  /* 128 */  3612,
  /* 129 */  3622,
  /* 130 */  3629,
  /* 131 */  3637,
  /* 132 */  3650,
  /* 133 */  3660,
  /* 134 */  3670,
  /* 135 */  3680,
  /* 136 */  3690,
  /* 137 */  3700,
  /* 138 */  3710,
  /* 139 */  3720,
  /* 140 */  3730,
  /* 141 */  3740,
  /* 142 */  3750,
  /* 143 */  3760,
  /* 144 */  3770,
  /* 145 */  3780,
  /* 146 */  3790,
  /* 147 */  3800,
  /* 148 */  3816,
  /* 149 */  3825,
  /* 150 */  3834,
  /* 151 */  3843,
  /* 152 */  3852,
  /* 153 */  3861,
  /* 154 */  3872,
  /* 155 */  3881,
  /* 156 */  3890,
  /* 157 */  3899,
  /* 158 */  3908,
  /* 159 */  3917,
  /* 160 */  3935,
  /* 161 */  3944,
  /* 162 */  3953,
  /* 163 */  3962,
  /* 164 */  3971,
  /* 165 */  3980,
  /* 166 */  3991,
  /* 167 */  4000,
  /* 168 */  4009,
  /* 169 */  4018,
  /* 170 */  4027,
  /* 171 */  4036,
  /* 172 */  4057,
  /* 173 */  4073,
  /* 174 */  4098,
  /* 175 */  4107,
  /* 176 */  4116,
  /* 177 */  4125,
  /* 178 */  4138,
  /* 179 */  4152,
  /* 180 */  4166,
  /* 181 */  4180,
  /* 182 */  4194,
  /* 183 */  4208,
  /* 184 */  4222,
  /* 185 */  4236,
  /* 186 */  4250,
  /* 187 */  4264,
  /* 188 */  4278,
  /* 189 */  4292,
  /* 190 */  4308,
  /* 191 */  4322,
  /* 192 */  4336,
  /* 193 */  4350,
  /* 194 */  4364,
  /* 195 */  4378,
  /* 196 */  4392,
  /* 197 */  4406,
  /* 198 */  4420,
  /* 199 */  4434,
  /* 200 */  4448,
  /* 201 */  4462,
  /* 202 */  4478,
  /* 203 */  4492,
  /* 204 */  4506,
  /* 205 */  4520,
  /* 206 */  4534,
  /* 207 */  4548,
  /* 208 */  4562,
  /* 209 */  4576,
  /* 210 */  4590,
  /* 211 */  4604,
  /* 212 */  4618,
  /* 213 */  4632,
  /* 214 */  4648,
  /* 215 */  4662,
  /* 216 */  4676,
  /* 217 */  4690,
  /* 218 */  4704,
  /* 219 */  4718,
  /* 220 */  4732,
  /* 221 */  4746,
  /* 222 */  4760,
  /* 223 */  4774,
  /* 224 */  4788,
  /* 225 */  4802,
  /* 226 */  4824,
  /* 227 */  4833,
  /* 228 */  4842,
  /* 229 */  4851,
  /* 230 */  4861,
  /* 231 */  4870,
  /* 232 */  4879,
  /* 233 */  4888,
  /* 234 */  4898,
  /* 235 */  4911,
  /* 236 */  4926,
  /* 237 */  4941,
  /* 238 */  4956,
  /* 239 */  4971,
  /* 240 */  4993,
  /* 241 */  5003,
  /* 242 */  5013,
  /* 243 */  5023,
  /* 244 */  5033,
  /* 245 */  5043,
  /* 246 */  5053,
  /* 247 */  5063,
  /* 248 */  5081,
  /* 249 */  5092,
  /* 250 */  5108,
  /* 251 */  5124,
  /* 252 */  5135,
  /* 253 */  5146,
  /* 254 */  5158,
  /* 255 */  5170,
  /* 256 */  5181,
  /* 257 */  5191,
  /* 258 */  5201,
  /* 259 */  5211,
  /* 260 */  5221,
  /* 261 */  5231,
  /* 262 */  5241,
  /* 263 */  5251,
  /* 264 */  5261,
  /* 265 */  5267,
  /* 266 */  5273,
  /* 267 */  5280,
  /* 268 */  5287,
  /* 269 */  5293,
  /* 270 */  5305,
  /* 271 */  5314,
  /* 272 */  5323,
  /* 273 */  5333,
  /* 274 */  5342,
  /* 275 */  5351,
  /* 276 */  5360,
  /* 277 */  5370,
  /* 278 */  5381,
  /* 279 */  5389,
  /* 280 */  5397,
  /* 281 */  5405,
  /* 282 */  5413,
  /* 283 */  5421,
  /* 284 */  5430,
  /* 285 */  5439,
  /* 286 */  5448,
  /* 287 */  5455,
  /* 288 */  5462,
  /* 289 */  5469,
  /* 290 */  5476,
  /* 291 */  5483,
  /* 292 */  5495,
  /* 293 */  5503,
  /* 294 */  5511,
  /* 295 */  5519,
  /* 296 */  5525,
  /* 297 */  5551,
  /* 298 */  5562,
  /* 299 */  5614,
  /* 300 */  5625,
  /* 301 */  5677,
  /* 302 */  5741,
  /* 303 */  5805,
  /* 304 */  5855,
  /* 305 */  5917,
  /* 306 */  5943,
  /* 307 */  5977,
  /* 308 */  5985,
  /* 309 */  5995,
  /* 310 */  6004,
  /* 311 */  6015,
  /* 312 */  6023,
  /* 313 */  6032,
  /* 314 */  6042,
  /* 315 */  6054,
  /* 316 */  6070,
  /* 317 */  6083,
  /* 318 */  6099,
  /* 319 */  6130,
  /* 320 */  6186,
  /* 321 */  6222,
  /* 322 */  6236,
  /* 323 */  6250,
  /* 324 */  6264,
  /* 325 */  6278,
  /* 326 */  6311,
  /* 327 */  6327,
  /* 328 */  6338,
  /* 329 */  6348,
  /* 330 */  6358,
  /* 331 */  6374,
  /* 332 */  6386,
  /* 333 */  6398,
  /* 334 */  6410,
  /* 335 */  6422,
  /* 336 */  6434,
  /* 337 */  6446,
  /* 338 */  6458,
  /* 339 */  6468,
  /* 340 */  6487,
  /* 341 */  6493,
  /* 342 */  6508,
  /* 343 */  6519,
  /* 344 */  6530,
  /* 345 */  6542,
  /* 346 */  6553,
  /* 347 */  6576,
  /* 348 */  6596,
  /* 349 */  6619,
  /* 350 */  6639,
  /* 351 */  6648,
  /* 352 */  6657,
  /* 353 */  6666,
  /* 354 */  6675,
  /* 355 */  6687,
  /* 356 */  6701,
  /* 357 */  6718,
  /* 358 */  6735,
  /* 359 */  6752,
  /* 360 */  6770,
  /* 361 */  6778,
  /* 362 */  6786,
  /* 363 */  6794,
  /* 364 */  6802,
  /* 365 */  6810,
  /* 366 */  6818,
  /* 367 */  6826,
  /* 368 */  6834,
  /* 369 */  6842,
  /* 370 */  6850,
  /* 371 */  6860,
  /* 372 */  6868,
  /* 373 */  6876,
  /* 374 */  6884,
  /* 375 */  6892,
  /* 376 */  6900,
  /* 377 */  6908,
  /* 378 */  6916,
  /* 379 */  6924,
  /* 380 */  6932,
  /* 381 */  6940,
  /* 382 */  6957,
  /* 383 */  6967,
  /* 384 */  6975,
  /* 385 */  6983,
  /* 386 */  6991,
  /* 387 */  6999,
  /* 388 */  7009,
  /* 389 */  7017,
  /* 390 */  7035,
  /* 391 */  7047,
  /* 392 */  7057,
  /* 393 */  7065,
  /* 394 */  7075,
  /* 395 */  7084,
  /* 396 */  7095,
  /* 397 */  7113,
  /* 398 */  7140,
  /* 399 */  7151,
  /* 400 */  7162,
  /* 401 */  7173,
  /* 402 */  7184,
  /* 403 */  7195,
  /* 404 */  7206,
  /* 405 */  7217,
  /* 406 */  7229,
  /* 407 */  7240,
  /* 408 */  7251,
  /* 409 */  7262,
  /* 410 */  7273,
  /* 411 */  7284,
  /* 412 */  7313,
  /* 413 */  7342,
  /* 414 */  7371,
  /* 415 */  7400,
  /* 416 */  7423,
  /* 417 */  7437,
  /* 418 */  7451,
  /* 419 */  7465,
  /* 420 */  7479,
  /* 421 */  7493,
  /* 422 */  7515,
  /* 423 */  7529,
  /* 424 */  7545,
  /* 425 */  7559,
  /* 426 */  7573,
  /* 427 */  7587,
  /* 428 */  7601,
  /* 429 */  7615,
  /* 430 */  7631,
  /* 431 */  7639,
  /* 432 */  7649,
  /* 433 */  7655,
  /* 434 */  7663,
  /* 435 */  7672,
  /* 436 */  7681,
  /* 437 */  7690,
  /* 438 */  7699,
  /* 439 */  7708,
  /* 440 */  7717,
  /* 441 */  7729,
  /* 442 */  7741,
  /* 443 */  7753,
  /* 444 */  7765,
  /* 445 */  7777,
  /* 446 */  7791,
  /* 447 */  7798,
  /* 448 */  7805,
  /* 449 */  7812,
  /* 450 */  7819,
  /* 451 */  7826,
  /* 452 */  7833,
  /* 453 */  7843,
  /* 454 */  7853,
  /* 455 */  7863,
  /* 456 */  7873,
  /* 457 */  7883,
  /* 458 */  7895,
  /* 459 */  7902,
  /* 460 */  7909,
  /* 461 */  7916,
  /* 462 */  7923,
  /* 463 */  7930,
  /* 464 */  7937,
  /* 465 */  7944,
  /* 466 */  7951,
  /* 467 */  7958,
  /* 468 */  7965,
  /* 469 */  7972,
  /* 470 */  7979,
  /* 471 */  7987,
  /* 472 */  7995,
  /* 473 */  8003,
  /* 474 */  8011,
  /* 475 */  8019,
  /* 476 */  8028,
  /* 477 */  8036,
  /* 478 */  8044,
  /* 479 */  8052,
  /* 480 */  8060,
  /* 481 */  8068,
  /* 482 */  8079,
  /* 483 */  8085,
  /* 484 */  8091,
  /* 485 */  8097,
  /* 486 */  8103,
  /* 487 */  8109,
  /* 488 */  8115,
  /* 489 */  8121,
  /* 490 */  8127,
  /* 491 */  8133,
  /* 492 */  8139,
  /* 493 */  8145,
  /* 494 */  8151,
  /* 495 */  8157,
  /* 496 */  8163,
  /* 497 */  8169,
  /* 498 */  8175,
  /* 499 */  8181,
  /* 500 */  8187,
  /* 501 */  8193,
  /* 502 */  8199,
  /* 503 */  8205,
  /* 504 */  8211,
  /* 505 */  8217,
  /* 506 */  8230,
  /* 507 */  8237,
  /* 508 */  8246,
  /* 509 */  8252,
  /* 510 */  8265,
  /* 511 */  8271,
  /* 512 */  8284,
  /* 513 */  8293,
  /* 514 */  8302,
  /* 515 */  8331,
  /* 516 */  8335,
  /* 517 */  8339,
  /* 518 */  8347,
  /* 519 */  8363,
  /* 520 */  8376,
  /* 521 */  8388,
  /* 522 */  8403,
  /* 523 */  8419,
  /* 524 */  8426,
  /* 525 */  8433,
  /* 526 */  8450,
  /* 527 */  8456,
  /* 528 */  8462,
  /* 529 */  8468,
  /* 530 */  8474,
  /* 531 */  8480,
  /* 532 */  8486,
  /* 533 */  8492,
  /* 534 */  8505,
  /* 535 */  8509,
  /* 536 */  8514,
  /* 537 */  8518,
  /* 538 */  8528,
  /* 539 */  8538,
  /* 540 */  8543,
  /* 541 */  8547,
  /* 542 */  8557,
  /* 543 */  8567,
  /* 544 */  8572,
  /* 545 */  8586,
  /* 546 */  8592,
  /* 547 */  8604,
  /* 548 */  8618,
  /* 549 */  8627,
  /* 550 */  8633,
  /* 551 */  8645,
  /* 552 */  8658,
  /* 553 */  8666,
  /* 554 */  8672,
  /* 555 */  8684,
  /* 556 */  8698,
  /* 557 */  8713,
  /* 558 */  8721,
  /* 559 */  8728,
  /* 560 */  8734,
  /* 561 */  8746,
  /* 562 */  8760,
  /* 563 */  8769,
  /* 564 */  8775,
  /* 565 */  8781,
  /* 566 */  8791,
  /* 567 */  8805,
  /* 568 */  8848,
  /* 569 */  8854,
  /* 570 */  8860,
  /* 571 */  8870,
  /* 572 */  8884,
  /* 573 */  8897,
  /* 574 */  8903,
  /* 575 */  8909,
  /* 576 */  8936,
  /* 577 */  8942,
  /* 578 */  8948,
  /* 579 */  8953,
  /* 580 */  8959,
  /* 581 */  8965,
  /* 582 */  8969,
  /* 583 */  9011,
  /* 584 */  9017,
  /* 585 */  9023,
  /* 586 */  9033,
  /* 587 */  9047,
  /* 588 */  9056,
  /* 589 */  9062,
  /* 590 */  9068,
  /* 591 */  9078,
  /* 592 */  9092,
  /* 593 */  9169,
  /* 594 */  9175,
  /* 595 */  9181,
  /* 596 */  9191,
  /* 597 */  9205,
  /* 598 */  9214,
  /* 599 */  9220,
  /* 600 */  9226,
  /* 601 */  9236,
  /* 602 */  9250,
  /* 603 */  9310,
  /* 604 */  9316,
  /* 605 */  9322,
  /* 606 */  9332,
  /* 607 */  9346,
  /* 608 */  9363,
  /* 609 */  9372,
  /* 610 */  9381,
  /* 611 */  9390,
  /* 612 */  9399,
  /* 613 */  9416,
  /* 614 */  9430,
  /* 615 */  9444,
  /* 616 */  9458,
  /* 617 */  9472,
  /* 618 */  9480,
  /* 619 */  9495,
  /* 620 */  9503,
  /* 621 */  9511,
  /* 622 */  9519,
  /* 623 */  9527,
  /* 624 */  9535,
  /* 625 */  9556,
  /* 626 */  9567,
  /* 627 */  9583,
  /* 628 */  9612,
  /* 629 */  9632,
  /* 630 */  9652,
  /* 631 */  9672,
  /* 632 */  9696,
  /* 633 */  9719,
  /* 634 */  9748,
  /* 635 */  9777,
  /* 636 */  9806,
  /* 637 */  9835,
  /* 638 */  9867,
  /* 639 */  9883,
  /* 640 */  9899,
  /* 641 */  9915,
  /* 642 */  9931,
  /* 643 */  9943,
  /* 644 */  9953,
  /* 645 */  9963,
  /* 646 */  9973,
  /* 647 */  9983,
  /* 648 */  10001,
  /* 649 */  10014,
  /* 650 */  10027,
  /* 651 */  10040,
  /* 652 */  10053,
  /* 653 */  10062,
  /* 654 */  10069,
  /* 655 */  10076,
  /* 656 */  10083,
  /* 657 */  10090,
  /* 658 */  10105,
  /* 659 */  10121,
  /* 660 */  10137,
  /* 661 */  10153,
  /* 662 */  10169,
  /* 663 */  10181,
  /* 664 */  10191,
  /* 665 */  10201,
  /* 666 */  10211,
  /* 667 */  10221,
  /* 668 */  10231,
  /* 669 */  10244,
  /* 670 */  10257,
  /* 671 */  10270,
  /* 672 */  10283,
  /* 673 */  10296,
  /* 674 */  10308,
  /* 675 */  10320,
  /* 676 */  10332,
  /* 677 */  10344,
  /* 678 */  10356,
  /* 679 */  10369,
  /* 680 */  10382,
  /* 681 */  10395,
  /* 682 */  10408,
  /* 683 */  10421,
  /* 684 */  10433,
  /* 685 */  10445,
  /* 686 */  10457,
  /* 687 */  10469,
  /* 688 */  10487,
  /* 689 */  10498,
  /* 690 */  10509,
  /* 691 */  10520,
  /* 692 */  10531,
  /* 693 */  10542,
  /* 694 */  10553,
  /* 695 */  10564,
  /* 696 */  10575,
  /* 697 */  10586,
  /* 698 */  10597,
  /* 699 */  10608,
  /* 700 */  10620,
  /* 701 */  10632,
  /* 702 */  10640,
  /* 703 */  10648,
  /* 704 */  10656,
  /* 705 */  10664,
};
ISEL::Rule ISEL::rule(ISEL::State *state, int goalnt) {
  ISEL_assert(goalnt >= 1 && goalnt <= 36,
        PANIC("Bad goal nonterminal %d in ISEL::rule\n", goalnt));
  if (!state)
    return 0;
  switch (goalnt) {
  case stmt_NT:
    if(state->has_match_for(stmt_NT))
      return state->matches[stmt_NT].rule_num;
    else
      return -1;
  case expr_NT:
    if(state->has_match_for(expr_NT))
      return state->matches[expr_NT].rule_num;
    else
      return -1;
  case areg_NT:
    if(state->has_match_for(areg_NT))
      return state->matches[areg_NT].rule_num;
    else
      return -1;
  case breg_NT:
    if(state->has_match_for(breg_NT))
      return state->matches[breg_NT].rule_num;
    else
      return -1;
  case bareg_NT:
    if(state->has_match_for(bareg_NT))
      return state->matches[bareg_NT].rule_num;
    else
      return -1;
  case b1reg_NT:
    if(state->has_match_for(b1reg_NT))
      return state->matches[b1reg_NT].rule_num;
    else
      return -1;
  case freg_NT:
    if(state->has_match_for(freg_NT))
      return state->matches[freg_NT].rule_num;
    else
      return -1;
  case tie_reg_NT:
    if(state->has_match_for(tie_reg_NT))
      return state->matches[tie_reg_NT].rule_num;
    else
      return -1;
  case tie_cvt_reg_NT:
    if(state->has_match_for(tie_cvt_reg_NT))
      return state->matches[tie_cvt_reg_NT].rule_num;
    else
      return -1;
  case ll_cvt_areg_NT:
    if(state->has_match_for(ll_cvt_areg_NT))
      return state->matches[ll_cvt_areg_NT].rule_num;
    else
      return -1;
  case acc_reg_NT:
    if(state->has_match_for(acc_reg_NT))
      return state->matches[acc_reg_NT].rule_num;
    else
      return -1;
  case tie_imm_NT:
    if(state->has_match_for(tie_imm_NT))
      return state->matches[tie_imm_NT].rule_num;
    else
      return -1;
  case wsar_NT:
    if(state->has_match_for(wsar_NT))
      return state->matches[wsar_NT].rule_num;
    else
      return -1;
  case sar_left_NT:
    if(state->has_match_for(sar_left_NT))
      return state->matches[sar_left_NT].rule_num;
    else
      return -1;
  case sar_right_NT:
    if(state->has_match_for(sar_right_NT))
      return state->matches[sar_right_NT].rule_num;
    else
      return -1;
  case areg_or_simm12_NT:
    if(state->has_match_for(areg_or_simm12_NT))
      return state->matches[areg_or_simm12_NT].rule_num;
    else
      return -1;
  case areg_or_simm8_NT:
    if(state->has_match_for(areg_or_simm8_NT))
      return state->matches[areg_or_simm8_NT].rule_num;
    else
      return -1;
  case areg_or_b4const_NT:
    if(state->has_match_for(areg_or_b4const_NT))
      return state->matches[areg_or_b4const_NT].rule_num;
    else
      return -1;
  case areg_or_b4constu_NT:
    if(state->has_match_for(areg_or_b4constu_NT))
      return state->matches[areg_or_b4constu_NT].rule_num;
    else
      return -1;
  case extui_mask_NT:
    if(state->has_match_for(extui_mask_NT))
      return state->matches[extui_mask_NT].rule_num;
    else
      return -1;
  case bbci_bbsi_imm_NT:
    if(state->has_match_for(bbci_bbsi_imm_NT))
      return state->matches[bbci_bbsi_imm_NT].rule_num;
    else
      return -1;
  case logical_and_immed_NT:
    if(state->has_match_for(logical_and_immed_NT))
      return state->matches[logical_and_immed_NT].rule_num;
    else
      return -1;
  case clamps_const_NT:
    if(state->has_match_for(clamps_const_NT))
      return state->matches[clamps_const_NT].rule_num;
    else
      return -1;
  case simm8x256_NT:
    if(state->has_match_for(simm8x256_NT))
      return state->matches[simm8x256_NT].rule_num;
    else
      return -1;
  case simm8_NT:
    if(state->has_match_for(simm8_NT))
      return state->matches[simm8_NT].rule_num;
    else
      return -1;
  case simm12_NT:
    if(state->has_match_for(simm12_NT))
      return state->matches[simm12_NT].rule_num;
    else
      return -1;
  case simm32_NT:
    if(state->has_match_for(simm32_NT))
      return state->matches[simm32_NT].rule_num;
    else
      return -1;
  case uimm4_NT:
    if(state->has_match_for(uimm4_NT))
      return state->matches[uimm4_NT].rule_num;
    else
      return -1;
  case uimm5_NT:
    if(state->has_match_for(uimm5_NT))
      return state->matches[uimm5_NT].rule_num;
    else
      return -1;
  case b4constu_NT:
    if(state->has_match_for(b4constu_NT))
      return state->matches[b4constu_NT].rule_num;
    else
      return -1;
  case b4const_NT:
    if(state->has_match_for(b4const_NT))
      return state->matches[b4const_NT].rule_num;
    else
      return -1;
  case msalp32_NT:
    if(state->has_match_for(msalp32_NT))
      return state->matches[msalp32_NT].rule_num;
    else
      return -1;
  case zero_NT:
    if(state->has_match_for(zero_NT))
      return state->matches[zero_NT].rule_num;
    else
      return -1;
  case one_NT:
    if(state->has_match_for(one_NT))
      return state->matches[one_NT].rule_num;
    else
      return -1;
  case thirtytwo_NT:
    if(state->has_match_for(thirtytwo_NT))
      return state->matches[thirtytwo_NT].rule_num;
    else
      return -1;
  case float_const_NT:
    if(state->has_match_for(float_const_NT))
      return state->matches[float_const_NT].rule_num;
    else
      return -1;
  default:
    /*CONSTCOND*/
    ISEL_assert(0, PANIC("Bad goal nonterminal %d in ISEL::rule\n", goalnt));
  }
  return 0;
}

void ISEL::State::set_match( Nonterm nt,COST &c,Rule r)
{  has_match[nt>>5] |= (1<<(nt&0x1f));
  matches[nt].cost = c;
  matches[nt].rule_num = r;
}
bool ISEL::State::has_match_for( Nonterm nt)
{  return (has_match[nt>>5] & (1<<(nt&0x1f)))!=0;
}
ISEL::Nonterm ISEL::add_nonterm(const char *name)
{
  int i;
  // Check that it doesn't already exist
  assert(name!=0);
  for(i=1;i < max_nt;i++) {
    if(strcmp(name,ntname[i])==0)
      throw Exception("Attempt to add existing nonterm",0);
  }
  if( max_nt < ISEL_MAX_NT)
    ntname[max_nt++] = name;
  else
    throw Exception("add_nonterm overflow",0);
  return max_nt-1;
}

ISEL::Rule_info *ISEL::ntchains[ISEL_MAX_NT];
ISEL::Rule_info *ISEL::dynamic_rules;

ISEL::Rule_info *ISEL::alloc_rule()
{
  if(num_dynamic_rules >= max_dynamic_rules ){
    if(max_dynamic_rules==0) {
      max_dynamic_rules = ISEL_INITIAL_MAX_DYNAMIC_RULES;
      dynamic_rules = (Rule_info*)ALLOC(max_dynamic_rules*sizeof(Rule_info));
    } else {
      int new_size = 2*max_dynamic_rules;
      dynamic_rules = (Rule_info*)REALLOC(dynamic_rules,max_dynamic_rules*sizeof(Rule_info),new_size*sizeof(Rule_info));
      max_dynamic_rules = new_size;
    }
  }
  return &dynamic_rules[num_dynamic_rules++];
}

ISEL::State *ISEL_label_add_rule_zero_kid(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  return s;
}

ISEL::State *ISEL_label_add_rule_one_kid(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
return s;
}

ISEL::State *ISEL_label_add_rule_two_kid(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
return s;
}

ISEL::State *ISEL_label_add_rule_three_kid(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
return s;
}

ISEL::Rule ISEL::add_rule( int opc, ISEL::Nonterm nt, int arity, ISEL::Labeller_func f)
{
  Op_info *oi = find_op_info( opc );
  Rule_info *ri;
  if (!oi) {
    oi = (Op_info*)malloc(sizeof(Op_info));
    oi->op = opc;
    if (arity==0) {
      oi->labeller = ISEL_label_add_rule_zero_kid;
    } else if (arity==1) {
      oi->labeller = ISEL_label_add_rule_one_kid;
    } else if (arity==2) {
      oi->labeller = ISEL_label_add_rule_two_kid;
    } else if (arity==3) {
      oi->labeller = ISEL_label_add_rule_three_kid;
    } else {
      throw Exception("Bad arity", 0);
    }
    oi->dynamic_rules = NULL;
    add_op_info(opc, oi);
  }
  ri = alloc_rule();
  ri->op = opc;
  ri->lhs = nt;
  ri->rhs = 0;
  ri->f = f;
  ri->action.none = 0;
  ri->next = oi->dynamic_rules;
  oi->dynamic_rules = ri;
  return rule_no(ri);
}

ISEL::Rule ISEL::add_chain_rule( ISEL::Nonterm lhs, ISEL::Nonterm rhs, ISEL::Labeller_func f)
{
  Rule_info *ri;
  assert(rhs <= ISEL_MAX_NT);
  assert(lhs <= ISEL_MAX_NT);
  ri = alloc_rule();
  ri->lhs = lhs;
  ri->rhs = rhs;
  ri->f = f;
  ri->action.none = 0;
  ri->next = ntchains[rhs];
  ntchains[rhs] = ri;
  return rule_no(ri);
}

ISEL::Nonterm ISEL::find_nonterm(const char *name)
{
  int i;
  // Check that it doesn't already exist
  assert(name!=0);
  for(i=1;i < max_nt;i++) {
    if(strcmp(name,ntname[i])==0)
      return i;
  }
    throw Exception("find_nonterm can't find nonterminal",0);
  return 0;
}

ISEL::Rule ISEL::rule_no(ISEL::Rule_info *ri)
{
  Rule r = ri-dynamic_rules;
  assert(0 <= r && r < num_dynamic_rules);
  return r+ISEL_NUM_PRECOMPILED_RULES;
}

bool ISEL::match(NODEPTR u, ISEL::Nonterm nt, COST &c)
{
  bool matches;
  State *s;
  assert( 0 < nt && nt < max_nt );
  s = ISEL::label1(u);
  matches = s->has_match_for(nt);
  if(matches) c = s->matches[nt].cost;
  return matches;
}

int ISEL_cost_code(COST *_c, int _ern,ISEL::State *_s)
{
  NODEPTR *_children;
  switch(_ern){
  default:
    DEFAULT_COST;
  case 0:
{
/* line 2293 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::expr_NT].cost.cost; 
}
  break;
  case 1:
{
/* line 2297 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::expr_NT].cost.cost; 
}
  break;
  case 2:
{
/* line 2308 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_Asm(_s->node, &((*_c))); 
}
  break;
  case 3:
{
/* line 2319 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + 1; 
}
  break;
  case 4:
{
/* line 2325 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 7:
{
/* line 2363 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 

  COST intr_cost, c;
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(_s->node));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count(_s->node);
  intr_cost.cost=tie_macro->num_instructions();
  FmtAssert(kid_count==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));

#if 0
printf("isel tie intr call label: %s\n", tie_macro->name());
#endif
  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid(_s->node,i));

    if (tie_macro->proto_is_immed(i) &&
	ISEL::match(kid, ISEL::find_nonterm("tie_imm"), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else if (ISEL::match(kid, ISEL::find_nonterm(
		find_nonterm_name(tie_macro->proto_mtype_id(tie_info,i))), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else {
      (*_c) = COST_INFINITY;
      return false;
    }
  }

  (*_c) = intr_cost;
  return true;

}
  break;
  case 8:
{
/* line 2426 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 

  COST intr_cost, c;
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(_s->node));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);

  if (tie_macro->is_conditional_branch()==FALSE) {
    (*_c) = COST_INFINITY;
    return false;
  }

  UINT kid_count = WN_kid_count(_s->node);
  intr_cost.cost=tie_macro->num_instructions();
  FmtAssert(kid_count==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));

  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid(_s->node,i));

    if (tie_macro->proto_is_label(i)) {
      if (WN_opcode(kid)!=OPC_I4INTCONST) {
	(*_c) = COST_INFINITY;
	return false;
      }
    } else if (tie_macro->proto_is_immed(i) &&
	       ISEL::match(kid, ISEL::find_nonterm("tie_imm"), c)) {
      intr_cost.cost = intr_cost.cost + c.cost;
    } else if (ISEL::match(kid, ISEL::find_nonterm(
		find_nonterm_name(tie_macro->proto_mtype_id(tie_info,i))), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else {
      (*_c) = COST_INFINITY;
      return false;
    }

  }

  (*_c) = intr_cost;
  return true;

}
  break;
  case 9:
{
/* line 2502 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 10:
{
/* line 2506 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 11:
{
/* line 2510 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 12:
{
/* line 2514 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 13:
{
/* line 2518 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 14:
{
/* line 2522 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 15:
{
/* line 2526 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 16:
{
/* line 2530 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 17:
{
/* line 2534 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 18:
{
/* line 2538 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 19:
{
/* line 2542 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 20:
{
/* line 2546 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 21:
{
/* line 2557 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 22:
{
/* line 2561 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 23:
{
/* line 2565 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 24:
{
/* line 2569 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 25:
{
/* line 2573 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 26:
{
/* line 2577 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 27:
{
/* line 2581 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 28:
{
/* line 2585 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 29:
{
/* line 2589 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 30:
{
/* line 2593 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 31:
{
/* line 2597 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 32:
{
/* line 2601 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Label_ICall(_s->node, &((*_c))); 
}
  break;
  case 33:
{
/* line 2612 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 34:
{
/* line 2621 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 35:
{
/* line 2630 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 36:
{
/* line 2650 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 37:
{
/* line 2659 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::one_NT].cost.cost + 1; 
}
  break;
  case 38:
{
/* line 2667 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 39:
{
/* line 2675 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 40:
{
/* line 2689 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 41:
{
/* line 2699 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 42:
{
/* line 2711 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 43:
{
/* line 2723 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 44:
{
/* line 2733 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 45:
{
/* line 2743 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 46:
{
/* line 2753 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 47:
{
/* line 2765 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 48:
{
/* line 2777 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 49:
{
/* line 2787 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 50:
{
/* line 2806 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 51:
{
/* line 2816 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 52:
{
/* line 2826 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 53:
{
/* line 2836 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 54:
{
/* line 2846 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 55:
{
/* line 2856 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 56:
{
/* line 2866 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 57:
{
/* line 2876 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 58:
{
/* line 2886 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 59:
{
/* line 2896 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 60:
{
/* line 2915 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 61:
{
/* line 2925 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 62:
{
/* line 2935 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 63:
{
/* line 2945 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 64:
{
/* line 2955 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 65:
{
/* line 2965 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 66:
{
/* line 2975 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 67:
{
/* line 2985 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 68:
{
/* line 2995 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 69:
{
/* line 3005 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 70:
{
/* line 3015 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 71:
{
/* line 3025 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 72:
{
/* line 3037 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 73:
{
/* line 3047 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 74:
{
/* line 3057 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 75:
{
/* line 3067 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 76:
{
/* line 3077 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 77:
{
/* line 3087 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 78:
{
/* line 3097 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 79:
{
/* line 3107 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 80:
{
/* line 3117 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 81:
{
/* line 3127 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 82:
{
/* line 3137 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 83:
{
/* line 3147 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4constu_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4constu_NT].cost.cost + 1; 
}
  break;
  case 84:
{
/* line 3165 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 85:
{
/* line 3175 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 86:
{
/* line 3185 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 87:
{
/* line 3195 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 88:
{
/* line 3205 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 89:
{
/* line 3215 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 90:
{
/* line 3225 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 91:
{
/* line 3235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 92:
{
/* line 3245 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 93:
{
/* line 3255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 94:
{
/* line 3265 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 95:
{
/* line 3275 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 96:
{
/* line 3287 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 97:
{
/* line 3297 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 98:
{
/* line 3307 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 99:
{
/* line 3317 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 100:
{
/* line 3327 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 101:
{
/* line 3337 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 102:
{
/* line 3347 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 103:
{
/* line 3357 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 104:
{
/* line 3367 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 105:
{
/* line 3377 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 106:
{
/* line 3387 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 107:
{
/* line 3397 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_b4const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_b4const_NT].cost.cost + 1; 
}
  break;
  case 108:
{
/* line 3420 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 109:
{
/* line 3430 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 110:
{
/* line 3440 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 111:
{
/* line 3450 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 112:
{
/* line 3460 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 113:
{
/* line 3468 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 114:
{
/* line 3476 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 115:
{
/* line 3486 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 116:
{
/* line 3496 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 117:
{
/* line 3506 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 118:
{
/* line 3516 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 119:
{
/* line 3524 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 120:
{
/* line 3532 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 121:
{
/* line 3542 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 122:
{
/* line 3552 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 123:
{
/* line 3562 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 124:
{
/* line 3572 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 125:
{
/* line 3580 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 126:
{
/* line 3588 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 127:
{
/* line 3598 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 128:
{
/* line 3608 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 129:
{
/* line 3618 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 130:
{
/* line 3628 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 131:
{
/* line 3636 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 132:
{
/* line 3646 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 133:
{
/* line 3656 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 134:
{
/* line 3666 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 135:
{
/* line 3676 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 136:
{
/* line 3686 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 137:
{
/* line 3696 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 138:
{
/* line 3706 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 139:
{
/* line 3716 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 140:
{
/* line 3726 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 141:
{
/* line 3736 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 142:
{
/* line 3746 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 143:
{
/* line 3756 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 144:
{
/* line 3766 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 145:
{
/* line 3776 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[0]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 146:
{
/* line 3786 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::logical_and_immed_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[1]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 147:
{
/* line 3796 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[1]->kids[0]->matches[ISEL::logical_and_immed_NT].cost.cost + _s->kids[0]->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 2;
  COST c;
  if (ISEL::match(_s->kids[0]->kids[1]->kids[0]->node, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { (*_c).cost--; }

}
  break;
  case 148:
{
/* line 3815 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 149:
{
/* line 3824 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 150:
{
/* line 3833 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 151:
{
/* line 3842 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 152:
{
/* line 3851 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 153:
{
/* line 3860 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 154:
{
/* line 3871 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 155:
{
/* line 3880 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 156:
{
/* line 3889 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 157:
{
/* line 3898 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 158:
{
/* line 3907 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 159:
{
/* line 3916 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 160:
{
/* line 3934 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 161:
{
/* line 3943 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 162:
{
/* line 3952 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 163:
{
/* line 3961 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 164:
{
/* line 3970 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 165:
{
/* line 3979 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 166:
{
/* line 3990 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 167:
{
/* line 3999 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 2; 
}
  break;
  case 168:
{
/* line 4008 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 169:
{
/* line 4017 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 170:
{
/* line 4026 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 171:
{
/* line 4035 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 3; 
}
  break;
  case 172:
{
/* line 4056 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::bbci_bbsi_imm_NT].cost.cost + 1; 
}
  break;
  case 173:
{
/* line 4072 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::bbci_bbsi_imm_NT].cost.cost + 1; 
}
  break;
  case 174:
{
/* line 4097 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 175:
{
/* line 4106 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 176:
{
/* line 4115 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 177:
{
/* line 4124 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 178:
{
/* line 4136 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 179:
{
/* line 4150 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 180:
{
/* line 4164 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 181:
{
/* line 4178 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 182:
{
/* line 4192 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 183:
{
/* line 4206 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 184:
{
/* line 4220 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 185:
{
/* line 4234 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 186:
{
/* line 4248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 187:
{
/* line 4262 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 188:
{
/* line 4276 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 189:
{
/* line 4290 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 190:
{
/* line 4306 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 191:
{
/* line 4320 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 192:
{
/* line 4334 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 193:
{
/* line 4348 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 194:
{
/* line 4362 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 195:
{
/* line 4376 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 196:
{
/* line 4390 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 197:
{
/* line 4404 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 198:
{
/* line 4418 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 199:
{
/* line 4432 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 200:
{
/* line 4446 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 201:
{
/* line 4460 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 202:
{
/* line 4476 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 203:
{
/* line 4490 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 204:
{
/* line 4504 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 205:
{
/* line 4518 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 206:
{
/* line 4532 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 207:
{
/* line 4546 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 208:
{
/* line 4560 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 209:
{
/* line 4574 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 210:
{
/* line 4588 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 211:
{
/* line 4602 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 212:
{
/* line 4616 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 213:
{
/* line 4630 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 214:
{
/* line 4646 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 215:
{
/* line 4660 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 216:
{
/* line 4674 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 217:
{
/* line 4688 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 218:
{
/* line 4702 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 219:
{
/* line 4716 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 220:
{
/* line 4730 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 221:
{
/* line 4744 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 222:
{
/* line 4758 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 223:
{
/* line 4772 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 224:
{
/* line 4786 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 225:
{
/* line 4800 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_or_simm8_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost +
    _s->kids[1]->matches[ISEL::areg_or_simm12_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_or_simm12_NT].cost.cost + 1; 
}
  break;
  case 226:
{
/* line 4823 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 227:
{
/* line 4832 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 228:
{
/* line 4841 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 229:
{
/* line 4850 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 230:
{
/* line 4860 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 231:
{
/* line 4869 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 232:
{
/* line 4878 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[2]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 233:
{
/* line 4887 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 234:
{
/* line 4897 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 235:
{
/* line 4910 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::breg_NT].cost.cost + _s->kids[2]->matches[ISEL::breg_NT].cost.cost + 3; 
}
  break;
  case 236:
{
/* line 4925 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::breg_NT].cost.cost + _s->kids[2]->matches[ISEL::breg_NT].cost.cost + 3; 
}
  break;
  case 237:
{
/* line 4940 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::breg_NT].cost.cost + _s->kids[2]->matches[ISEL::breg_NT].cost.cost + 3; 
}
  break;
  case 238:
{
/* line 4955 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::breg_NT].cost.cost + _s->kids[2]->matches[ISEL::breg_NT].cost.cost + 3; 
}
  break;
  case 239:
{
/* line 4970 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::breg_NT].cost.cost + _s->kids[2]->matches[ISEL::breg_NT].cost.cost + 3; 
}
  break;
  case 240:
{
/* line 4992 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 241:
{
/* line 5002 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 242:
{
/* line 5012 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 243:
{
/* line 5022 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 244:
{
/* line 5032 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 245:
{
/* line 5042 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 246:
{
/* line 5052 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 247:
{
/* line 5062 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 248:
{
/* line 5080 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 249:
{
/* line 5091 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 250:
{
/* line 5107 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 251:
{
/* line 5123 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 252:
{
/* line 5134 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 253:
{
/* line 5145 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 254:
{
/* line 5157 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 255:
{
/* line 5169 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost; 
}
  break;
  case 256:
{
/* line 5180 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 257:
{
/* line 5190 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 258:
{
/* line 5200 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 259:
{
/* line 5210 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 260:
{
/* line 5220 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 261:
{
/* line 5230 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 262:
{
/* line 5240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 263:
{
/* line 5250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 264:
{
/* line 5260 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 265:
{
/* line 5266 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::tie_reg_NT].cost.cost; 
}
  break;
  case 266:
{
/* line 5272 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c) = COST_INFINITY; 
}
  break;
  case 267:
{
/* line 5279 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c) = COST_INFINITY; 
}
  break;
  case 268:
{
/* line 5286 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::breg_NT].cost.cost; 
}
  break;
  case 269:
{
/* line 5292 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::freg_NT].cost.cost; 
}
  break;
  case 270:
{
/* line 5304 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 271:
{
/* line 5313 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 272:
{
/* line 5322 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 273:
{
/* line 5332 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 274:
{
/* line 5341 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 275:
{
/* line 5350 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 276:
{
/* line 5359 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 277:
{
/* line 5369 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 278:
{
/* line 5380 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 279:
{
/* line 5388 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 280:
{
/* line 5396 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 281:
{
/* line 5404 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 282:
{
/* line 5412 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 283:
{
/* line 5420 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 284:
{
/* line 5429 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 285:
{
/* line 5438 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 286:
{
/* line 5447 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 287:
{
/* line 5454 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 288:
{
/* line 5461 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 289:
{
/* line 5468 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 290:
{
/* line 5475 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 291:
{
/* line 5482 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 292:
{
/* line 5494 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 293:
{
/* line 5502 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 294:
{
/* line 5510 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 295:
{
/* line 5518 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 296:
{
/* line 5524 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 297:
{
/* line 5550 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 298:
{
/* line 5561 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 299:
{
/* line 5613 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 300:
{
/* line 5624 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 301:
{
/* line 5676 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 302:
{
/* line 5740 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 303:
{
/* line 5804 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 304:
{
/* line 5854 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 305:
{
/* line 5916 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 306:
{
/* line 5942 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 307:
{
/* line 5976 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost + 1; 
}
  break;
  case 308:
{
/* line 5984 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::simm8_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 309:
{
/* line 5994 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::simm8x256_NT].cost.cost + 1; 
}
  break;
  case 310:
{
/* line 6003 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::simm8x256_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 311:
{
/* line 6014 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost + 1; 
}
  break;
  case 312:
{
/* line 6022 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::simm8_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 313:
{
/* line 6031 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::simm8x256_NT].cost.cost + 1; 
}
  break;
  case 314:
{
/* line 6041 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::simm8x256_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 315:
{
/* line 6053 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost + 1; 
}
  break;
  case 316:
{
/* line 6062 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  /* Check for corner case where max negative value fits, but positive
     doesn't. */
  if (!is_simm8x256_negated(_s->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::simm8x256_NT].cost.cost + 1;

}
  break;
  case 317:
{
/* line 6082 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_or_simm8_NT].cost.cost + 1; 
}
  break;
  case 318:
{
/* line 6091 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  /* Check for corner case where max negative value fits, but positive
     doesn't. */
  if (!is_simm8x256_negated(_s->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::simm8x256_NT].cost.cost + 1;

}
  break;
  case 319:
{
/* line 6111 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  if (xt_mul16 && WN_Mpy_16Bit(_s->node))
  {
    if (!MUL16_arg_cost(_s->node, _s->kids[0]->node, _s->kids[1]->node, &((*_c)), 1))
      NO_MATCH;
  }
  else if (xt_mul32)
  {
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit(_s->node))
  {
    int cost_val = WN_Mpy_16Bit_Signed(_s->node) ? 4 : 5;
    if (!MUL16_arg_cost(_s->node, _s->kids[0]->node, _s->kids[1]->node, &((*_c)), cost_val))
      NO_MATCH;
  }
  else
    NO_MATCH;

}
  break;
  case 320:
{
/* line 6167 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  if (xt_mul16 && WN_Mpy_16Bit(_s->node))
  {
    if (!MUL16_arg_cost(_s->node, _s->kids[0]->node, _s->kids[1]->node, &((*_c)), 1))
      NO_MATCH;
  }
  else if (xt_mul32)
  {
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit(_s->node))
  {
    int cost_val = WN_Mpy_16Bit_Signed(_s->node) ? 4 : 5;
    if (!MUL16_arg_cost(_s->node, _s->kids[0]->node, _s->kids[1]->node, &((*_c)), cost_val))
      NO_MATCH;
  }
  else
    NO_MATCH;

}
  break;
  case 321:
{
/* line 6221 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 322:
{
/* line 6235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 323:
{
/* line 6249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 324:
{
/* line 6263 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 325:
{
/* line 6277 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 326:
{
/* line 6310 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 327:
{
/* line 6326 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + ((xt_minmax) ? 1 : 2); 
}
  break;
  case 328:
{
/* line 6337 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + ((xt_minmax) ? 1 : 2); 
}
  break;
  case 329:
{
/* line 6347 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + ((xt_minmax) ? 1 : 2); 
}
  break;
  case 330:
{
/* line 6357 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + ((xt_minmax) ? 1 : 2); 
}
  break;
  case 331:
{
/* line 6369 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[0]->kids[1]->node, _s->kids[1]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + 1;

}
  break;
  case 332:
{
/* line 6381 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[1]->kids[1]->node, _s->kids[0]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + 1;

}
  break;
  case 333:
{
/* line 6393 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[0]->kids[0]->node, _s->kids[1]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + 1;

}
  break;
  case 334:
{
/* line 6405 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[1]->kids[0]->node, _s->kids[0]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 335:
{
/* line 6417 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[1]->node, _s->kids[0]->kids[1]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + 1;

}
  break;
  case 336:
{
/* line 6429 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[0]->node, _s->kids[1]->kids[1]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + 1;

}
  break;
  case 337:
{
/* line 6441 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[1]->node, _s->kids[0]->kids[0]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::clamps_const_NT].cost.cost + 1;

}
  break;
  case 338:
{
/* line 6453 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_clamps || !is_clamps_const_pair(_s->kids[0]->node, _s->kids[1]->kids[0]->node))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::clamps_const_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 339:
{
/* line 6467 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + xt_abs ? 1 : 2; 
}
  break;
  case 340:
{
/* line 6486 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 341:
{
/* line 6492 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 342:
{
/* line 6507 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 343:
{
/* line 6518 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 344:
{
/* line 6529 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 345:
{
/* line 6541 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 346:
{
/* line 6552 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 347:
{
/* line 6575 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 348:
{
/* line 6595 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 349:
{
/* line 6618 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + _s->kids[2]->matches[ISEL::freg_NT].cost.cost + 2; 
}
  break;
  case 350:
{
/* line 6638 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 351:
{
/* line 6647 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 352:
{
/* line 6656 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 353:
{
/* line 6665 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 354:
{
/* line 6674 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); 
}
  break;
  case 355:
{
/* line 6686 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); 
}
  break;
  case 356:
{
/* line 6700 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); 
}
  break;
  case 357:
{
/* line 6717 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); 
}
  break;
  case 358:
{
/* line 6734 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); 
}
  break;
  case 359:
{
/* line 6751 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); 
}
  break;
  case 360:
{
/* line 6769 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 361:
{
/* line 6777 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 362:
{
/* line 6785 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 363:
{
/* line 6793 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 364:
{
/* line 6801 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 365:
{
/* line 6809 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 366:
{
/* line 6817 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 367:
{
/* line 6825 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 368:
{
/* line 6833 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 369:
{
/* line 6841 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 1; 
}
  break;
  case 370:
{
/* line 6849 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 371:
{
/* line 6859 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 372:
{
/* line 6867 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 373:
{
/* line 6875 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 374:
{
/* line 6883 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 375:
{
/* line 6891 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 376:
{
/* line 6899 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 377:
{
/* line 6907 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 378:
{
/* line 6915 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 379:
{
/* line 6923 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 380:
{
/* line 6931 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 381:
{
/* line 6939 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::freg_NT].cost.cost + _s->kids[1]->matches[ISEL::freg_NT].cost.cost + 3; 
}
  break;
  case 382:
{
/* line 6956 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 383:
{
/* line 6966 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::extui_mask_NT].cost.cost + 1; 
}
  break;
  case 384:
{
/* line 6974 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::extui_mask_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 385:
{
/* line 6982 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 386:
{
/* line 6990 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::extui_mask_NT].cost.cost + 1; 
}
  break;
  case 387:
{
/* line 6998 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::extui_mask_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 388:
{
/* line 7008 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 389:
{
/* line 7016 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 390:
{
/* line 7030 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + 2; 
  if (!xt_addx) 
    NO_MATCH;

}
  break;
  case 391:
{
/* line 7042 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + 2; 
  if (!xt_addx) 
    NO_MATCH;

}
  break;
  case 392:
{
/* line 7056 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 393:
{
/* line 7064 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 394:
{
/* line 7074 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 395:
{
/* line 7083 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 396:
{
/* line 7094 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 397:
{
/* line 7112 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 398:
{
/* line 7139 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::msalp32_NT].cost.cost + 1; 
}
  break;
  case 399:
{
/* line 7150 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::msalp32_NT].cost.cost + 1; 
}
  break;
  case 400:
{
/* line 7161 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::uimm5_NT].cost.cost + 1; 
}
  break;
  case 401:
{
/* line 7172 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::uimm5_NT].cost.cost + 1; 
}
  break;
  case 402:
{
/* line 7183 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::uimm4_NT].cost.cost + 1; 
}
  break;
  case 403:
{
/* line 7194 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::uimm4_NT].cost.cost + 1; 
}
  break;
  case 404:
{
/* line 7205 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::uimm5_NT].cost.cost + 2; 
}
  break;
  case 405:
{
/* line 7216 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::uimm5_NT].cost.cost + 2; 
}
  break;
  case 406:
{
/* line 7228 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::sar_left_NT].cost.cost + 1; 
}
  break;
  case 407:
{
/* line 7239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::sar_left_NT].cost.cost + 1; 
}
  break;
  case 408:
{
/* line 7250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::sar_right_NT].cost.cost + 1; 
}
  break;
  case 409:
{
/* line 7261 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::sar_right_NT].cost.cost + 1; 
}
  break;
  case 410:
{
/* line 7272 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::sar_right_NT].cost.cost + 1; 
}
  break;
  case 411:
{
/* line 7283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::sar_right_NT].cost.cost + 1; 
}
  break;
  case 412:
{
/* line 7295 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  const OPERATOR opc4 = WN_operator(_s->kids[0]->kids[1]->node);
  const OPERATOR opc9 = WN_operator(_s->kids[1]->kids[1]->kids[1]->node);
  if (opc4 != OPR_INTCONST) {
    if (opc4 != OPR_LDID || ST_class(WN_st(_s->kids[0]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st(_s->kids[1]->kids[1]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv(_s->kids[0]->kids[1]->node, _s->kids[1]->kids[1]->kids[1]->node))
      NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::wsar_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 

}
  break;
  case 413:
{
/* line 7324 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  const OPERATOR opc4 = WN_operator(_s->kids[0]->kids[1]->node);
  const OPERATOR opc9 = WN_operator(_s->kids[1]->kids[1]->kids[1]->node);
  if (opc4 != OPR_INTCONST) {
    if (opc4 != OPR_LDID || ST_class(WN_st(_s->kids[0]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st(_s->kids[1]->kids[1]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv(_s->kids[0]->kids[1]->node, _s->kids[1]->kids[1]->kids[1]->node))
      NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::wsar_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 

}
  break;
  case 414:
{
/* line 7353 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  const OPERATOR opc6 = WN_operator(_s->kids[0]->kids[1]->kids[1]->node);
  const OPERATOR opc9 = WN_operator(_s->kids[1]->kids[1]->node);
  if (opc6 != OPR_INTCONST) {
    if (opc6 != OPR_LDID || ST_class(WN_st(_s->kids[0]->kids[1]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st(_s->kids[1]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv(_s->kids[0]->kids[1]->kids[1]->node, _s->kids[1]->kids[1]->node))
      NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::wsar_NT].cost.cost + 1; 

}
  break;
  case 415:
{
/* line 7382 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  const OPERATOR opc6 = WN_operator(_s->kids[0]->kids[1]->kids[1]->node);
  const OPERATOR opc9 = WN_operator(_s->kids[1]->kids[1]->node);
  if (opc6 != OPR_INTCONST) {
    if (opc6 != OPR_LDID || ST_class(WN_st(_s->kids[0]->kids[1]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st(_s->kids[1]->kids[1]->node)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv(_s->kids[0]->kids[1]->kids[1]->node, _s->kids[1]->kids[1]->node))
      NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::wsar_NT].cost.cost + 1; 

}
  break;
  case 416:
{
/* line 7417 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!allowed_shiftadd_immed(_s->kids[1]->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::msalp32_NT].cost.cost + 1;

}
  break;
  case 417:
{
/* line 7431 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!allowed_shiftadd_immed(_s->kids[0]->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::msalp32_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 418:
{
/* line 7445 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!allowed_shiftadd_immed(_s->kids[1]->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->kids[1]->matches[ISEL::msalp32_NT].cost.cost + 1;

}
  break;
  case 419:
{
/* line 7459 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!allowed_shiftadd_immed(_s->kids[0]->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::msalp32_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 420:
{
/* line 7473 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!allowed_shiftadd_immed(_s->kids[0]->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::msalp32_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 421:
{
/* line 7487 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!allowed_shiftadd_immed(_s->kids[0]->kids[1]->node))
    NO_MATCH;

  (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[0]->kids[1]->matches[ISEL::msalp32_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 422:
{
/* line 7510 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_mac16 || !WN_Mpy_16Bit(_s->node))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[0]->node, _s->kids[1]->node, &((*_c)), 1);

}
  break;
  case 423:
{
/* line 7524 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_mac16 || !WN_Mpy_16Bit(_s->node))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[0]->node, _s->kids[1]->node, &((*_c)), 1);

}
  break;
  case 424:
{
/* line 7538 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16 || !WN_Mpy_16Bit(_s->kids[1]->node))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[0]->node)) || MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[1]->node)))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, &((*_c)), _s->kids[0]->matches[ISEL::acc_reg_NT].cost.cost + 1);

}
  break;
  case 425:
{
/* line 7552 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16 || !WN_Mpy_16Bit(_s->kids[0]->node))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype(_s->kids[0]->kids[0]->node)) || MTYPE_is_unsigned(WN_rtype(_s->kids[0]->kids[1]->node)))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[0]->kids[0]->node, _s->kids[0]->kids[1]->node, &((*_c)), _s->kids[1]->matches[ISEL::acc_reg_NT].cost.cost + 1);

}
  break;
  case 426:
{
/* line 7566 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16 || !WN_Mpy_16Bit(_s->kids[1]->node))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[0]->node)) || MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[1]->node)))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, &((*_c)), _s->kids[0]->matches[ISEL::acc_reg_NT].cost.cost + 1);

}
  break;
  case 427:
{
/* line 7580 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16 || !WN_Mpy_16Bit(_s->kids[0]->node))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype(_s->kids[0]->kids[0]->node)) || MTYPE_is_unsigned(WN_rtype(_s->kids[0]->kids[1]->node)))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[0]->kids[0]->node, _s->kids[0]->kids[1]->node, &((*_c)), _s->kids[1]->matches[ISEL::acc_reg_NT].cost.cost + 1);

}
  break;
  case 428:
{
/* line 7594 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16 || !WN_Mpy_16Bit(_s->kids[1]->node))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[0]->node)) || MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[1]->node)))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, &((*_c)), _s->kids[0]->matches[ISEL::acc_reg_NT].cost.cost + 1);

}
  break;
  case 429:
{
/* line 7608 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16 || !WN_Mpy_16Bit(_s->kids[1]->node))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype(_s->kids[1]->node)) || MTYPE_is_unsigned(WN_rtype(_s->kids[1]->kids[0]->node)))
    NO_MATCH;
  return MAC16_arg_cost(_s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, &((*_c)), _s->kids[0]->matches[ISEL::acc_reg_NT].cost.cost + 1);

}
  break;
  case 430:
{
/* line 7630 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 4; 
}
  break;
  case 431:
{
/* line 7638 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 4; 
}
  break;
  case 432:
{
/* line 7648 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 433:
{
/* line 7654 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 434:
{
/* line 7662 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 435:
{
/* line 7671 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 436:
{
/* line 7680 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 437:
{
/* line 7689 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 438:
{
/* line 7698 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 439:
{
/* line 7707 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 440:
{
/* line 7716 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 441:
{
/* line 7728 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 442:
{
/* line 7740 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 443:
{
/* line 7752 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 444:
{
/* line 7764 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 445:
{
/* line 7776 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 446:
{
/* line 7790 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 447:
{
/* line 7797 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 448:
{
/* line 7804 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 449:
{
/* line 7811 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 450:
{
/* line 7818 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 451:
{
/* line 7825 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 452:
{
/* line 7832 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 453:
{
/* line 7842 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 454:
{
/* line 7852 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 455:
{
/* line 7862 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 456:
{
/* line 7872 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 457:
{
/* line 7882 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 458:
{
/* line 7894 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 459:
{
/* line 7901 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 460:
{
/* line 7908 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 461:
{
/* line 7915 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 462:
{
/* line 7922 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 463:
{
/* line 7929 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 464:
{
/* line 7936 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 465:
{
/* line 7943 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 466:
{
/* line 7950 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 467:
{
/* line 7957 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 468:
{
/* line 7964 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 469:
{
/* line 7971 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 470:
{
/* line 7978 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 471:
{
/* line 7986 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 472:
{
/* line 7994 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 473:
{
/* line 8002 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 474:
{
/* line 8010 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 475:
{
/* line 8018 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 476:
{
/* line 8027 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 477:
{
/* line 8035 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 478:
{
/* line 8043 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 479:
{
/* line 8051 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 480:
{
/* line 8059 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 481:
{
/* line 8067 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 482:
{
/* line 8078 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 483:
{
/* line 8084 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 484:
{
/* line 8090 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 485:
{
/* line 8096 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 486:
{
/* line 8102 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 487:
{
/* line 8108 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 488:
{
/* line 8114 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 489:
{
/* line 8120 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 490:
{
/* line 8126 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 491:
{
/* line 8132 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 492:
{
/* line 8138 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 493:
{
/* line 8144 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 2; 
}
  break;
  case 494:
{
/* line 8150 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 495:
{
/* line 8156 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 496:
{
/* line 8162 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 497:
{
/* line 8168 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 498:
{
/* line 8174 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 499:
{
/* line 8180 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 500:
{
/* line 8186 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 501:
{
/* line 8192 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 502:
{
/* line 8198 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 503:
{
/* line 8204 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 504:
{
/* line 8210 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 505:
{
/* line 8216 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 506:
{
/* line 8229 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 507:
{
/* line 8236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 508:
{
/* line 8245 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 509:
{
/* line 8251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 510:
{
/* line 8264 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 511:
{
/* line 8270 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 512:
{
/* line 8283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 513:
{
/* line 8292 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 514:
{
/* line 8301 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 515:
{
/* line 8330 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 516:
{
/* line 8334 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 517:
{
/* line 8338 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 518:
{
/* line 8342 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  if (!xt_mac16)
    NO_MATCH;
  (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost + 1; 

}
  break;
  case 519:
{
/* line 8354 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (!xt_mac16)
    NO_MATCH;

  if (TI_ISA_Prefer_MUL16())
    (*_c).cost = _s->matches[ISEL::acc_reg_NT].cost.cost + 100; 
  else
    (*_c).cost = _s->matches[ISEL::acc_reg_NT].cost.cost + 1; 

}
  break;
  case 520:
{
/* line 8375 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 521:
{
/* line 8382 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_hard_float)
    NO_MATCH;

  (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost + 1;

}
  break;
  case 522:
{
/* line 8397 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!xt_hard_float)
    NO_MATCH;

  (*_c).cost = _s->matches[ISEL::freg_NT].cost.cost + 1;

}
  break;
  case 523:
{
/* line 8418 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::simm12_NT].cost.cost + 1; 
}
  break;
  case 524:
{
/* line 8425 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::simm32_NT].cost.cost + 1; 
}
  break;
  case 525:
{
/* line 8432 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::float_const_NT].cost.cost + 1; 
}
  break;
  case 526:
{
/* line 8449 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 527:
{
/* line 8455 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::simm12_NT].cost.cost; 
}
  break;
  case 528:
{
/* line 8461 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 529:
{
/* line 8467 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::simm8_NT].cost.cost; 
}
  break;
  case 530:
{
/* line 8473 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 531:
{
/* line 8479 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::b4const_NT].cost.cost; 
}
  break;
  case 532:
{
/* line 8485 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 533:
{
/* line 8491 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::b4constu_NT].cost.cost; 
}
  break;
  case 534:
{
/* line 8504 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 535:
{
/* line 8508 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 536:
{
/* line 8513 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 537:
{
/* line 8517 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 538:
{
/* line 8521 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_one(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 539:
{
/* line 8531 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_one(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 540:
{
/* line 8542 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 541:
{
/* line 8546 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 542:
{
/* line 8550 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_thirtytwo(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 543:
{
/* line 8560 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_thirtytwo(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 544:
{
/* line 8571 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 545:
{
/* line 8585 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 546:
{
/* line 8591 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 547:
{
/* line 8597 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_extui_mask(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 548:
{
/* line 8611 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_extui_mask(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 549:
{
/* line 8626 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 550:
{
/* line 8632 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 551:
{
/* line 8638 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_bbci_bbsi_imm(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 552:
{
/* line 8651 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_bbci_bbsi_imm(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 553:
{
/* line 8665 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 554:
{
/* line 8671 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 555:
{
/* line 8677 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || (!is_extui_shift_mask(lit) && !is_bbci_bbsi_imm(lit)))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 556:
{
/* line 8691 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || (!is_extui_shift_mask(lit) && !is_bbci_bbsi_imm(lit)))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 557:
{
/* line 8710 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  (*_c).cost = _s->kids[1]->matches[ISEL::areg_NT].cost.cost; 

}
  break;
  case 558:
{
/* line 8718 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  (*_c).cost = _s->kids[1]->matches[ISEL::areg_NT].cost.cost; 

}
  break;
  case 559:
{
/* line 8727 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 560:
{
/* line 8733 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 561:
{
/* line 8739 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_clamps_const(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 562:
{
/* line 8753 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_clamps_const(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 563:
{
/* line 8768 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 564:
{
/* line 8774 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 565:
{
/* line 8780 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 566:
{
/* line 8784 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_simm8x256(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 567:
{
/* line 8798 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_simm8x256(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 568:
{
/* line 8847 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 569:
{
/* line 8853 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 570:
{
/* line 8859 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 571:
{
/* line 8863 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_simm8(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 572:
{
/* line 8877 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_simm8(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 573:
{
/* line 8896 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 574:
{
/* line 8902 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 575:
{
/* line 8908 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 576:
{
/* line 8935 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 577:
{
/* line 8941 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 578:
{
/* line 8947 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 579:
{
/* line 8952 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 580:
{
/* line 8958 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 581:
{
/* line 8964 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 582:
{
/* line 8968 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c) = COST_INFINITY; 
}
  break;
  case 583:
{
/* line 9010 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 584:
{
/* line 9016 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 585:
{
/* line 9022 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 586:
{
/* line 9026 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_uimm4(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 587:
{
/* line 9040 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_uimm4(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 588:
{
/* line 9055 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 589:
{
/* line 9061 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 590:
{
/* line 9067 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 591:
{
/* line 9071 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_uimm5(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 592:
{
/* line 9085 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_uimm5(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 593:
{
/* line 9168 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 594:
{
/* line 9174 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 595:
{
/* line 9180 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 596:
{
/* line 9184 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_b4constu(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 597:
{
/* line 9198 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_b4constu(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 598:
{
/* line 9213 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 599:
{
/* line 9219 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 600:
{
/* line 9225 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 601:
{
/* line 9229 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_b4const(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 602:
{
/* line 9243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_b4const(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 603:
{
/* line 9309 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 604:
{
/* line 9315 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 605:
{
/* line 9321 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 0; 
}
  break;
  case 606:
{
/* line 9325 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_msalp32(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 607:
{
/* line 9339 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  if (!lit || !is_msalp32(lit))
    NO_MATCH;
  
  (*_c).cost = 0;

}
  break;
  case 608:
{
/* line 9362 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 609:
{
/* line 9371 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 610:
{
/* line 9380 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 611:
{
/* line 9389 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 612:
{
/* line 9398 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 613:
{
/* line 9409 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 614:
{
/* line 9423 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 615:
{
/* line 9437 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 616:
{
/* line 9451 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 617:
{
/* line 9465 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 618:
{
/* line 9479 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost; 
}
  break;
  case 619:
{
/* line 9494 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 620:
{
/* line 9502 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 621:
{
/* line 9510 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 622:
{
/* line 9518 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 623:
{
/* line 9526 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 624:
{
/* line 9534 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->matches[ISEL::breg_NT].cost.cost + 2; 
}
  break;
  case 625:
{
/* line 9551 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_rtype(_s->node)!=MTYPE_XTBOOL)
    NO_MATCH;
  (*_c).cost = _s->matches[ISEL::b1reg_NT].cost.cost;

}
  break;
  case 626:
{
/* line 9562 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_rtype(_s->node)!=MTYPE_XTBOOL)
    NO_MATCH;
  (*_c).cost = _s->matches[ISEL::bareg_NT].cost.cost + 10;

}
  break;
  case 627:
{
/* line 9580 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  (*_c).cost = _s->matches[ISEL::bareg_NT].cost.cost + 10;

}
  break;
  case 628:
{
/* line 9607 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (WN_st(_s->node)!=MTYPE_To_PREG(MTYPE_XTBOOL))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost+1;

}
  break;
  case 629:
{
/* line 9627 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (WN_st(_s->node)!=MTYPE_To_PREG(MTYPE_XTBOOL2))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost+2;

}
  break;
  case 630:
{
/* line 9647 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (WN_st(_s->node)!=MTYPE_To_PREG(MTYPE_XTBOOL4))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost+4;

}
  break;
  case 631:
{
/* line 9667 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (WN_st(_s->node)!=MTYPE_To_PREG(MTYPE_XTBOOL8))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost+6;

}
  break;
  case 632:
{
/* line 9691 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (WN_st(_s->node)!=MTYPE_To_PREG(MTYPE_XTBOOL16))
    NO_MATCH;
  (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost;

}
  break;
  case 633:
{
/* line 9713 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_st(_s->node)==MTYPE_To_PREG(MTYPE_XTBOOL))
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+7;
  else
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+1;

}
  break;
  case 634:
{
/* line 9742 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_st(_s->node)==MTYPE_To_PREG(MTYPE_XTBOOL2))
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+7;
  else
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+1;

}
  break;
  case 635:
{
/* line 9771 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_st(_s->node)==MTYPE_To_PREG(MTYPE_XTBOOL4))
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+7;
  else
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+1;

}
  break;
  case 636:
{
/* line 9800 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_st(_s->node)==MTYPE_To_PREG(MTYPE_XTBOOL8))
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+7;
  else
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+1;

}
  break;
  case 637:
{
/* line 9829 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_st(_s->node)==MTYPE_To_PREG(MTYPE_XTBOOL16))
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+7;
  else
    (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost+1;

}
  break;
  case 638:
{
/* line 9860 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 639:
{
/* line 9876 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 640:
{
/* line 9892 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 641:
{
/* line 9908 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 642:
{
/* line 9924 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 643:
{
/* line 9942 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + 1; 
}
  break;
  case 644:
{
/* line 9952 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + 1; 
}
  break;
  case 645:
{
/* line 9962 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + 1; 
}
  break;
  case 646:
{
/* line 9972 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + 1; 
}
  break;
  case 647:
{
/* line 9982 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + 1; 
}
  break;
  case 648:
{
/* line 9994 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 649:
{
/* line 10007 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 650:
{
/* line 10020 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 651:
{
/* line 10033 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 652:
{
/* line 10046 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 653:
{
/* line 10061 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 654:
{
/* line 10068 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 655:
{
/* line 10075 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 656:
{
/* line 10082 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 657:
{
/* line 10089 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 658:
{
/* line 10098 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 659:
{
/* line 10114 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 660:
{
/* line 10130 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 661:
{
/* line 10146 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 662:
{
/* line 10162 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc(_s->node));
  if (macro && macro->num_instructions()!=0)
    (*_c).cost = _s->kids[0]->matches[ISEL::breg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + macro->num_instructions();
  else
    NO_MATCH;

}
  break;
  case 663:
{
/* line 10180 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 664:
{
/* line 10190 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 665:
{
/* line 10200 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 666:
{
/* line 10210 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 667:
{
/* line 10220 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost + _s->kids[1]->matches[ISEL::areg_NT].cost.cost + 1; 
}
  break;
  case 668:
{
/* line 10230 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 669:
{
/* line 10243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 670:
{
/* line 10256 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 671:
{
/* line 10269 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 672:
{
/* line 10282 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 673:
{
/* line 10295 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 674:
{
/* line 10307 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 675:
{
/* line 10319 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 676:
{
/* line 10331 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 677:
{
/* line 10343 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 678:
{
/* line 10355 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 679:
{
/* line 10368 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 680:
{
/* line 10381 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 681:
{
/* line 10394 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 682:
{
/* line 10407 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::areg_NT].cost.cost; 
}
  break;
  case 683:
{
/* line 10420 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 684:
{
/* line 10432 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 685:
{
/* line 10444 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 686:
{
/* line 10456 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 687:
{
/* line 10468 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::bareg_NT].cost.cost; 
}
  break;
  case 688:
{
/* line 10486 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 689:
{
/* line 10497 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 690:
{
/* line 10508 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 691:
{
/* line 10519 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 692:
{
/* line 10530 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 693:
{
/* line 10541 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 694:
{
/* line 10552 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 695:
{
/* line 10563 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 696:
{
/* line 10574 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 697:
{
/* line 10585 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 698:
{
/* line 10596 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + _s->kids[1]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 1; 
}
  break;
  case 699:
{
/* line 10607 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 2; 
}
  break;
  case 700:
{
/* line 10619 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = _s->kids[0]->matches[ISEL::b1reg_NT].cost.cost + 2; 
}
  break;
  case 701:
{
/* line 10631 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 702:
{
/* line 10639 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 703:
{
/* line 10647 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 704:
{
/* line 10655 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  case 705:
{
/* line 10663 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 (*_c).cost = 1; 
}
  break;
  }
#ifdef lint
  _children = _children;
#endif
  return 1;
}
/* line 2283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * stmt_action(ISEL::State *_s, /* line 2283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * expr_action(ISEL::State *_s, /* line 2235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_action(ISEL::State *_s, /* line 2236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * breg_action(ISEL::State *_s, /* line 2237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2238 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * bareg_action(ISEL::State *_s, /* line 2238 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * b1reg_action(ISEL::State *_s, /* line 2239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * freg_action(ISEL::State *_s, /* line 2240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * tie_reg_action(ISEL::State *_s, /* line 2241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2242 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * tie_cvt_reg_action(ISEL::State *_s, /* line 2242 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * ll_cvt_areg_action(ISEL::State *_s, /* line 2243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void acc_reg_action(ISEL::State *_s, /* line 2244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2245 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * tie_imm_action(ISEL::State *_s);
/* line 2246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * wsar_action(ISEL::State *_s, /* line 2246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops);
/* line 2247 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * sar_left_action(ISEL::State *_s, /* line 2247 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops);
/* line 2248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * sar_right_action(ISEL::State *_s, /* line 2248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops);
/* line 2249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_simm12_action(ISEL::State *_s, /* line 2249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_simm8_action(ISEL::State *_s, /* line 2250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_b4const_action(ISEL::State *_s, /* line 2251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_b4constu_action(ISEL::State *_s, /* line 2252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2253 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * extui_mask_action(ISEL::State *_s);
/* line 2254 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * bbci_bbsi_imm_action(ISEL::State *_s);
/* line 2255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * logical_and_immed_action(ISEL::State *_s, /* line 2255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops);
/* line 2256 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * clamps_const_action(ISEL::State *_s);
/* line 2257 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm8x256_action(ISEL::State *_s);
/* line 2260 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm8_action(ISEL::State *_s);
/* line 2261 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm12_action(ISEL::State *_s);
/* line 2263 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm32_action(ISEL::State *_s);
/* line 2266 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * uimm4_action(ISEL::State *_s);
/* line 2267 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * uimm5_action(ISEL::State *_s);
/* line 2272 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * b4constu_action(ISEL::State *_s);
/* line 2273 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * b4const_action(ISEL::State *_s);
/* line 2277 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * msalp32_action(ISEL::State *_s);
/* line 2278 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void zero_action(ISEL::State *_s);
/* line 2279 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void one_action(ISEL::State *_s);
/* line 2280 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void thirtytwo_action(ISEL::State *_s);
/* line 2281 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
INT32 float_const_action(ISEL::State *_s);
ISEL::State *ISEL_immed(ISEL::State *s,int n);
#ifndef NO_ACTION
#define NO_ACTION assert(0)
#endif
/* line 2283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * stmt_action(ISEL::State *_s, /* line 2283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::stmt_NT))
    NO_ACTION(stmt);
  _ern = _s->matches[ISEL::stmt_NT].rule_num;
  switch(_ern){
  case 0:
{
/* line 2294 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return expr_action(_s,result,ops); 
}
  break;
  case 1:
{
/* line 2298 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return expr_action(_s->kids[0],result,ops); 
}
  break;
  case 2:
{
/* line 2309 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Handle_ASM(_s->node, asm_action_callback); return 0; 
}
  break;
  case 4:
{
/* line 2326 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True(!result, ("result not expected for OPR_DEALLOCA\n"));
  Generate_Dealloca(MTYPE_U4, areg_action(_s->kids[0],0, ops), ops);
  return 0;

}
  break;
  case 5:
{
/* line 2340 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Build_OP( WN_Barrier_No_Reorder(_s->node)? TOP_extw_pseudo :
	    WN_Barrier_No_Reorder_Memory(_s->node)? TOP_memw_pseudo :
	    WN_Barrier_Flush_Memory(_s->node)? TOP_memw :
		earliest_arch==Barcelona_Xtensa ?	/* FLUSH */
		TOP_extw : TOP_memw,
	    ops ); return 0; 
}
  break;
  case 6:
{
/* line 2348 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Build_OP( WN_Barrier_No_Reorder(_s->node)? TOP_extw_pseudo :
	    WN_Barrier_No_Reorder_Memory(_s->node)? TOP_memw_pseudo :
	    WN_Barrier_Flush_Memory(_s->node)? TOP_memw :
		earliest_arch==Barcelona_Xtensa ?	/* FLUSH */
		TOP_extw : TOP_memw,
	    ops ); return 0; 
}
  break;
  case 7:
{
/* line 2396 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 TN* in_operands[128];
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(_s->node));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count(_s->node);
#if 0
printf("isel tie intr call action: %s\n", tie_macro->name());
#endif

  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid(_s->node,i));
    if (tie_macro->proto_is_out(i) &&
	WN_operator(kid)==OPR_LDID &&
	ST_class(WN_st(kid))==CLASS_PREG)
      in_operands[i]=PREG_To_TN(WN_st(kid),WN_offset(kid));
    else {
      if (tie_macro->proto_is_immed(i))
	in_operands[i]=action_by_type(kid, "immediate", 0, ops);
      else
	in_operands[i]=action_by_type(kid,tie_macro->proto_mtype_id(tie_info,i),0,ops);
    }
  }

  Set_Last_Mem_OP( ops );
  expand_tie_macro_to_ops(ops, Intrinsic_To_Tie_Macro_Id(WN_intrinsic(_s->node)), in_operands);
  Set_OP_To_WN_Map(_s->node);

  return 0;

}
  break;
  case 8:
{
/* line 2468 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 TN* in_operands[128];
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(_s->node));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count(_s->node);
#if 0
printf("isel tie intr call action: %s\n", tie_macro->name());
#endif

  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid(_s->node,i));
    if (tie_macro->proto_is_label(i)) {
      in_operands[i]= Gen_Label_TN(WN_const_val(kid),0);
    } else if (tie_macro->proto_is_out(i) &&
	WN_operator(kid)==OPR_LDID &&
	ST_class(WN_st(kid))==CLASS_PREG)
      in_operands[i]=PREG_To_TN(WN_st(kid),WN_offset(kid));
    else {
      if (tie_macro->proto_is_immed(i))
	in_operands[i]=action_by_type(kid, "immediate", 0, ops);
      else
	in_operands[i]=action_by_type(kid,tie_macro->proto_mtype_id(tie_info,i),0,ops);
    }
  }

  Set_Last_Mem_OP( ops );
  expand_tie_macro_to_ops(ops, Intrinsic_To_Tie_Macro_Id(WN_intrinsic(_s->node)), in_operands);
  Set_OP_To_WN_Map(_s->node);

  End_Basic_Block(_s->node);

  return 0;

}
  break;
  case 9:
{
/* line 2503 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 10:
{
/* line 2507 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 11:
{
/* line 2511 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 12:
{
/* line 2515 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 13:
{
/* line 2519 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 14:
{
/* line 2523 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 15:
{
/* line 2527 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 16:
{
/* line 2531 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 17:
{
/* line 2535 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 18:
{
/* line 2539 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 19:
{
/* line 2543 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 20:
{
/* line 2547 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_Call( _s->node, ABI_CALL, ops); return 0; 
}
  break;
  case 21:
{
/* line 2558 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 22:
{
/* line 2562 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 23:
{
/* line 2566 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 24:
{
/* line 2570 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 25:
{
/* line 2574 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 26:
{
/* line 2578 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 27:
{
/* line 2582 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 28:
{
/* line 2586 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 29:
{
/* line 2590 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 30:
{
/* line 2594 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 31:
{
/* line 2598 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 32:
{
/* line 2602 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 Generate_ICall( _s->node, ABI_ICALL, ops); return 0; 
}
  break;
  case 33:
{
/* line 2613 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from region exit"));
  Build_OP( TOP_j, Gen_Label_TN(Get_WN_Label(_s->node),0), ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 34:
{
/* line 2622 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from goto"));
  Build_OP( TOP_j, Gen_Label_TN(Get_WN_Label(_s->node),0), ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 35:
{
/* line 2631 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (ST_is_switchjump(WN_st(_s->node))) { 
    FmtAssert( result==0, ("Requesting result from xgoto"));
    FmtAssert( !Gen_PIC_Shared, ("-mswitchjump not supported with PIC code"));
    Build_OP( TOP_jx, areg_action(_s->kids[0],0, ops), ops );
    Handle_XGOTO_Extras(_s->node);
    End_Basic_Block(_s->node);
    return 0;
  } else {
    Is_True( result==0, ("Requesting result from xgoto"));
    Build_OP( TOP_jx, areg_action(_s->kids[0],0, ops), ops );
    Handle_XGOTO_Extras(_s->node);
    End_Basic_Block(_s->node);
    return 0;
  }

}
  break;
  case 36:
{
/* line 2651 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from agoto"));
  Build_OP( TOP_jx, areg_action(_s->kids[0],0, ops), ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 37:
{
/* line 2660 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Build_OP( TOP_j, Gen_Label_TN(Get_WN_Label(_s->node),0), ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 38:
{
/* line 2668 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Build_OP( TOP_bnez, areg_action(_s->kids[0],0,ops), Gen_Label_TN(Get_WN_Label(_s->node),0), ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 39:
{
/* line 2676 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Build_OP( TOP_beqz, areg_action(_s->kids[0],0,ops), Gen_Label_TN(Get_WN_Label(_s->node),0), ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 40:
{
/* line 2690 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0],0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 41:
{
/* line 2700 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * r = freg_action(_s->kids[0]->kids[1],0,ops);
  TN * l = freg_action(_s->kids[0]->kids[0],0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 42:
{
/* line 2712 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * r = freg_action(_s->kids[0]->kids[1],0,ops);
  TN * l = freg_action(_s->kids[0]->kids[0],0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 43:
{
/* line 2724 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 44:
{
/* line 2734 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 45:
{
/* line 2744 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0],0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 46:
{
/* line 2754 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * r = freg_action(_s->kids[0]->kids[1],0,ops);
  TN * l = freg_action(_s->kids[0]->kids[0],0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 47:
{
/* line 2766 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * r = freg_action(_s->kids[0]->kids[1],0,ops);
  TN * l = freg_action(_s->kids[0]->kids[0],0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 48:
{
/* line 2778 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 49:
{
/* line 2788 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 50:
{
/* line 2807 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 51:
{
/* line 2817 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 52:
{
/* line 2827 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 53:
{
/* line 2837 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 54:
{
/* line 2847 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 55:
{
/* line 2857 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 56:
{
/* line 2867 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 57:
{
/* line 2877 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0],0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 58:
{
/* line 2887 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 59:
{
/* line 2897 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn2 = Gen_Label_TN(Get_WN_Label(_s->node),0);
  TN * tn1 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block(_s->node);
  return 0;

}
  break;
  case 60:
{
/* line 2916 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 61:
{
/* line 2926 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 62:
{
/* line 2936 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 63:
{
/* line 2946 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 64:
{
/* line 2956 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 65:
{
/* line 2966 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 66:
{
/* line 2976 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 67:
{
/* line 2986 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 68:
{
/* line 2996 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 69:
{
/* line 3006 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);;
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 70:
{
/* line 3016 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);;
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 71:
{
/* line 3026 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);;
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 72:
{
/* line 3038 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);;
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 73:
{
/* line 3048 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 74:
{
/* line 3058 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);;
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 75:
{
/* line 3068 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 76:
{
/* line 3078 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 77:
{
/* line 3088 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 78:
{
/* line 3098 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 79:
{
/* line 3108 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 80:
{
/* line 3118 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 81:
{
/* line 3128 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 82:
{
/* line 3138 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bgeu, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 83:
{
/* line 3148 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4constu_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4constu_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_U4, TOP_bltu, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 84:
{
/* line 3166 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 85:
{
/* line 3176 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 86:
{
/* line 3186 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 87:
{
/* line 3196 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 88:
{
/* line 3206 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 89:
{
/* line 3216 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 90:
{
/* line 3226 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 91:
{
/* line 3236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 92:
{
/* line 3246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 93:
{
/* line 3256 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 94:
{
/* line 3266 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 95:
{
/* line 3276 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 96:
{
/* line 3288 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 97:
{
/* line 3298 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 98:
{
/* line 3308 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 99:
{
/* line 3318 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 100:
{
/* line 3328 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 101:
{
/* line 3338 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 102:
{
/* line 3348 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bne, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 103:
{
/* line 3358 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_beq, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 104:
{
/* line 3368 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 105:
{
/* line 3378 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 106:
{
/* line 3388 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_bge, Get_WN_Label(_s->node), tn3, tn4, ops );
  return 0;

}
  break;
  case 107:
{
/* line 3398 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = areg_or_b4const_action(_s->kids[0]->kids[0],0,ops);
  TN * tn4 = areg_or_b4const_action(_s->kids[0]->kids[1],0,ops);
  Generate_Branch( _s->node, MTYPE_I4, TOP_blt, Get_WN_Label(_s->node), tn4, tn3, ops );
  return 0;

}
  break;
  case 108:
{
/* line 3424 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn4, tn5, ops); 
}
  break;
  case 109:
{
/* line 3434 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn5, tn4, ops); 
}
  break;
  case 110:
{
/* line 3444 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn5, tn6, ops); 
}
  break;
  case 111:
{
/* line 3454 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn6, tn5, ops); 
}
  break;
  case 112:
{
/* line 3461 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn6, ops);
  return 0; 
}
  break;
  case 113:
{
/* line 3469 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn4, ops);
  return 0; 
}
  break;
  case 114:
{
/* line 3480 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn4, tn5, ops); 
}
  break;
  case 115:
{
/* line 3490 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn5, tn4, ops); 
}
  break;
  case 116:
{
/* line 3500 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn5, tn6, ops); 
}
  break;
  case 117:
{
/* line 3510 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn6, tn5, ops); 
}
  break;
  case 118:
{
/* line 3517 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn6, ops);
  return 0; 
}
  break;
  case 119:
{
/* line 3525 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn4, ops);
  return 0; 
}
  break;
  case 120:
{
/* line 3536 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn4, tn5, ops); 
}
  break;
  case 121:
{
/* line 3546 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn5, tn4, ops); 
}
  break;
  case 122:
{
/* line 3556 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn5, tn6, ops); 
}
  break;
  case 123:
{
/* line 3566 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_beq, tn6, tn5, ops); 
}
  break;
  case 124:
{
/* line 3573 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn6, ops);
  return 0; 
}
  break;
  case 125:
{
/* line 3581 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn4, ops);
  return 0; 
}
  break;
  case 126:
{
/* line 3592 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn4, tn5, ops); 
}
  break;
  case 127:
{
/* line 3602 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn5, tn4, ops); 
}
  break;
  case 128:
{
/* line 3612 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn5, tn6, ops); 
}
  break;
  case 129:
{
/* line 3622 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_beq, tn6, tn5, ops); 
}
  break;
  case 130:
{
/* line 3629 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn6, ops);
  return 0; 
}
  break;
  case 131:
{
/* line 3637 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  Generate_Branch(_s->node, MTYPE_I4, TOP_bnone, Get_WN_Label(_s->node), tn5, tn4, ops);
  return 0; 
}
  break;
  case 132:
{
/* line 3650 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn4, tn5, ops); 
}
  break;
  case 133:
{
/* line 3660 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn5, tn4, ops); 
}
  break;
  case 134:
{
/* line 3670 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn5, tn6, ops); 
}
  break;
  case 135:
{
/* line 3680 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn6, tn5, ops); 
}
  break;
  case 136:
{
/* line 3690 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn4, tn5, ops); 
}
  break;
  case 137:
{
/* line 3700 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn5, tn4, ops); 
}
  break;
  case 138:
{
/* line 3710 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn5, tn6, ops); 
}
  break;
  case 139:
{
/* line 3720 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn6, tn5, ops); 
}
  break;
  case 140:
{
/* line 3730 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn4, tn5, ops); 
}
  break;
  case 141:
{
/* line 3740 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn5, tn4, ops); 
}
  break;
  case 142:
{
/* line 3750 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn5, tn6, ops); 
}
  break;
  case 143:
{
/* line 3760 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_I4, TOP_bne, tn6, tn5, ops); 
}
  break;
  case 144:
{
/* line 3770 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  TN * tn4 = areg_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn4, tn5, ops); 
}
  break;
  case 145:
{
/* line 3780 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn4 = logical_and_immed_action(_s->kids[0]->kids[0]->kids[0],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[0]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn5, tn4, ops); 
}
  break;
  case 146:
{
/* line 3790 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn6 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  TN * tn5 = areg_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn5, tn6, ops); 
}
  break;
  case 147:
{
/* line 3800 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn5 = logical_and_immed_action(_s->kids[0]->kids[1]->kids[0],0,ops);
  TN * tn6 = areg_action(_s->kids[0]->kids[1]->kids[1],0,ops);
  return Generate_Logical_And_Conditional(_s->node, MTYPE_U4, TOP_bne, tn6, tn5, ops); 
}
  break;
  case 701:
{
/* line 10632 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( _s->node, ABI_CALL, ops);
  return 0;

}
  break;
  case 702:
{
/* line 10640 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( _s->node, ABI_CALL, ops);
  return 0;

}
  break;
  case 703:
{
/* line 10648 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( _s->node, ABI_CALL, ops);
  return 0;

}
  break;
  case 704:
{
/* line 10656 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( _s->node, ABI_CALL, ops);
  return 0;

}
  break;
  case 705:
{
/* line 10664 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( _s->node, ABI_CALL, ops);
  return 0;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._stmt(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule stmt"));
  /*NOTREACHED*/
}
/* line 2235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * expr_action(ISEL::State *_s, /* line 2235 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::expr_NT))
    NO_ACTION(expr);
  _ern = _s->matches[ISEL::expr_NT].rule_num;
  switch(_ern){
  case 240:
{
/* line 4993 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_I4, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 241:
{
/* line 5003 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U4, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 242:
{
/* line 5013 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory(_s->node, MTYPE_I4, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 243:
{
/* line 5023 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = freg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory(_s->node, MTYPE_F4, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 244:
{
/* line 5033 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_I2, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 245:
{
/* line 5043 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U2, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 246:
{
/* line 5053 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_I1, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 247:
{
/* line 5063 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = areg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U1, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 248:
{
/* line 5081 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 249:
{
/* line 5092 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 250:
{
/* line 5108 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 251:
{
/* line 5124 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 252:
{
/* line 5135 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 253:
{
/* line 5146 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 254:
{
/* line 5158 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = float_preg_to_int_tn(s, o);      
  return areg_action(_s->kids[0],dst,ops);

}
  break;
  case 255:
{
/* line 5170 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s, o);
  return freg_action(_s->kids[0],dst,ops);

}
  break;
  case 256:
{
/* line 5181 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U4, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 257:
{
/* line 5191 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U2, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 258:
{
/* line 5201 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 259:
{
/* line 5211 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_I4, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 260:
{
/* line 5221 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_I2, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 261:
{
/* line 5231 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_I1, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 262:
{
/* line 5241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = areg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_I4, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 263:
{
/* line 5251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = freg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_F4, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 264:
{
/* line 5261 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  return areg_action(_s,result, ops);

}
  break;
  case 265:
{
/* line 5267 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  return tie_reg_action(_s,result, ops);

}
  break;
  case 266:
{
/* line 5273 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  FmtAssert(0,("Should never reach here"));
  return 0;

}
  break;
  case 267:
{
/* line 5280 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  FmtAssert(0,("Should never reach here"));
  return 0;

}
  break;
  case 268:
{
/* line 5287 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  return breg_action(_s,result, ops);

}
  break;
  case 269:
{
/* line 5293 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  return freg_action(_s,result, ops);

}
  break;
  case 305:
{
/* line 5917 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  WN* kid = WN_kid0(_s->node);
  TN *result_lo, *result_hi;

  Is_True(WN_operator(kid)==OPR_CVT, ("Expecting TIE conversion"));
  Is_True(MTYPE_is_tie(WN_desc(kid)), ("Expecting TIE type"));
  Is_True(result==0, ("Requesting result from store"));
  if (Target_Byte_Sex == BIG_ENDIAN) {
    result_lo = PREG_To_TN(s,o+Preg_Increment(MTYPE_I4));
    result_hi = PREG_To_TN(s,o);
  } else {
    result_hi = PREG_To_TN(s,o+Preg_Increment(MTYPE_I4));
    result_lo = PREG_To_TN(s,o);
  }

  TN* areg = areg_action(_s->kids[0],0,ops);
  TN* areg_1 = get_reg_tn_pair(areg);
  Move_To_Register(MTYPE_I4,result_hi,areg_1,ops);
  return Move_To_Register(MTYPE_I4,result_lo,areg,ops);

}
  break;
  case 306:
{
/* line 5943 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  WN* kid = WN_kid0(_s->node);
  TN *result_lo, *result_hi;

  Is_True(WN_operator(kid)==OPR_CVT, ("Expecting TIE conversion"));
  Is_True(MTYPE_is_tie(WN_desc(kid)), ("Expecting TIE type"));
  Is_True(result==0, ("Requesting result from store"));
  if (Target_Byte_Sex == BIG_ENDIAN) {
    result_lo = PREG_To_TN(s,o+Preg_Increment(MTYPE_U4));
    result_hi = PREG_To_TN(s,o);
  } else {
    result_hi = PREG_To_TN(s,o+Preg_Increment(MTYPE_U4));
    result_lo = PREG_To_TN(s,o);
  }

  TN* areg = areg_action(_s->kids[0],0,ops);
  TN* areg_1 = get_reg_tn_pair(areg);
  Move_To_Register(MTYPE_U4,result_hi,areg_1,ops);
  return Move_To_Register(MTYPE_U4,result_lo,areg,ops);

}
  break;
  case 582:
{
/* line 8969 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  FmtAssert(0,("Should never reach here"));
  return 0;

}
  break;
  case 628:
{
/* line 9612 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = b1reg_action(_s->kids[0],0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;

}
  break;
  case 629:
{
/* line 9632 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = breg_action(_s->kids[0],0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL2 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr2, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;

}
  break;
  case 630:
{
/* line 9652 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = breg_action(_s->kids[0],0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL4 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr4, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;

}
  break;
  case 631:
{
/* line 9672 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = breg_action(_s->kids[0],0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL8 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
  TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_get_tmp_ar, tmp1, ops );
  Build_OP(TOP_get_tmp_ar, tmp2, ops );
  Build_OP(TOP_movbr8, dst, src, tmp1, tmp2, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;

}
  break;
  case 632:
{
/* line 9696 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = breg_action(_s->kids[0],0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL16 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr16, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;

}
  break;
  case 633:
{
/* line 9719 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = bareg_action(_s->kids[0],0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;

}
  break;
  case 634:
{
/* line 9748 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = bareg_action(_s->kids[0],0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br2, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;

}
  break;
  case 635:
{
/* line 9777 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = bareg_action(_s->kids[0],0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br4, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;

}
  break;
  case 636:
{
/* line 9806 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = bareg_action(_s->kids[0],0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br8, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;

}
  break;
  case 637:
{
/* line 9835 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_store_offset(_s->node);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = bareg_action(_s->kids[0],0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br16, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;

}
  break;
  case 638:
{
/* line 9867 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = breg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, WN_desc(_s->node), val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 639:
{
/* line 9883 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = breg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, WN_desc(_s->node), val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 640:
{
/* line 9899 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = breg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, WN_desc(_s->node), val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 641:
{
/* line 9915 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = breg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, WN_desc(_s->node), val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 642:
{
/* line 9931 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = breg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, WN_desc(_s->node), val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 643:
{
/* line 9943 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U1, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 644:
{
/* line 9953 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U1, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 645:
{
/* line 9963 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U1, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 646:
{
/* line 9973 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U1, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 647:
{
/* line 9983 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( _s->node, MTYPE_U2, val, WN_st(_s->node), WN_store_offset(_s->node), Variant_STID(_s->node), ops);
  return val;

}
  break;
  case 658:
{
/* line 10105 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = breg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, WN_desc(_s->node), val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 659:
{
/* line 10121 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = breg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, WN_desc(_s->node), val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 660:
{
/* line 10137 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = breg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, WN_desc(_s->node), val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 661:
{
/* line 10153 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = breg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, WN_desc(_s->node), val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 662:
{
/* line 10169 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = breg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, WN_desc(_s->node), val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 663:
{
/* line 10181 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 664:
{
/* line 10191 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 665:
{
/* line 10201 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 666:
{
/* line 10211 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  case 667:
{
/* line 10221 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN *addr = areg_action(_s->kids[1],0,ops);
  TN *val = bareg_action(_s->kids[0],0,ops);
  Generate_Store_Memory(_s->node, MTYPE_U2, val, addr, WN_offset(_s->node), Variant_ISTORE(_s->node), ops );
  return val;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._expr(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule expr"));
  /*NOTREACHED*/
}
/* line 2236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_action(ISEL::State *_s, /* line 2236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::areg_NT))
    NO_ACTION(areg);
  _ern = _s->matches[ISEL::areg_NT].rule_num;
  switch(_ern){
  case 3:
{
/* line 2320 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Alloca(MTYPE_U4, result, areg_or_simm8_action(_s->kids[0],0, ops), ops);

}
  break;
  case 148:
{
/* line 3816 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
    return Generate_Comparison(OPR_LT, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 149:
{
/* line 3825 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 150:
{
/* line 3834 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 151:
{
/* line 3843 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 152:
{
/* line 3852 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 153:
{
/* line 3861 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 154:
{
/* line 3872 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LT, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 155:
{
/* line 3881 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 156:
{
/* line 3890 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 157:
{
/* line 3899 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 158:
{
/* line 3908 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 159:
{
/* line 3917 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);

}
  break;
  case 160:
{
/* line 3935 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LT, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 161:
{
/* line 3944 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 162:
{
/* line 3953 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 163:
{
/* line 3962 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 164:
{
/* line 3971 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 165:
{
/* line 3980 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 166:
{
/* line 3991 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LT, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 167:
{
/* line 4000 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 168:
{
/* line 4009 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 169:
{
/* line 4018 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 170:
{
/* line 4027 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 171:
{
/* line 4036 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);

}
  break;
  case 172:
{
/* line 4057 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  INT32 bit_pos;
  TN * power_of_2 = bbci_bbsi_imm_action(_s->kids[0]->kids[1]);
  TN * src = areg_action(_s->kids[0]->kids[0],0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_I4);
  if (Get_Bbci_Bbsi_Immediate(TN_value(power_of_2), &bit_pos))
    Build_OP(TOP_extui, result, src, 
             Gen_Literal_TN(bit_pos, 4), Gen_Literal_TN(1, 4), ops);
  else 
    Fail_FmtAssertion("Expected a power of 2 (1..1<<31)");
  return result;

}
  break;
  case 173:
{
/* line 4073 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  INT32 bit_pos;
  TN * power_of_2 = bbci_bbsi_imm_action(_s->kids[0]->kids[1]);
  TN * src = areg_action(_s->kids[0]->kids[0],0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_I4);
  if (Get_Bbci_Bbsi_Immediate(TN_value(power_of_2), &bit_pos))
    Build_OP(TOP_extui, result, src, 
             Gen_Literal_TN(bit_pos, 4), Gen_Literal_TN(1, 4), ops);
  else 
    Fail_FmtAssertion("Expected a power of 2 (1..1<<31)");
  return result;

}
  break;
  case 174:
{
/* line 4098 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = areg_action(_s->kids[2],0,ops);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movnez, result, tn2, tn3, tn4, ops);

}
  break;
  case 175:
{
/* line 4107 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = areg_action(_s->kids[2],0,ops);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Cmov(MTYPE_U4, TOP_movnez, result, tn2, tn3, tn4, ops);

}
  break;
  case 176:
{
/* line 4116 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = areg_action(_s->kids[2],0,ops);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movnez, result, tn2, tn3, tn4, ops);

}
  break;
  case 178:
{
/* line 4138 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 179:
{
/* line 4152 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 180:
{
/* line 4166 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 181:
{
/* line 4180 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 182:
{
/* line 4194 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 183:
{
/* line 4208 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 184:
{
/* line 4222 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 185:
{
/* line 4236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 186:
{
/* line 4250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 187:
{
/* line 4264 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 188:
{
/* line 4278 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 189:
{
/* line 4292 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 190:
{
/* line 4308 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 191:
{
/* line 4322 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 192:
{
/* line 4336 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 193:
{
/* line 4350 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 194:
{
/* line 4364 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 195:
{
/* line 4378 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 196:
{
/* line 4392 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 197:
{
/* line 4406 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 198:
{
/* line 4420 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 199:
{
/* line 4434 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 200:
{
/* line 4448 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 201:
{
/* line 4462 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 202:
{
/* line 4478 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 203:
{
/* line 4492 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 204:
{
/* line 4506 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 205:
{
/* line 4520 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 206:
{
/* line 4534 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 207:
{
/* line 4548 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 208:
{
/* line 4562 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 209:
{
/* line 4576 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 210:
{
/* line 4590 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 211:
{
/* line 4604 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 212:
{
/* line 4618 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 213:
{
/* line 4632 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 214:
{
/* line 4648 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 215:
{
/* line 4662 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 216:
{
/* line 4676 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 217:
{
/* line 4690 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 218:
{
/* line 4704 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 219:
{
/* line 4718 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 220:
{
/* line 4732 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 221:
{
/* line 4746 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 222:
{
/* line 4760 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 223:
{
/* line 4774 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 224:
{
/* line 4788 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 225:
{
/* line 4802 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = areg_or_simm12_action(_s->kids[2],0,ops);
  TN * tn5 = areg_or_simm12_action(_s->kids[1],0,ops);
  TN * tn4 = areg_or_simm8_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = areg_or_simm8_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Conditional_Select(WN_rtype(_s->kids[0]->node), WN_desc(_s->kids[0]->node), WN_operator(_s->kids[0]->node),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);

}
  break;
  case 226:
{
/* line 4824 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = areg_action(_s->kids[2],0,ops);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = b1reg_action(_s->kids[0],0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movt, result, tn2, tn3, tn4, ops);

}
  break;
  case 227:
{
/* line 4833 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = areg_action(_s->kids[2],0,ops);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = b1reg_action(_s->kids[0],0,ops);
  return Generate_Cmov(MTYPE_U4, TOP_movt, result, tn2, tn3, tn4, ops);

}
  break;
  case 228:
{
/* line 4842 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = areg_action(_s->kids[2],0,ops);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = b1reg_action(_s->kids[0],0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movt, result, tn2, tn3, tn4, ops);

}
  break;
  case 230:
{
/* line 4861 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn5 = areg_action(_s->kids[2],0,ops);
  TN * tn4 = areg_action(_s->kids[1],0,ops);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movf, result, tn3, tn4, tn5, ops);

}
  break;
  case 231:
{
/* line 4870 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn5 = areg_action(_s->kids[2],0,ops);
  TN * tn4 = areg_action(_s->kids[1],0,ops);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Cmov(MTYPE_U4, TOP_movf, result, tn3, tn4, tn5, ops);

}
  break;
  case 232:
{
/* line 4879 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn5 = areg_action(_s->kids[2],0,ops);
  TN * tn4 = areg_action(_s->kids[1],0,ops);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movf, result, tn3, tn4, tn5, ops);

}
  break;
  case 270:
{
/* line 5305 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);

}
  break;
  case 271:
{
/* line 5314 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);

}
  break;
  case 272:
{
/* line 5323 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);

}
  break;
  case 273:
{
/* line 5333 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);

}
  break;
  case 274:
{
/* line 5342 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);

}
  break;
  case 275:
{
/* line 5351 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);

}
  break;
  case 276:
{
/* line 5360 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  TN *val = float_preg_to_int_tn(s, o);      
  return Move_To_Register(MTYPE_I4, result, val, ops);

}
  break;
  case 278:
{
/* line 5381 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I4, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 279:
{
/* line 5389 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I2, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 280:
{
/* line 5397 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I1, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 281:
{
/* line 5405 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U4, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 282:
{
/* line 5413 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U2, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 283:
{
/* line 5421 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 284:
{
/* line 5430 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_I4);
  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, mtype, mtype, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 286:
{
/* line 5448 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I4, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 287:
{
/* line 5455 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I2, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 288:
{
/* line 5462 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I1, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 289:
{
/* line 5469 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U4, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 290:
{
/* line 5476 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U2, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 291:
{
/* line 5483 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 292:
{
/* line 5495 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_I4);
  return Generate_Load_Memory(_s->node, mtype, mtype, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 294:
{
/* line 5511 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  ST *s = WN_st(_s->node);
  INT64 o = WN_lda_offset(_s->node);
  return Generate_Constant(MTYPE_U4, _s->node, result, s, o, ops);

}
  break;
  case 295:
{
/* line 5519 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Constant(MTYPE_U4, _s->node, result, Gen_Label_TN(Get_WN_Label(_s->node),0), ops );

}
  break;
  case 296:
{
/* line 5525 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Allocate_Object(WN_st(_s->node));
  Set_Last_Mem_OP(ops);
  Generate_OP_And_Address_Computation(TOP_addi, result,
				      WN_st(_s->node), WN_load_offset(_s->node), ops,
				      use_conservative_addressing(WN_st(_s->node)),
				      false, false);
  Set_OP_To_WN_Map(_s->node);
  return result;

}
  break;
  case 297:
{
/* line 5551 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + Preg_Increment(MTYPE_I4);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);

}
  break;
  case 299:
{
/* line 5614 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + Preg_Increment(MTYPE_U4);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);

}
  break;
  case 301:
{
/* line 5677 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  INT64 o = WN_load_offset(_s->node);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_I4);
  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I4, result,
			      WN_st(_s->node), o, Variant_LDID(_s->node), ops);

}
  break;
  case 302:
{
/* line 5741 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  INT64 o = WN_load_offset(_s->node);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_U4);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U4, result,
			      WN_st(_s->node), o, Variant_LDID(_s->node), ops);

}
  break;
  case 303:
{
/* line 5805 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  INT64 o = WN_offset(_s->node);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_I4);
  return Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I4, result,
			      areg_action(_s->kids[0],0,ops), o, Variant_ILOAD(_s->node), ops);

}
  break;
  case 304:
{
/* line 5855 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  INT64 o = WN_offset(_s->node);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_U4);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U4, result,
			      areg_action(_s->kids[0],0,ops), o, Variant_ILOAD(_s->node), ops);

}
  break;
  case 307:
{
/* line 5977 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *reg_or_imm = areg_or_simm8_action(_s->kids[1],0,ops);
  return Generate_Binary(MTYPE_I4, (TN_has_value(reg_or_imm)) ? TOP_addi : TOP_add,
			 result, areg_action(_s->kids[0],0,ops), reg_or_imm, ops);

}
  break;
  case 308:
{
/* line 5985 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn2 = simm8_action(_s->kids[0]);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  
  return Generate_Binary( MTYPE_I4, TOP_addi, result,
			  tn3, tn2, ops );

}
  break;
  case 309:
{
/* line 5995 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn3 = simm8x256_action(_s->kids[1]);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  return Generate_Binary( MTYPE_I4, TOP_addmi, result,
			  tn2, tn3, ops );

}
  break;
  case 310:
{
/* line 6004 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn2 = simm8x256_action(_s->kids[0]);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  return Generate_Binary( MTYPE_I4, TOP_addmi, result,
			  tn3, tn2, ops );

}
  break;
  case 311:
{
/* line 6015 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *reg_or_imm = areg_or_simm8_action(_s->kids[1],0,ops);
  return Generate_Binary(MTYPE_U4, (TN_has_value(reg_or_imm)) ? TOP_addi : TOP_add,
			 result, areg_action(_s->kids[0],0,ops), reg_or_imm, ops);

}
  break;
  case 312:
{
/* line 6023 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn2 = simm8_action(_s->kids[0]);
  TN * tn3 = areg_action(_s->kids[1],0,ops);			  
  return Generate_Binary( MTYPE_U4, TOP_addi, result,
			  tn3, tn2, ops );

}
  break;
  case 313:
{
/* line 6032 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = simm8x256_action(_s->kids[1]);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  
  return Generate_Binary( MTYPE_U4, TOP_addmi, result,
			  tn2, tn3, ops );

}
  break;
  case 314:
{
/* line 6042 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn2 = simm8x256_action(_s->kids[0]);
  TN * tn3 = areg_action(_s->kids[1],0,ops);
			  
  return Generate_Binary( MTYPE_U4, TOP_addmi, result,
			  tn3, tn2, ops );

}
  break;
  case 315:
{
/* line 6054 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_or_simm8_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
			  
  return Generate_Sub(MTYPE_I4, result, tn2, tn3, ops);

}
  break;
  case 316:
{
/* line 6070 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = simm8x256_action(_s->kids[1]);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
			  
 return Generate_Binary(MTYPE_U4, TOP_addmi, result, tn2,
			 Gen_Literal_TN(-TN_value(tn3), 4), ops);


}
  break;
  case 317:
{
/* line 6083 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_or_simm8_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
			  
  return Generate_Sub(MTYPE_U4, result, tn2, tn3, ops);

}
  break;
  case 318:
{
/* line 6099 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn3 = simm8x256_action(_s->kids[1]);
  TN * tn2 = areg_action(_s->kids[0],0,ops);		  
 return Generate_Binary(MTYPE_U4, TOP_addmi, result, tn2,
			 Gen_Literal_TN(-TN_value(tn3), 4), ops);


}
  break;
  case 319:
{
/* line 6130 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  char *op_name = NULL;
  bool mul16 = false;
  if (xt_mul16 && WN_Mpy_16Bit(_s->node))
  {
    if (WN_Mpy_16Bit_Signed(_s->node))
      op_name = "mul16s";
    else
      op_name = "mul16u";
    mul16 = true;
  }  
  else if (xt_mul32)
  {
    op_name = "mull";
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit(_s->node))
  {
    /* op_name is set to NULL. Note that xt_mul16 and xt_mul32 have
       priority over HiFi2. */
    mul16 = true;
  }
  else
    FmtAssert(FALSE, ("cannot generate multiply instruction"));

  if (mul16)
    return Generate_MUL16(MTYPE_I4, result, _s->node, op_name, _s->kids[0]->node, _s->kids[1]->node, ops);
  
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  
  return Generate_Mul(MTYPE_I4, result, _s->node, op_name, tn2, tn3, ops);

}
  break;
  case 320:
{
/* line 6186 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  char *op_name = NULL;
  bool mul16 = false;
  if (xt_mul16 && WN_Mpy_16Bit(_s->node))
  {
    if (WN_Mpy_16Bit_Signed(_s->node))
      op_name = "mul16s";
    else
      op_name = "mul16u";
    mul16 = true;
  }  
  else if (xt_mul32)
  {
    op_name = "mull";
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit(_s->node))
  {
    /* op_name is set to NULL. Note that xt_mul16 and xt_mul32 have
       priority over hifi2. */
    mul16 = true;
  }
  else
    FmtAssert(FALSE, ("cannot generate multiply instruction"));

  if (mul16)
    return Generate_MUL16(MTYPE_U4, result, _s->node, op_name, _s->kids[0]->node, _s->kids[1]->node, ops);
  
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  
  return Generate_Mul(MTYPE_U4, result, _s->node, op_name, tn2, tn3, ops);

}
  break;
  case 321:
{
/* line 6222 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to DIV are constant");
    return Generate_Constant(MTYPE_I4, result, tn_equiv_const(tn2)/tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_I4, TOP_quos, result, tn2, tn3, ops);
  }

}
  break;
  case 322:
{
/* line 6236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to unsigned DIV are constant");
    return Generate_Constant(MTYPE_U4, result, tn_equiv_const(tn2)/tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_U4, TOP_quou, result, tn2, tn3, ops);
  }

}
  break;
  case 323:
{
/* line 6250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to REM are constant");
    return Generate_Constant(MTYPE_I4, result, tn_equiv_const(tn2) % tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_I4, TOP_rems, result, tn2, tn3, ops);
  }

}
  break;
  case 324:
{
/* line 6264 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to unsigned REM are constant");
    return Generate_Constant(MTYPE_U4, result, tn_equiv_const(tn2) % tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_U4, TOP_remu, result, tn2, tn3, ops);
  }

}
  break;
  case 325:
{
/* line 6278 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to MOD are constant");
    // a mod b == (1) (a rem b)        if a*b >= 0 OR (a rem b) == 0;
    //            (2) (a rem b) + b    otherwise
    INT64 cdivident = tn_equiv_const(tn2);
    INT64 cdivisor  = tn_equiv_const(tn3);
    INT64 cres      = cdivident % cdivisor;
    if ( (cres != 0) && (cdivident * cdivisor < 0) ) {
      cres += cdivisor;
    }
    return Generate_Constant(MTYPE_I4, result, cres, ops);
  } else {
    TN *sign_tn;
    TN *tmp;
    Build_OP(TOP_movi, tmp, Gen_Literal_TN(0, 4), ops);
    Build_OP(TOP_xor, sign_tn, tn2, tn3, ops);
    Build_OP(TOP_movltz, tmp, tn3, sign_tn, ops);
    
    Generate_iDivRem(MTYPE_I4, TOP_rems, result, tn2, tn3, ops);

    Build_OP(TOP_add, tmp, tmp, result, ops);
    Build_OP(TOP_movnez, result, tmp, result, ops);
    return result;
  }

}
  break;
  case 326:
{
/* line 6311 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to unsigned MOD are constant");
    return Generate_Constant(MTYPE_U4, result, tn_equiv_const(tn2) % tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_U4, TOP_remu, result, tn2, tn3, ops);
  }

}
  break;
  case 327:
{
/* line 6327 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
			  
  return Generate_MINMAX( MTYPE_I4, TOP_max, OPR_GE, result,
			  tn2, tn3,
			  ops );

}
  break;
  case 328:
{
/* line 6338 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_MINMAX( MTYPE_U4, TOP_maxu, OPR_GE, result,
			  tn2, tn3,
			  ops );

}
  break;
  case 329:
{
/* line 6348 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_MINMAX( MTYPE_I4, TOP_min, OPR_LE, result,
			  tn2, tn3,
			  ops );

}
  break;
  case 330:
{
/* line 6358 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_MINMAX( MTYPE_U4, TOP_minu, OPR_LE, result,
			  tn2, tn3,
			  ops );

}
  break;
  case 331:
{
/* line 6374 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[0]->kids[0],0,ops);
  TN *imm = clamps_const_action(_s->kids[1]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 332:
{
/* line 6386 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[1]->kids[0],0,ops);
  TN *imm = clamps_const_action(_s->kids[0]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 333:
{
/* line 6398 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[0]->kids[1],0,ops);
  TN *imm = clamps_const_action(_s->kids[1]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 334:
{
/* line 6410 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[1]->kids[1],0,ops);
  TN *imm = clamps_const_action(_s->kids[0]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 335:
{
/* line 6422 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[0]->kids[0],0,ops);
  TN *imm = clamps_const_action(_s->kids[0]->kids[1]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 336:
{
/* line 6434 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[1]->kids[0],0,ops);
  TN *imm = clamps_const_action(_s->kids[1]->kids[1]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 337:
{
/* line 6446 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[0]->kids[1],0,ops);
  TN *imm = clamps_const_action(_s->kids[0]->kids[0]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 338:
{
/* line 6458 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[1]->kids[1],0,ops);
  TN *imm = clamps_const_action(_s->kids[1]->kids[0]);
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);

}
  break;
  case 339:
{
/* line 6468 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  if (xt_abs)
    return Generate_Unary( MTYPE_I4, TOP_abs, result,
			   areg_action(_s->kids[0],0,ops), ops );
  else {
    TN * value =  areg_action(_s->kids[0],0,ops);
    TN * neg = Generate_Unary( MTYPE_I4, TOP_neg, NULL,
			       value, ops );
    TN * cond = Generate_Cmov(MTYPE_I4, TOP_movgez, result, 
			      value, value, neg, ops);
    return cond;
  }
			      

}
  break;
  case 340:
{
/* line 6487 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Generate_Unary( MTYPE_I4, TOP_neg, result,
			  areg_action(_s->kids[0],0,ops), ops );

}
  break;
  case 341:
{
/* line 6493 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return Generate_Unary( MTYPE_U4, TOP_neg, result,
			  areg_action(_s->kids[0],0,ops), ops );

}
  break;
  case 356:
{
/* line 6701 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *fr = freg_action(_s->kids[0],0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("trunc.s"); 

  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_I4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_I4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;

}
  break;
  case 357:
{
/* line 6718 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *fr = freg_action(_s->kids[0],0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("trunc.s"); 

  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_I4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_I4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;

}
  break;
  case 358:
{
/* line 6735 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *fr = freg_action(_s->kids[0],0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("utrunc.s"); 

  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_U4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_U4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;

}
  break;
  case 359:
{
/* line 6752 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *fr = freg_action(_s->kids[0],0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("utrunc.s"); 
  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_U4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_U4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;

}
  break;
  case 360:
{
/* line 6770 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_LT, MTYPE_I4, result, l, r, ops);

}
  break;
  case 362:
{
/* line 6786 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_GT, MTYPE_I4, result, l, r, ops);

}
  break;
  case 364:
{
/* line 6802 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_LE, MTYPE_I4, result, l, r, ops);

}
  break;
  case 366:
{
/* line 6818 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_GE, MTYPE_I4, result, l, r, ops);

}
  break;
  case 368:
{
/* line 6834 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_EQ, MTYPE_I4, result, l, r, ops);

}
  break;
  case 370:
{
/* line 6850 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_NE, MTYPE_I4, result, l, r, ops);

}
  break;
  case 371:
{
/* line 6860 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_LT, MTYPE_U4, result, l, r, ops);

}
  break;
  case 373:
{
/* line 6876 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_GT, MTYPE_U4, result, l, r, ops);

}
  break;
  case 375:
{
/* line 6892 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_LE, MTYPE_U4, result, l, r, ops);

}
  break;
  case 377:
{
/* line 6908 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_GE, MTYPE_U4, result, l, r, ops);

}
  break;
  case 379:
{
/* line 6924 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_EQ, MTYPE_U4, result, l, r, ops);

}
  break;
  case 381:
{
/* line 6940 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison(OPR_NE, MTYPE_U4, result, l, r, ops);

}
  break;
  case 382:
{
/* line 6957 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Binary( MTYPE_I4, TOP_and, result,
			  tn2, tn3,
			  ops );

}
  break;
  case 383:
{
/* line 6967 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = extui_mask_action(_s->kids[1]);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_And_Immediate(MTYPE_I4, result,tn2, tn3, ops);

}
  break;
  case 384:
{
/* line 6975 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn2 = extui_mask_action(_s->kids[0]);
  TN * tn3 = areg_action(_s->kids[1],0,ops); 
  return Generate_And_Immediate(MTYPE_I4, result, tn3, tn2, ops);

}
  break;
  case 385:
{
/* line 6983 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Binary( MTYPE_U4, TOP_and, result, tn2, tn3, ops );

}
  break;
  case 386:
{
/* line 6991 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = extui_mask_action(_s->kids[1]);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_And_Immediate(MTYPE_U4, result, tn2, tn3, ops);

}
  break;
  case 387:
{
/* line 6999 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn2 = extui_mask_action(_s->kids[0]);
  TN * tn3 = areg_action(_s->kids[1],0,ops); 
  return Generate_And_Immediate(MTYPE_U4, result, tn3, tn2, ops);

}
  break;
  case 388:
{
/* line 7009 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Binary( MTYPE_I4, TOP_or, result, tn2, tn3,  ops );

}
  break;
  case 389:
{
/* line 7017 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Binary( MTYPE_U4, TOP_or, result, tn2, tn3, ops );

}
  break;
  case 390:
{
/* line 7035 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * left = areg_action(_s->kids[0]->kids[0],0,ops);
  TN * one = Generate_Constant( MTYPE_I4, NULL, 1, ops ); 
  return Generate_Binary( MTYPE_I4, TOP_addx2, result, left, one,  ops );

}
  break;
  case 391:
{
/* line 7047 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * left = areg_action(_s->kids[0]->kids[0],0,ops);
  TN * one = Generate_Constant( MTYPE_U4, NULL, 1, ops ); 
  return Generate_Binary( MTYPE_U4, TOP_addx2, result, left, one,  ops );

}
  break;
  case 392:
{
/* line 7057 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Binary( MTYPE_I4, TOP_xor, result, tn2, tn3, ops );

}
  break;
  case 393:
{
/* line 7065 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
   
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Binary( MTYPE_U4, TOP_xor, result, tn2, tn3, ops );

}
  break;
  case 394:
{
/* line 7075 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *tmp = Generate_Constant(MTYPE_I4, NULL, -1, ops);
    
  return Generate_Binary( MTYPE_I4, TOP_xor, result,
			  areg_action(_s->kids[0],0,ops), tmp, ops );

}
  break;
  case 395:
{
/* line 7084 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *tmp = Generate_Constant(MTYPE_I4, NULL, -1, ops);

  return Generate_Binary( MTYPE_U4, TOP_xor, result,
			  areg_action(_s->kids[0],0,ops), tmp, ops );

}
  break;
  case 396:
{
/* line 7095 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *tmp = Generate_Constant(MTYPE_I4, NULL, 1, ops);

  /* Get the source tn. We must copy it to a temporary tn if 'src' ==
     'result' since we clobber 'result' before using 'src'. */
  TN *src = areg_action(_s->kids[0],0,ops);
  if (src == result)
    src = Move_To_Register(MTYPE_I4,Build_TN_Of_Mtype(MTYPE_I4), src, ops);
  
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  result = Generate_Constant(MTYPE_I4, result, 0, ops);
  Build_OP(TOP_moveqz, result, result, tmp, src, ops );
  return result;

}
  break;
  case 397:
{
/* line 7113 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *tmp = Generate_Constant(MTYPE_U4, NULL, 1, ops);

  /* Get the source tn. We must copy it to a temporary tn if 'src' ==
     'result' since we clobber 'result' before using 'src'. */
  TN *src = areg_action(_s->kids[0],0,ops);
  if (src == result)
    src = Move_To_Register(MTYPE_U4, Build_TN_Of_Mtype(MTYPE_U4), src, ops);
  
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  result = Generate_Constant(MTYPE_U4, result, 0, ops);
  Build_OP(TOP_moveqz, result, result, tmp, src, ops );
  return result;

}
  break;
  case 398:
{
/* line 7140 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = msalp32_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_slli, result, left, right, ops );
  return result;

}
  break;
  case 399:
{
/* line 7151 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = msalp32_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_slli, result, left, right, ops );
  return result;

}
  break;
  case 400:
{
/* line 7162 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = uimm5_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_srai, result, left, right, ops );
  return result;

}
  break;
  case 401:
{
/* line 7173 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = uimm5_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_srai, result, left, right, ops );
  return result;

}
  break;
  case 402:
{
/* line 7184 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = uimm4_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_srli, result, left, right, ops );
  return result;

}
  break;
  case 403:
{
/* line 7195 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = uimm4_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_srli, result, left, right, ops );
  return result;

}
  break;
  case 404:
{
/* line 7206 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = uimm5_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP(TOP_extui, result, left, right, Gen_Literal_TN(32-TN_value(right),4), ops);
  return result;

}
  break;
  case 405:
{
/* line 7217 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = uimm5_action(_s->kids[1]);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_extui, result, left, right, Gen_Literal_TN(32-TN_value(right),4), ops);
  return result;

}
  break;
  case 406:
{
/* line 7229 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = sar_left_action(_s->kids[1],ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_sll, result, left, right, ops );
  return result;

}
  break;
  case 407:
{
/* line 7240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = sar_left_action(_s->kids[1],ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_sll, result, left, right, ops );
  return result;

}
  break;
  case 408:
{
/* line 7251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = sar_right_action(_s->kids[1],ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_sra, result, left, right, ops );
  return result;

}
  break;
  case 409:
{
/* line 7262 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = sar_right_action(_s->kids[1],ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_sra, result, left, right, ops );
  return result;

}
  break;
  case 410:
{
/* line 7273 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = sar_right_action(_s->kids[1],ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_srl, result, left, right, ops );
  return result;

}
  break;
  case 411:
{
/* line 7284 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0],0,ops);
  TN *right = sar_right_action(_s->kids[1],ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_srl, result, left, right, ops );
  return result;

}
  break;
  case 412:
{
/* line 7313 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

    TN *left  = areg_action(_s->kids[1]->kids[0],0,ops);
    TN *right = areg_action(_s->kids[0]->kids[0],0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = wsar_action(_s->kids[0]->kids[1],ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;

}
  break;
  case 413:
{
/* line 7342 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

    TN *left  = areg_action(_s->kids[1]->kids[0],0,ops);
    TN *right = areg_action(_s->kids[0]->kids[0],0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = wsar_action(_s->kids[0]->kids[1],ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;

}
  break;
  case 414:
{
/* line 7371 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

    TN *left  = areg_action(_s->kids[0]->kids[0],0,ops);
    TN *right = areg_action(_s->kids[1]->kids[0],0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = wsar_action(_s->kids[1]->kids[1],ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;

}
  break;
  case 415:
{
/* line 7400 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

    TN *left  = areg_action(_s->kids[0]->kids[0],0,ops);
    TN *right = areg_action(_s->kids[1]->kids[0],0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = wsar_action(_s->kids[1]->kids[1],ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;

}
  break;
  case 416:
{
/* line 7423 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[1]->kids[0],0,ops);
  TN *right = areg_action(_s->kids[0],0,ops);
  TN *shift = msalp32_action(_s->kids[1]->kids[1]);
  return Generate_AddShift(_s->node, MTYPE_I4, result, left, right, shift, ops);

}
  break;
  case 417:
{
/* line 7437 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0]->kids[0],0,ops);
  TN *right = areg_action(_s->kids[1],0,ops);
  TN *shift = msalp32_action(_s->kids[0]->kids[1]);
  return Generate_AddShift(_s->node, MTYPE_I4, result, left, right, shift, ops);

}
  break;
  case 418:
{
/* line 7451 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[1]->kids[0],0,ops);
  TN *right = areg_action(_s->kids[0],0,ops);
  TN *shift = msalp32_action(_s->kids[1]->kids[1]);
  return Generate_AddShift(_s->node, MTYPE_U4, result, left, right, shift, ops);

}
  break;
  case 419:
{
/* line 7465 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0]->kids[0],0,ops);
  TN *right = areg_action(_s->kids[1],0,ops);
  TN *shift = msalp32_action(_s->kids[0]->kids[1]);
  return Generate_AddShift(_s->node, MTYPE_U4, result, left, right, shift, ops);

}
  break;
  case 420:
{
/* line 7479 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0]->kids[0],0,ops);
  TN *right = areg_action(_s->kids[1],0,ops);
  TN *shift = msalp32_action(_s->kids[0]->kids[1]);
  return Generate_SubShift(_s->node, MTYPE_I4, result, left, right, shift, ops);

}
  break;
  case 421:
{
/* line 7493 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *left = areg_action(_s->kids[0]->kids[0],0,ops);
  TN *right = areg_action(_s->kids[1],0,ops);
  TN *shift = msalp32_action(_s->kids[0]->kids[1]);
  return Generate_SubShift(_s->node, MTYPE_U4, result, left, right, shift, ops);

}
  break;
  case 430:
{
/* line 7631 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Compose(_s->node, MTYPE_I4, MTYPE_I4, result, tn2, tn3, ops);

}
  break;
  case 431:
{
/* line 7639 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_Compose(_s->node, MTYPE_U4, MTYPE_U4, result, tn2, tn3, ops);

}
  break;
  case 432:
{
/* line 7649 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_I4, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 433:
{
/* line 7655 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_U4, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 434:
{
/* line 7663 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st(_s->node), WN_store_offset(_s->node));
  return Generate_Compose(_s->node, Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4),
			  MTYPE_U4, result, result, areg_action(_s->kids[0],0, ops), ops); 

}
  break;
  case 435:
{
/* line 7672 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st(_s->node), WN_store_offset(_s->node));
  return Generate_Compose(_s->node, Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4),
			  MTYPE_U2, result, result, areg_action(_s->kids[0],0, ops), ops); 

}
  break;
  case 436:
{
/* line 7681 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st(_s->node), WN_store_offset(_s->node));
  return Generate_Compose(_s->node, Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4),
			  MTYPE_U1, result, result, areg_action(_s->kids[0],0, ops), ops); 

}
  break;
  case 437:
{
/* line 7690 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st(_s->node), WN_store_offset(_s->node));
  return Generate_Compose(_s->node, Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4),
			  MTYPE_U4, result, result, areg_action(_s->kids[0],0, ops), ops); 

}
  break;
  case 438:
{
/* line 7699 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st(_s->node), WN_store_offset(_s->node));
  return Generate_Compose(_s->node, Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4),
			  MTYPE_U2, result, result, areg_action(_s->kids[0],0, ops), ops); 

}
  break;
  case 439:
{
/* line 7708 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st(_s->node), WN_store_offset(_s->node));
  return Generate_Compose(_s->node, Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4),
			  MTYPE_U1, result, result, areg_action(_s->kids[0],0, ops), ops); 

}
  break;
  case 440:
{
/* line 7717 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory(_s->node, rtype, MTYPE_U4, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  TN *comped = Generate_Compose(_s->node, rtype, MTYPE_U4, 0, src_tn, areg_action(_s->kids[0],0, ops), ops);
  Generate_Store_Memory(_s->node, MTYPE_U4, comped, WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  return comped;

}
  break;
  case 441:
{
/* line 7729 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory(_s->node, rtype, MTYPE_U2, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  TN *comped = Generate_Compose(_s->node, rtype, MTYPE_U2, 0, src_tn, areg_action(_s->kids[0],0, ops), ops);
  Generate_Store_Memory(_s->node, MTYPE_U2, comped, WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  return comped;

}
  break;
  case 442:
{
/* line 7741 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory(_s->node, rtype, MTYPE_U1, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  TN *comped = Generate_Compose(_s->node, rtype, MTYPE_U1, 0, src_tn, areg_action(_s->kids[0],0, ops), ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, comped, WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  return comped;

}
  break;
  case 443:
{
/* line 7753 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory(_s->node, rtype, MTYPE_U4, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  TN *comped = Generate_Compose(_s->node, rtype, MTYPE_U4, 0, src_tn, areg_action(_s->kids[0],0, ops), ops);
  Generate_Store_Memory(_s->node, MTYPE_U4, comped, WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  return comped;

}
  break;
  case 444:
{
/* line 7765 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory(_s->node, rtype, MTYPE_U2, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  TN *comped = Generate_Compose(_s->node, rtype, MTYPE_U2, 0, src_tn, areg_action(_s->kids[0],0, ops), ops);
  Generate_Store_Memory(_s->node, MTYPE_U2, comped, WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  return comped;

}
  break;
  case 445:
{
/* line 7777 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0(_s->node)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory(_s->node, rtype, MTYPE_U1, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  TN *comped = Generate_Compose(_s->node, rtype, MTYPE_U1, 0, src_tn, areg_action(_s->kids[0],0, ops), ops);
  Generate_Store_Memory(_s->node, MTYPE_U1, comped, WN_st(_s->node), WN_load_offset(_s->node), Variant_STID(_s->node), ops);
  return comped;

}
  break;
  case 446:
{
/* line 7791 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits(_s->node, MTYPE_U4, MTYPE_U4, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 447:
{
/* line 7798 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits(_s->node, MTYPE_U2, MTYPE_U2, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 448:
{
/* line 7805 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits(_s->node, MTYPE_U1, MTYPE_U1, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 449:
{
/* line 7812 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits(_s->node, MTYPE_U4, MTYPE_U4, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 450:
{
/* line 7819 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits(_s->node, MTYPE_U2, MTYPE_U2, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 451:
{
/* line 7826 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits(_s->node, MTYPE_U1, MTYPE_U1, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 452:
{
/* line 7833 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2  =areg_action(_s->kids[0],0,ops); 
  return Generate_IStore_Bits(_s->node, MTYPE_U4, MTYPE_U4,
			      tn2, tn3, ops);

}
  break;
  case 453:
{
/* line 7843 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_IStore_Bits(_s->node, MTYPE_U2, MTYPE_U2,
			      tn2, tn3, ops);

}
  break;
  case 454:
{
/* line 7853 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_IStore_Bits(_s->node, MTYPE_U1, MTYPE_U1,
			      tn2, tn3, ops);

}
  break;
  case 455:
{
/* line 7863 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_IStore_Bits(_s->node, MTYPE_U4, MTYPE_U4,
			      tn2, tn3, ops);

}
  break;
  case 456:
{
/* line 7873 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_IStore_Bits(_s->node, MTYPE_U2, MTYPE_U2,
			      tn2, tn3, ops);

}
  break;
  case 457:
{
/* line 7883 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = areg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops); 
  return Generate_IStore_Bits(_s->node, MTYPE_U1, MTYPE_U1,
			      tn2, tn3, ops);

}
  break;
  case 458:
{
/* line 7895 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 459:
{
/* line 7902 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 460:
{
/* line 7909 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 461:
{
/* line 7916 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 462:
{
/* line 7923 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 463:
{
/* line 7930 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 464:
{
/* line 7937 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 465:
{
/* line 7944 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 466:
{
/* line 7951 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 467:
{
/* line 7958 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 468:
{
/* line 7965 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 469:
{
/* line 7972 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = PREG_To_TN(WN_st(_s->node), WN_load_offset(_s->node));
  return Generate_Extract(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result, src_tn, ops);

}
  break;
  case 470:
{
/* line 7979 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U4, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_U4, result, src_tn, ops);

}
  break;
  case 471:
{
/* line 7987 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U2, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_U4, result, src_tn, ops);

}
  break;
  case 472:
{
/* line 7995 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_U4, result, src_tn, ops);

}
  break;
  case 473:
{
/* line 8003 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I4, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_I4, result, src_tn, ops);

}
  break;
  case 474:
{
/* line 8011 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I2, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_I4, result, src_tn, ops);

}
  break;
  case 475:
{
/* line 8019 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  /* Load as unsigned and let Generate_Extract do the sign extension. */
  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_U4, MTYPE_I1, result, src_tn, ops);

}
  break;
  case 476:
{
/* line 8028 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U4, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_U4, result, src_tn, ops);

}
  break;
  case 477:
{
/* line 8036 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U2, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_U4, result, src_tn, ops);

}
  break;
  case 478:
{
/* line 8044 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_U4, result, src_tn, ops);

}
  break;
  case 479:
{
/* line 8052 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I4, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_I4, result, src_tn, ops);

}
  break;
  case 480:
{
/* line 8060 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_I4, MTYPE_I2, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_I4, result, src_tn, ops);

}
  break;
  case 481:
{
/* line 8068 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  /* Load as unsigned and let Generate_Extract do the sign extension. */
  TN *src_tn = Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, 0,
				    WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);
  return Generate_Extract(_s->node, MTYPE_I4, MTYPE_I1, result, src_tn, ops);

}
  break;
  case 482:
{
/* line 8079 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_U4, MTYPE_U4, result, ops);

}
  break;
  case 483:
{
/* line 8085 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_U4, MTYPE_U2, result, ops);

}
  break;
  case 484:
{
/* line 8091 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_U4, MTYPE_U1, result, ops);

}
  break;
  case 485:
{
/* line 8097 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_U4, MTYPE_I4, result, ops);

}
  break;
  case 486:
{
/* line 8103 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_U4, MTYPE_I2, result, ops);

}
  break;
  case 487:
{
/* line 8109 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_U4, MTYPE_I1, result, ops);

}
  break;
  case 488:
{
/* line 8115 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_I4, MTYPE_U4, result, ops);

}
  break;
  case 489:
{
/* line 8121 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_I4, MTYPE_U2, result, ops);

}
  break;
  case 490:
{
/* line 8127 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_I4, MTYPE_U1, result, ops);

}
  break;
  case 491:
{
/* line 8133 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_I4, MTYPE_I4, result, ops);

}
  break;
  case 492:
{
/* line 8139 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_I4, MTYPE_I2, result, ops);

}
  break;
  case 493:
{
/* line 8145 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoadLda_Bits(_s->node, MTYPE_I4, MTYPE_I1, result, ops);

}
  break;
  case 494:
{
/* line 8151 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_U4, MTYPE_U4, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 495:
{
/* line 8157 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_U4, MTYPE_U2, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 496:
{
/* line 8163 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_U4, MTYPE_U1, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 497:
{
/* line 8169 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_U4, MTYPE_I4, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 498:
{
/* line 8175 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_U4, MTYPE_I2, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 499:
{
/* line 8181 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_U4, MTYPE_I1, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 500:
{
/* line 8187 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_I4, MTYPE_U4, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 501:
{
/* line 8193 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_I4, MTYPE_U2, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 502:
{
/* line 8199 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_I4, MTYPE_U1, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 503:
{
/* line 8205 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_I4, MTYPE_I4, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 504:
{
/* line 8211 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_I4, MTYPE_I2, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 505:
{
/* line 8217 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_ILoad_Bits(_s->node, MTYPE_I4, MTYPE_I1, result, areg_action(_s->kids[0],0, ops), ops);

}
  break;
  case 506:
{
/* line 8230 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Extend(MTYPE_U4, result, areg_action(_s->kids[0],0,ops),
			 WN_cvtl_bits(_s->node), ops);

}
  break;
  case 507:
{
/* line 8237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Extend(MTYPE_I4, result, areg_action(_s->kids[0],0,ops),
			 WN_cvtl_bits(_s->node), ops);

}
  break;
  case 508:
{
/* line 8246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s->kids[0],result,ops);

}
  break;
  case 509:
{
/* line 8252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s->kids[0],result,ops);

}
  break;
  case 510:
{
/* line 8265 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s->kids[0],result, ops);

}
  break;
  case 511:
{
/* line 8271 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s->kids[0],result, ops);

}
  break;
  case 515:
{
/* line 8331 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 519:
{
/* line 8363 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
  {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  acc_reg_action(_s,0, ops);
  Build_OP(TI_TOP_Topcode("rsr.acclo"), result, accum_tn(), ops );
  return result;

}
  break;
  case 522:
{
/* line 8403 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  TN *fr = freg_action(_s,0, ops);
  result = Generate_Unary_FP(MTYPE_I4, TI_TOP_Topcode("rfr"), result, fr, ops);
  return result;

}
  break;
  case 523:
{
/* line 8419 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *val = simm12_action(_s);
  return Generate_Constant(MTYPE_I4, result, TN_value(val), ops);

}
  break;
  case 524:
{
/* line 8426 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *val = simm32_action(_s);
  return Generate_Constant(MTYPE_I4, result, TN_value(val), ops);

}
  break;
  case 525:
{
/* line 8433 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  INT32 val = float_const_action(_s);
  if (result && xt_hard_float && TN_register_class(result)==TI_ISA_Regclass_Float()) {

    // destination is a floating point register

    TN *tmp = Build_TN_Of_Mtype(MTYPE_U4);
    tmp = Generate_Constant(MTYPE_U4, tmp, val, ops);

    result = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), result, tmp, ops);
    return result;
  } else 
    return Generate_Constant(MTYPE_U4, result, val, ops);

}
  break;
  case 673:
{
/* line 10296 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 674:
{
/* line 10308 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 675:
{
/* line 10320 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 676:
{
/* line 10332 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 677:
{
/* line 10344 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 683:
{
/* line 10421 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 684:
{
/* line 10433 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 685:
{
/* line 10445 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 686:
{
/* line 10457 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  case 687:
{
/* line 10469 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = bareg_action(_s->kids[0],0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._areg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule areg"));
  /*NOTREACHED*/
}
/* line 2237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * breg_action(ISEL::State *_s, /* line 2237 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::breg_NT))
    NO_ACTION(breg);
  _ern = _s->matches[ISEL::breg_NT].rule_num;
  switch(_ern){
  case 235:
{
/* line 4911 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(WN_rtype(WN_kid(_s->node,1))==MTYPE_XTBOOL, ("Expecting xtbool type"));
  FmtAssert(WN_rtype(WN_kid(_s->node,2))==MTYPE_XTBOOL, ("Expecting xtbool type"));
  TYPE_ID rtype = MTYPE_XTBOOL;
  TYPE_ID desc = WN_desc(WN_kid0(_s->node));
  TN * tn_false = breg_action(_s->kids[2],0,ops);
  TN * tn_true = breg_action(_s->kids[1],0,ops);
  TN * l = areg_action(_s->kids[0],0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);

}
  break;
  case 236:
{
/* line 4926 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(WN_rtype(WN_kid(_s->node,1))==MTYPE_XTBOOL2, ("Expecting xtbool2 type"));
  FmtAssert(WN_rtype(WN_kid(_s->node,2))==MTYPE_XTBOOL2, ("Expecting xtbool2 type"));
  TYPE_ID rtype = MTYPE_XTBOOL2;
  TYPE_ID desc = WN_desc(WN_kid0(_s->node));
  TN * tn_false = breg_action(_s->kids[2],0,ops);
  TN * tn_true = breg_action(_s->kids[1],0,ops);
  TN * l = areg_action(_s->kids[0],0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);

}
  break;
  case 237:
{
/* line 4941 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(WN_rtype(WN_kid(_s->node,1))==MTYPE_XTBOOL4, ("Expecting xtbool4 type"));
  FmtAssert(WN_rtype(WN_kid(_s->node,2))==MTYPE_XTBOOL4, ("Expecting xtbool4 type"));
  TYPE_ID rtype = MTYPE_XTBOOL4;
  TYPE_ID desc = WN_desc(WN_kid0(_s->node));
  TN * tn_false = breg_action(_s->kids[2],0,ops);
  TN * tn_true = breg_action(_s->kids[1],0,ops);
  TN * l = areg_action(_s->kids[0],0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);

}
  break;
  case 238:
{
/* line 4956 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(WN_rtype(WN_kid(_s->node,1))==MTYPE_XTBOOL8, ("Expecting xtbool8 type"));
  FmtAssert(WN_rtype(WN_kid(_s->node,2))==MTYPE_XTBOOL8, ("Expecting xtbool8 type"));
  TYPE_ID rtype = MTYPE_XTBOOL8;
  TYPE_ID desc = WN_desc(WN_kid0(_s->node));
  TN * tn_false = breg_action(_s->kids[2],0,ops);
  TN * tn_true = breg_action(_s->kids[1],0,ops);
  TN * l = areg_action(_s->kids[0],0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);

}
  break;
  case 239:
{
/* line 4971 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(WN_rtype(WN_kid(_s->node,1))==MTYPE_XTBOOL16, ("Expecting xtbool16 type"));
  FmtAssert(WN_rtype(WN_kid(_s->node,2))==MTYPE_XTBOOL16, ("Expecting xtbool16 type"));
  TYPE_ID rtype = MTYPE_XTBOOL16;
  TYPE_ID desc = WN_desc(WN_kid0(_s->node));
  TN * tn_false = breg_action(_s->kids[2],0,ops);
  TN * tn_true = breg_action(_s->kids[1],0,ops);
  TN * l = areg_action(_s->kids[0],0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);

}
  break;
  case 517:
{
/* line 8339 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 609:
{
/* line 9372 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_XTBOOL2,result,PREG_To_TN(s,o),ops);

}
  break;
  case 610:
{
/* line 9381 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_XTBOOL4,result,PREG_To_TN(s,o),ops);

}
  break;
  case 611:
{
/* line 9390 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_XTBOOL8,result,PREG_To_TN(s,o),ops);

}
  break;
  case 612:
{
/* line 9399 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_XTBOOL16,result,PREG_To_TN(s,o),ops);

}
  break;
  case 613:
{
/* line 9416 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 614:
{
/* line 9430 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 615:
{
/* line 9444 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 616:
{
/* line 9458 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 617:
{
/* line 9472 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 625:
{
/* line 9556 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  result = b1reg_action(_s,result, ops);
  return result;

}
  break;
  case 627:
{
/* line 9583 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *ar = bareg_action(_s,0, ops);
  TYPE_ID rtype = WN_rtype(_s->node);
  if( !result )
    result = Build_TN_Of_Mtype(rtype);
  else
    FmtAssert(TN_mtype(result)==rtype, ("xtbool type mismatch"));
  TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
  TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_get_tmp_ar, tmp1, ops );
  Build_OP(TOP_get_tmp_ar, tmp2, ops );
  TOP top = (rtype == MTYPE_XTBOOL) ? TOP_ar_to_br :
		(rtype == MTYPE_XTBOOL2) ? TOP_ar_to_br2 :
		(rtype == MTYPE_XTBOOL4) ? TOP_ar_to_br4 :
		(rtype == MTYPE_XTBOOL8) ? TOP_ar_to_br8 :
		(rtype == MTYPE_XTBOOL16) ? TOP_ar_to_br16 : TOP_UNDEFINED;
  FmtAssert(top!=TOP_UNDEFINED,("Unknown rtype"));
  Build_OP(top, result, ar, tmp1, tmp2, ops );
  return result;

}
  break;
  case 648:
{
/* line 10001 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 649:
{
/* line 10014 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 650:
{
/* line 10027 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 651:
{
/* line 10040 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 652:
{
/* line 10053 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, WN_rtype(_s->node), WN_desc(_s->node), result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._breg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule breg"));
  /*NOTREACHED*/
}
/* line 2238 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * bareg_action(ISEL::State *_s, /* line 2238 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::bareg_NT))
    NO_ACTION(bareg);
  _ern = _s->matches[ISEL::bareg_NT].rule_num;
  switch(_ern){
  case 619:
{
/* line 9495 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 620:
{
/* line 9503 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 621:
{
/* line 9511 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 622:
{
/* line 9519 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 623:
{
/* line 9527 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U2, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 624:
{
/* line 9535 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *br = breg_action(_s,0, ops);
  if( !result )
    result = Build_TN_Of_Mtype(MTYPE_U4);
  TYPE_ID rtype = TN_mtype(br);
  TOP top = (rtype == MTYPE_XTBOOL) ? TOP_br_to_ar :
	    (rtype == MTYPE_XTBOOL2) ? TOP_br2_to_ar :
	    (rtype == MTYPE_XTBOOL4) ? TOP_br4_to_ar :
	    (rtype == MTYPE_XTBOOL8) ? TOP_br8_to_ar :
	    (rtype == MTYPE_XTBOOL16) ? TOP_br16_to_ar : TOP_UNDEFINED;
  FmtAssert(top!=TOP_UNDEFINED,("Unknown rtype"));
  Build_OP(top, result, br, ops );
  return result;

}
  break;
  case 653:
{
/* line 10062 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 654:
{
/* line 10069 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 655:
{
/* line 10076 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 656:
{
/* line 10083 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U1, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 657:
{
/* line 10090 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Generate_Load_Memory(_s->node, MTYPE_U4, MTYPE_U2, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 668:
{
/* line 10231 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 1;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 669:
{
/* line 10244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 2;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 670:
{
/* line 10257 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 4;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 671:
{
/* line 10270 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 8;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 672:
{
/* line 10283 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 16;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 678:
{
/* line 10356 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 1;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 679:
{
/* line 10369 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 2;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 680:
{
/* line 10382 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 4;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 681:
{
/* line 10395 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 8;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  case 682:
{
/* line 10408 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = areg_action(_s->kids[0],0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 16;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._bareg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule bareg"));
  /*NOTREACHED*/
}
/* line 2239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * b1reg_action(ISEL::State *_s, /* line 2239 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::b1reg_NT))
    NO_ACTION(b1reg);
  _ern = _s->matches[ISEL::b1reg_NT].rule_num;
  switch(_ern){
  case 361:
{
/* line 6778 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, l, r, ops);

}
  break;
  case 363:
{
/* line 6794 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, r, l, ops);

}
  break;
  case 365:
{
/* line 6810 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, l, r, ops);

}
  break;
  case 367:
{
/* line 6826 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, r, l, ops);

}
  break;
  case 369:
{
/* line 6842 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);

}
  break;
  case 372:
{
/* line 6868 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, l, r, ops);

}
  break;
  case 374:
{
/* line 6884 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, r, l, ops);

}
  break;
  case 376:
{
/* line 6900 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, l, r, ops);

}
  break;
  case 378:
{
/* line 6916 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, r, l, ops);

}
  break;
  case 380:
{
/* line 6932 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *r = freg_action(_s->kids[1],0,ops);
  TN *l = freg_action(_s->kids[0],0,ops);
  return Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);

}
  break;
  case 608:
{
/* line 9363 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  return Move_To_Register(MTYPE_XTBOOL,result,PREG_To_TN(s,o),ops);

}
  break;
  case 618:
{
/* line 9480 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* val = b1reg_action(_s->kids[0],0,ops);
  if (!result) {
    result = val;
  } else {
    Build_OP(TOP_movbr, result, val, ops);
  }
  return result;

}
  break;
  case 626:
{
/* line 9567 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *ar = bareg_action(_s,0, ops);
  if( !result )
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
  TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_get_tmp_ar, tmp1, ops );
  Build_OP(TOP_get_tmp_ar, tmp2, ops );
  Build_OP(TOP_ar_to_br, result, ar, tmp1, tmp2, ops );
  return result;

}
  break;
  case 688:
{
/* line 10487 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_andb, result, tn3, tn5, ops );
  return result;

}
  break;
  case 689:
{
/* line 10498 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn6 = b1reg_action(_s->kids[1]->kids[0]->kids[0],0,ops);
  Build_OP(TOP_andbc, result, tn3, tn6, ops );
  return result;

}
  break;
  case 690:
{
/* line 10509 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_andbc, result, tn3, tn5, ops );
  return result;

}
  break;
  case 691:
{
/* line 10520 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn4 = b1reg_action(_s->kids[0]->kids[0]->kids[0],0,ops); 
  TN * tn6 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_andbc, result, tn6, tn4, ops );
  return result;

}
  break;
  case 692:
{
/* line 10531 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_andbc, result, tn5, tn3, ops );
  return result;

}
  break;
  case 693:
{
/* line 10542 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_orb, result, tn3, tn5, ops );
  return result;

}
  break;
  case 694:
{
/* line 10553 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn6 = b1reg_action(_s->kids[1]->kids[0]->kids[0],0,ops);
  Build_OP(TOP_orbc, result, tn3, tn6, ops );
  return result;

}
  break;
  case 695:
{
/* line 10564 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_orbc, result, tn3, tn5, ops );
  return result;

}
  break;
  case 696:
{
/* line 10575 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn4 = b1reg_action(_s->kids[0]->kids[0]->kids[0],0,ops); 
  TN * tn6 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_orbc, result, tn6, tn4, ops );
  return result;

}
  break;
  case 697:
{
/* line 10586 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops); 
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops);
  Build_OP(TOP_orbc, result, tn5, tn3, ops );
  return result;

}
  break;
  case 698:
{
/* line 10597 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  TN * tn5 = b1reg_action(_s->kids[1]->kids[0],0,ops); 
  Build_OP(TOP_xorb, result, tn3, tn5, ops );
  return result;

}
  break;
  case 699:
{
/* line 10608 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* zero = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* br = b1reg_action(_s->kids[0]->kids[0],0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  Build_OP(TOP_orbc, zero, br, br, ops );
  Build_OP(TOP_xorb, result, br, zero, ops );
  return result;

}
  break;
  case 700:
{
/* line 10620 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN* zero = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* br = b1reg_action(_s->kids[0],0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  Build_OP(TOP_orbc, zero, br, br, ops );
  Build_OP(TOP_xorb, result, br, zero, ops );
  return result;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._b1reg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule b1reg"));
  /*NOTREACHED*/
}
/* line 2240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * freg_action(ISEL::State *_s, /* line 2240 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::freg_NT))
    NO_ACTION(freg);
  _ern = _s->matches[ISEL::freg_NT].rule_num;
  switch(_ern){
  case 177:
{
/* line 4125 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = freg_action(_s->kids[2],0,ops);
  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = areg_action(_s->kids[0],0,ops);
  TOP cmov = TI_TOP_Topcode("movnez.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, tn2, tn3, tn4, ops);

}
  break;
  case 229:
{
/* line 4851 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = freg_action(_s->kids[2],0,ops);
  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = b1reg_action(_s->kids[0],0,ops);
  TOP cmov = TI_TOP_Topcode("movt.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, tn2, tn3, tn4, ops);

}
  break;
  case 233:
{
/* line 4888 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn5 = freg_action(_s->kids[2],0,ops);
  TN * tn4 = freg_action(_s->kids[1],0,ops);
  TN * tn3 = b1reg_action(_s->kids[0]->kids[0],0,ops);
  TOP cmov = TI_TOP_Topcode("movf.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, tn3, tn4, tn5, ops);

}
  break;
  case 234:
{
/* line 4898 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn6 = freg_action(_s->kids[2],0,ops);
  TN * tn5 = freg_action(_s->kids[1],0,ops);
  TN * tn4 = freg_action(_s->kids[0]->kids[1],0,ops);
  TN * tn3 = freg_action(_s->kids[0]->kids[0],0,ops);
  
  TN *boolean_cond = Generate_FP_Comparison_br(OPR_EQ, 0, tn3, tn4, ops);
  TOP cmov = TI_TOP_Topcode("movf.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, boolean_cond, tn5, tn6, ops);

}
  break;
  case 277:
{
/* line 5370 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o = WN_load_offset(_s->node);
  TN *val = PREG_To_TN(s, o);
  return Move_To_Register(MTYPE_F4, result, val, ops);

}
  break;
  case 285:
{
/* line 5439 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_F4);
  Check_For_Dedicated_Preg(_s->node);
  return Generate_Load_Memory(_s->node, mtype, mtype, result,
			      WN_st(_s->node), WN_load_offset(_s->node), Variant_LDID(_s->node), ops);

}
  break;
  case 293:
{
/* line 5503 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_F4);
  return Generate_Load_Memory(_s->node, mtype, mtype, result,
			      areg_action(_s->kids[0],0,ops), WN_offset(_s->node), Variant_ILOAD(_s->node), ops);

}
  break;
  case 342:
{
/* line 6508 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TOP add_s = TI_TOP_Topcode("add.s");
  return Generate_Binary_FP(MTYPE_F4, add_s, result, tn2, tn3, true, ops);

}
  break;
  case 343:
{
/* line 6519 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TOP sub_s = TI_TOP_Topcode("sub.s");
  return Generate_Binary_FP(MTYPE_F4, sub_s, result, tn2, tn3, true, ops);

}
  break;
  case 344:
{
/* line 6530 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TOP mul_s = TI_TOP_Topcode("mul.s");
  return Generate_Binary_FP(MTYPE_F4, mul_s, result, tn2, tn3, true, ops);

}
  break;
  case 345:
{
/* line 6542 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TOP div_s = TI_TOP_Topcode("div.s");
  return Generate_Binary_FP(MTYPE_F4, div_s, result, tn2, tn3, true, ops);

}
  break;
  case 346:
{
/* line 6553 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = freg_action(_s->kids[2],0,ops);
  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TN *tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP madd_s = TI_TOP_Topcode("madd.s");
  TN* state4 = cpenable_tn(madd_s);
  if (state4)
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);

  if (result == NULL) {
    result = tmp;
  } else {
    result = Move_To_Register(MTYPE_F4, result, tmp, ops);
  }
  return result;

}
  break;
  case 347:
{
/* line 6576 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = freg_action(_s->kids[2],0,ops);
  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TN * tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP madd_s = TI_TOP_Topcode("madd.s");
  TN* state4 = cpenable_tn(madd_s);
  if (state4)
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);
  TOP neg_s = TI_TOP_Topcode("neg.s"); 
  return Generate_Unary_FP(MTYPE_F4, neg_s, result, tmp, ops );

}
  break;
  case 348:
{
/* line 6596 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = freg_action(_s->kids[2],0,ops);
  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TN *tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP msub_s = TI_TOP_Topcode("msub.s");
  TN* state4 = cpenable_tn(msub_s);
  if (state4)
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);

  if (result == NULL) {
    result = tmp;
  } else {
    result = Move_To_Register(MTYPE_F4, result, tmp, ops);
  }
  return result;

}
  break;
  case 349:
{
/* line 6619 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN * tn4 = freg_action(_s->kids[2],0,ops);
  TN * tn3 = freg_action(_s->kids[1],0,ops);
  TN * tn2 = freg_action(_s->kids[0],0,ops); 
  TN * tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP msub_s = TI_TOP_Topcode("msub.s");
  TN* state4 = cpenable_tn(msub_s);
  if (state4)
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);
  TOP neg_s = TI_TOP_Topcode("neg.s"); 
  return Generate_Unary_FP(MTYPE_F4, neg_s, result, tmp, ops );

}
  break;
  case 350:
{
/* line 6639 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TOP abs_s = TI_TOP_Topcode("abs.s"); 
  return Generate_Unary_FP(MTYPE_F4, abs_s, result, freg_action(_s->kids[0],0,ops), ops );

}
  break;
  case 351:
{
/* line 6648 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TOP neg_s = TI_TOP_Topcode("neg.s"); 
  return Generate_Unary_FP(MTYPE_F4, neg_s, result, freg_action(_s->kids[0],0,ops), ops );

}
  break;
  case 352:
{
/* line 6657 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TOP recip_s = TI_TOP_Topcode("recip.s"); 
  return Generate_Unary_FP(MTYPE_F4, recip_s, result, freg_action(_s->kids[0],0, ops), ops );

}
  break;
  case 353:
{
/* line 6666 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TOP rsqrt_s = TI_TOP_Topcode("rsqrt.s"); 
  return Generate_Unary_FP(MTYPE_F4, rsqrt_s, result, freg_action(_s->kids[0],0, ops), ops );

}
  break;
  case 354:
{
/* line 6675 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[0],0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP float_s = TI_TOP_Topcode("float.s"); 
  /* Move the data from AR into the FP regfile first if necessary. */
  if (!tie_info->xtfloat_ar_converts())
    src = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), NULL, src, ops);
  return Generate_Binary_FP(MTYPE_F4, float_s, result, src, zero_tn, true, ops);

}
  break;
  case 355:
{
/* line 6687 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *src = areg_action(_s->kids[0],0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP float_s = TI_TOP_Topcode("ufloat.s"); 
  /* Move the data from AR into the FP regfile first if necessary. */
  if (!tie_info->xtfloat_ar_converts())
    src = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), NULL, src, ops);
  return Generate_Binary_FP(MTYPE_F4, float_s, result, src, zero_tn, true, ops);

}
  break;
  case 520:
{
/* line 8376 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  return WN_tn(_s->node); 

}
  break;
  case 521:
{
/* line 8388 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  TN *ar = areg_action(_s,0, ops);

  result = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), result, ar, ops);
  return result;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._freg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule freg"));
  /*NOTREACHED*/
}
/* line 2241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * tie_reg_action(ISEL::State *_s, /* line 2241 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::tie_reg_NT))
    NO_ACTION(tie_reg);
  _ern = _s->matches[ISEL::tie_reg_NT].rule_num;
  switch(_ern){
  case 516:
{
/* line 8335 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._tie_reg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule tie_reg"));
  /*NOTREACHED*/
}
/* line 2242 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * tie_cvt_reg_action(ISEL::State *_s, /* line 2242 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::tie_cvt_reg_NT))
    NO_ACTION(tie_cvt_reg);
  _ern = _s->matches[ISEL::tie_cvt_reg_NT].rule_num;
  switch(_ern){
  default:
    return ISEL::get_dynamic_rule(_ern)->action._tie_cvt_reg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule tie_cvt_reg"));
  /*NOTREACHED*/
}
/* line 2243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * ll_cvt_areg_action(ISEL::State *_s, /* line 2243 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::ll_cvt_areg_NT))
    NO_ACTION(ll_cvt_areg);
  _ern = _s->matches[ISEL::ll_cvt_areg_NT].rule_num;
  switch(_ern){
  case 298:
{
/* line 5562 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o_lo = WN_load_offset(_s->node);
  INT64 o_hi = o_lo + Preg_Increment(MTYPE_I4);
  if (Target_Byte_Sex == BIG_ENDIAN) {
    o_hi = WN_load_offset(_s->node);
    o_lo = o_hi + Preg_Increment(MTYPE_I4);
  }
  if (result==NULL)
    result = Build_TN_Of_Mtype(MTYPE_I4);
  TN* result_1 = Build_TN_Of_Mtype(MTYPE_I4);
  set_reg_tn_pair(result, result_1);
  Move_To_Register(MTYPE_I4,result_1,PREG_To_TN(s,o_hi),ops);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o_lo),ops);

}
  break;
  case 300:
{
/* line 5625 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  Check_For_Dedicated_Preg(_s->node);
  ST *s = WN_st(_s->node);
  INT64 o_lo = WN_load_offset(_s->node);
  INT64 o_hi = o_lo + Preg_Increment(MTYPE_U4);
  if (Target_Byte_Sex == BIG_ENDIAN) {
    o_hi = WN_load_offset(_s->node);
    o_lo = o_hi + Preg_Increment(MTYPE_U4);
  }
  if (result==NULL)
    result = Build_TN_Of_Mtype(MTYPE_U4);
  TN* result_1 = Build_TN_Of_Mtype(MTYPE_U4);
  set_reg_tn_pair(result, result_1);
  Move_To_Register(MTYPE_U4,result_1,PREG_To_TN(s,o_hi),ops);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN(s,o_lo),ops);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._ll_cvt_areg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule ll_cvt_areg"));
  /*NOTREACHED*/
}
/* line 2244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void acc_reg_action(ISEL::State *_s, /* line 2244 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::acc_reg_NT))
    NO_ACTION(acc_reg);
  _ern = _s->matches[ISEL::acc_reg_NT].rule_num;
  switch(_ern){
  case 422:
{
/* line 7515 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_Mpy_16Bit_Signed(_s->node))
    Generate_MAC16("mul.aa.ll", _s->kids[0]->node, _s->kids[1]->node, ops);
  else
    Generate_MAC16("umul.aa.ll", _s->kids[0]->node, _s->kids[1]->node, ops);
  return;

}
  break;
  case 423:
{
/* line 7529 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  if (WN_Mpy_16Bit_Signed(_s->node))
    Generate_MAC16("mul.aa.ll", _s->kids[0]->node, _s->kids[1]->node, ops);
  else
    Generate_MAC16("umul.aa.ll", _s->kids[0]->node, _s->kids[1]->node, ops);
  return;

}
  break;
  case 424:
{
/* line 7545 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  acc_reg_action(_s->kids[0],0,ops);
  Generate_MAC16("mula.aa.ll", _s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, ops);
  return;

}
  break;
  case 425:
{
/* line 7559 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  acc_reg_action(_s->kids[1],0,ops);
  Generate_MAC16("mula.aa.ll", _s->kids[0]->kids[0]->node, _s->kids[0]->kids[1]->node, ops);
  return;

}
  break;
  case 426:
{
/* line 7573 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  acc_reg_action(_s->kids[0],0,ops);
  Generate_MAC16("mula.aa.ll", _s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, ops);
  return;

}
  break;
  case 427:
{
/* line 7587 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  acc_reg_action(_s->kids[1],0,ops);
  Generate_MAC16("mula.aa.ll", _s->kids[0]->kids[0]->node, _s->kids[0]->kids[1]->node, ops);
  return;

}
  break;
  case 428:
{
/* line 7601 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  acc_reg_action(_s->kids[0],0,ops);
  Generate_MAC16("muls.aa.ll", _s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, ops);
  return;

}
  break;
  case 429:
{
/* line 7615 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  acc_reg_action(_s->kids[0],0,ops);
  Generate_MAC16("muls.aa.ll", _s->kids[1]->kids[0]->node, _s->kids[1]->kids[1]->node, ops);
  return;

}
  break;
  case 518:
{
/* line 8347 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  TN *ar = areg_action(_s,0, ops);
  Build_OP(TI_TOP_Topcode("wsr.acclo"), accum_tn(), ar, accum_tn(), ops );
  return;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._acc_reg(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule acc_reg"));
  /*NOTREACHED*/
}
/* line 2245 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * tie_imm_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::tie_imm_NT))
    NO_ACTION(tie_imm);
  _ern = _s->matches[ISEL::tie_imm_NT].rule_num;
  switch(_ern){
  case 579:
{
/* line 8953 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 580:
{
/* line 8959 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 581:
{
/* line 8965 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._tie_imm(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule tie_imm"));
  /*NOTREACHED*/
}
/* line 2246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * wsar_action(ISEL::State *_s, /* line 2246 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::wsar_NT))
    NO_ACTION(wsar);
  _ern = _s->matches[ISEL::wsar_NT].rule_num;
  switch(_ern){
  case 514:
{
/* line 8302 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *ar = areg_action(_s,0, ops);
  TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
  Build_OP(TI_TOP_Topcode("wsr.sar"), sar, xtsync_tn(), ar, ops);
  return sar;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._wsar(_s,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule wsar"));
  /*NOTREACHED*/
}
/* line 2247 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * sar_left_action(ISEL::State *_s, /* line 2247 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::sar_left_NT))
    NO_ACTION(sar_left);
  _ern = _s->matches[ISEL::sar_left_NT].rule_num;
  switch(_ern){
  case 512:
{
/* line 8284 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *ar = areg_action(_s,0, ops);
  TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
  Build_OP(TOP_ssl, sar, ar, ops );
  return sar;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._sar_left(_s,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule sar_left"));
  /*NOTREACHED*/
}
/* line 2248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * sar_right_action(ISEL::State *_s, /* line 2248 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::sar_right_NT))
    NO_ACTION(sar_right);
  _ern = _s->matches[ISEL::sar_right_NT].rule_num;
  switch(_ern){
  case 513:
{
/* line 8293 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  TN *ar = areg_action(_s,0, ops);
  TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
  Build_OP(TOP_ssr, sar, ar, ops );
  return sar;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._sar_right(_s,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule sar_right"));
  /*NOTREACHED*/
}
/* line 2249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_simm12_action(ISEL::State *_s, /* line 2249 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::areg_or_simm12_NT))
    NO_ACTION(areg_or_simm12);
  _ern = _s->matches[ISEL::areg_or_simm12_NT].rule_num;
  switch(_ern){
  case 526:
{
/* line 8450 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s,0, ops);

}
  break;
  case 527:
{
/* line 8456 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return simm12_action(_s);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._areg_or_simm12(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule areg_or_simm12"));
  /*NOTREACHED*/
}
/* line 2250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_simm8_action(ISEL::State *_s, /* line 2250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::areg_or_simm8_NT))
    NO_ACTION(areg_or_simm8);
  _ern = _s->matches[ISEL::areg_or_simm8_NT].rule_num;
  switch(_ern){
  case 528:
{
/* line 8462 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s,0, ops);

}
  break;
  case 529:
{
/* line 8468 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return simm8_action(_s);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._areg_or_simm8(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule areg_or_simm8"));
  /*NOTREACHED*/
}
/* line 2251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_b4const_action(ISEL::State *_s, /* line 2251 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::areg_or_b4const_NT))
    NO_ACTION(areg_or_b4const);
  _ern = _s->matches[ISEL::areg_or_b4const_NT].rule_num;
  switch(_ern){
  case 530:
{
/* line 8474 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s,0, ops);

}
  break;
  case 531:
{
/* line 8480 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return b4const_action(_s);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._areg_or_b4const(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule areg_or_b4const"));
  /*NOTREACHED*/
}
/* line 2252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * areg_or_b4constu_action(ISEL::State *_s, /* line 2252 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::areg_or_b4constu_NT))
    NO_ACTION(areg_or_b4constu);
  _ern = _s->matches[ISEL::areg_or_b4constu_NT].rule_num;
  switch(_ern){
  case 532:
{
/* line 8486 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return areg_action(_s,0, ops);

}
  break;
  case 533:
{
/* line 8492 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return b4constu_action(_s);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._areg_or_b4constu(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule areg_or_b4constu"));
  /*NOTREACHED*/
}
/* line 2253 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * extui_mask_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::extui_mask_NT))
    NO_ACTION(extui_mask);
  _ern = _s->matches[ISEL::extui_mask_NT].rule_num;
  switch(_ern){
  case 545:
{
/* line 8586 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 546:
{
/* line 8592 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 547:
{
/* line 8604 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 548:
{
/* line 8618 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._extui_mask(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule extui_mask"));
  /*NOTREACHED*/
}
/* line 2254 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * bbci_bbsi_imm_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::bbci_bbsi_imm_NT))
    NO_ACTION(bbci_bbsi_imm);
  _ern = _s->matches[ISEL::bbci_bbsi_imm_NT].rule_num;
  switch(_ern){
  case 549:
{
/* line 8627 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 550:
{
/* line 8633 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 551:
{
/* line 8645 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 552:
{
/* line 8658 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._bbci_bbsi_imm(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule bbci_bbsi_imm"));
  /*NOTREACHED*/
}
/* line 2255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * logical_and_immed_action(ISEL::State *_s, /* line 2255 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN *result,OPS *ops)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::logical_and_immed_NT))
    NO_ACTION(logical_and_immed);
  _ern = _s->matches[ISEL::logical_and_immed_NT].rule_num;
  switch(_ern){
  case 553:
{
/* line 8666 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 554:
{
/* line 8672 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 555:
{
/* line 8684 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 556:
{
/* line 8698 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 557:
{
/* line 8713 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  return areg_action(_s->kids[1],0, ops);

}
  break;
  case 558:
{
/* line 8721 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 
  return areg_action(_s->kids[1],0, ops);

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._logical_and_immed(_s,result,ops);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule logical_and_immed"));
  /*NOTREACHED*/
}
/* line 2256 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * clamps_const_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::clamps_const_NT))
    NO_ACTION(clamps_const);
  _ern = _s->matches[ISEL::clamps_const_NT].rule_num;
  switch(_ern){
  case 559:
{
/* line 8728 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 560:
{
/* line 8734 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 561:
{
/* line 8746 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 562:
{
/* line 8760 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._clamps_const(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule clamps_const"));
  /*NOTREACHED*/
}
/* line 2257 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm8x256_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::simm8x256_NT))
    NO_ACTION(simm8x256);
  _ern = _s->matches[ISEL::simm8x256_NT].rule_num;
  switch(_ern){
  case 563:
{
/* line 8769 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 564:
{
/* line 8775 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 565:
{
/* line 8781 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 566:
{
/* line 8791 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 567:
{
/* line 8805 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._simm8x256(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule simm8x256"));
  /*NOTREACHED*/
}
/* line 2260 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm8_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::simm8_NT))
    NO_ACTION(simm8);
  _ern = _s->matches[ISEL::simm8_NT].rule_num;
  switch(_ern){
  case 568:
{
/* line 8848 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 569:
{
/* line 8854 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 570:
{
/* line 8860 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 571:
{
/* line 8870 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 572:
{
/* line 8884 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._simm8(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule simm8"));
  /*NOTREACHED*/
}
/* line 2261 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm12_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::simm12_NT))
    NO_ACTION(simm12);
  _ern = _s->matches[ISEL::simm12_NT].rule_num;
  switch(_ern){
  case 573:
{
/* line 8897 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 574:
{
/* line 8903 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 575:
{
/* line 8909 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._simm12(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule simm12"));
  /*NOTREACHED*/
}
/* line 2263 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * simm32_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::simm32_NT))
    NO_ACTION(simm32);
  _ern = _s->matches[ISEL::simm32_NT].rule_num;
  switch(_ern){
  case 576:
{
/* line 8936 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 577:
{
/* line 8942 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 578:
{
/* line 8948 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._simm32(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule simm32"));
  /*NOTREACHED*/
}
/* line 2266 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * uimm4_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::uimm4_NT))
    NO_ACTION(uimm4);
  _ern = _s->matches[ISEL::uimm4_NT].rule_num;
  switch(_ern){
  case 583:
{
/* line 9011 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 584:
{
/* line 9017 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 585:
{
/* line 9023 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 586:
{
/* line 9033 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 587:
{
/* line 9047 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._uimm4(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule uimm4"));
  /*NOTREACHED*/
}
/* line 2267 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * uimm5_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::uimm5_NT))
    NO_ACTION(uimm5);
  _ern = _s->matches[ISEL::uimm5_NT].rule_num;
  switch(_ern){
  case 588:
{
/* line 9056 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 589:
{
/* line 9062 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 590:
{
/* line 9068 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 591:
{
/* line 9078 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 592:
{
/* line 9092 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._uimm5(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule uimm5"));
  /*NOTREACHED*/
}
/* line 2272 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * b4constu_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::b4constu_NT))
    NO_ACTION(b4constu);
  _ern = _s->matches[ISEL::b4constu_NT].rule_num;
  switch(_ern){
  case 593:
{
/* line 9169 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 594:
{
/* line 9175 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 595:
{
/* line 9181 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 596:
{
/* line 9191 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 597:
{
/* line 9205 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._b4constu(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule b4constu"));
  /*NOTREACHED*/
}
/* line 2273 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * b4const_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::b4const_NT))
    NO_ACTION(b4const);
  _ern = _s->matches[ISEL::b4const_NT].rule_num;
  switch(_ern){
  case 598:
{
/* line 9214 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 599:
{
/* line 9220 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 600:
{
/* line 9226 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 601:
{
/* line 9236 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 602:
{
/* line 9250 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._b4const(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule b4const"));
  /*NOTREACHED*/
}
/* line 2277 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
TN * msalp32_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::msalp32_NT))
    NO_ACTION(msalp32);
  _ern = _s->matches[ISEL::msalp32_NT].rule_num;
  switch(_ern){
  case 603:
{
/* line 9310 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 604:
{
/* line 9316 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  return Gen_Literal_TN( (INT32) WN_const_val(_s->node), 4 );

}
  break;
  case 605:
{
/* line 9322 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return WN_tn(_s->node); 
}
  break;
  case 606:
{
/* line 9332 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  case 607:
{
/* line 9346 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  WN *lit = preg_equivalent_literal(_s->node);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._msalp32(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule msalp32"));
  /*NOTREACHED*/
}
/* line 2278 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void zero_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::zero_NT))
    NO_ACTION(zero);
  _ern = _s->matches[ISEL::zero_NT].rule_num;
  switch(_ern){
  case 534:
{
/* line 8505 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 535:
{
/* line 8509 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._zero(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule zero"));
  /*NOTREACHED*/
}
/* line 2279 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void one_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::one_NT))
    NO_ACTION(one);
  _ern = _s->matches[ISEL::one_NT].rule_num;
  switch(_ern){
  case 536:
{
/* line 8514 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 537:
{
/* line 8518 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 538:
{
/* line 8528 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 539:
{
/* line 8538 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 543:
{
/* line 8567 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._one(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule one"));
  /*NOTREACHED*/
}
/* line 2280 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
void thirtytwo_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::thirtytwo_NT))
    NO_ACTION(thirtytwo);
  _ern = _s->matches[ISEL::thirtytwo_NT].rule_num;
  switch(_ern){
  case 540:
{
/* line 8543 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 541:
{
/* line 8547 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  case 542:
{
/* line 8557 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
 return; 
}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._thirtytwo(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule thirtytwo"));
  /*NOTREACHED*/
}
/* line 2281 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */
INT32 float_const_action(ISEL::State *_s)
{
  ISEL::State *_t;
  int _ern;
  NODEPTR *_children;
  if(_s->has_match_for(ISEL::float_const_NT))
    NO_ACTION(float_const);
  _ern = _s->matches[ISEL::float_const_NT].rule_num;
  switch(_ern){
  case 544:
{
/* line 8572 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

  ST *s = WN_st(_s->node);
  union {
    INT32 ii;
    float ff;
  } float_to_int_bytes;
  float_to_int_bytes.ff = TCON_R4(STC_val(s));

  return float_to_int_bytes.ii;

}
  break;
  default:
    return ISEL::get_dynamic_rule(_ern)->action._float_const(_s);
  }
#ifdef lint
  _t = 0;
  _t = _t;
  _children = 0;
  _children = _children;
#endif
  /*CONSTCOND*/
  ISEL_assert(0, PANIC("missing return in an action for rule float_const"));
  /*NOTREACHED*/
}
void ISEL::closure(ISEL::State *s,ISEL::Nonterm rhs)
{
  assert( 0 < rhs && rhs < max_nt);
  COST c;
  switch(rhs) {
    case 2:
        if(ISEL_cost_code(&c,0,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
          s->set_match(ISEL::stmt_NT,c,0);
        }
      break;
    case 3:
        if(ISEL_cost_code(&c,532,s) && (!s->has_match_for(ISEL::areg_or_b4constu_NT) || COST_LESS(c,s->matches[ISEL::areg_or_b4constu_NT].cost))) {
          s->set_match(ISEL::areg_or_b4constu_NT,c,532);
        }
        if(ISEL_cost_code(&c,530,s) && (!s->has_match_for(ISEL::areg_or_b4const_NT) || COST_LESS(c,s->matches[ISEL::areg_or_b4const_NT].cost))) {
          s->set_match(ISEL::areg_or_b4const_NT,c,530);
        }
        if(ISEL_cost_code(&c,528,s) && (!s->has_match_for(ISEL::areg_or_simm8_NT) || COST_LESS(c,s->matches[ISEL::areg_or_simm8_NT].cost))) {
          s->set_match(ISEL::areg_or_simm8_NT,c,528);
        }
        if(ISEL_cost_code(&c,526,s) && (!s->has_match_for(ISEL::areg_or_simm12_NT) || COST_LESS(c,s->matches[ISEL::areg_or_simm12_NT].cost))) {
          s->set_match(ISEL::areg_or_simm12_NT,c,526);
        }
        if(ISEL_cost_code(&c,521,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
          s->set_match(ISEL::freg_NT,c,521);
          ISEL::closure(s,ISEL::freg_NT);
        }
        if(ISEL_cost_code(&c,518,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
          s->set_match(ISEL::acc_reg_NT,c,518);
          ISEL::closure(s,ISEL::acc_reg_NT);
        }
        if(ISEL_cost_code(&c,514,s) && (!s->has_match_for(ISEL::wsar_NT) || COST_LESS(c,s->matches[ISEL::wsar_NT].cost))) {
          s->set_match(ISEL::wsar_NT,c,514);
        }
        if(ISEL_cost_code(&c,513,s) && (!s->has_match_for(ISEL::sar_right_NT) || COST_LESS(c,s->matches[ISEL::sar_right_NT].cost))) {
          s->set_match(ISEL::sar_right_NT,c,513);
        }
        if(ISEL_cost_code(&c,512,s) && (!s->has_match_for(ISEL::sar_left_NT) || COST_LESS(c,s->matches[ISEL::sar_left_NT].cost))) {
          s->set_match(ISEL::sar_left_NT,c,512);
        }
        if(ISEL_cost_code(&c,264,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,264);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 4:
        if(ISEL_cost_code(&c,624,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
          s->set_match(ISEL::bareg_NT,c,624);
          ISEL::closure(s,ISEL::bareg_NT);
        }
        if(ISEL_cost_code(&c,268,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,268);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 5:
        if(ISEL_cost_code(&c,627,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
          s->set_match(ISEL::breg_NT,c,627);
          ISEL::closure(s,ISEL::breg_NT);
        }
        if(ISEL_cost_code(&c,626,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
          s->set_match(ISEL::b1reg_NT,c,626);
          ISEL::closure(s,ISEL::b1reg_NT);
        }
      break;
    case 6:
        if(ISEL_cost_code(&c,625,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
          s->set_match(ISEL::breg_NT,c,625);
          ISEL::closure(s,ISEL::breg_NT);
        }
      break;
    case 7:
        if(ISEL_cost_code(&c,522,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
          s->set_match(ISEL::areg_NT,c,522);
          ISEL::closure(s,ISEL::areg_NT);
        }
        if(ISEL_cost_code(&c,269,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,269);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 8:
        if(ISEL_cost_code(&c,265,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,265);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 9:
        if(ISEL_cost_code(&c,266,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,266);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 10:
        if(ISEL_cost_code(&c,267,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,267);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 11:
        if(ISEL_cost_code(&c,519,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
          s->set_match(ISEL::areg_NT,c,519);
          ISEL::closure(s,ISEL::areg_NT);
        }
      break;
    case 12:
        if(ISEL_cost_code(&c,582,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
          s->set_match(ISEL::expr_NT,c,582);
          ISEL::closure(s,ISEL::expr_NT);
        }
      break;
    case 25:
        if(ISEL_cost_code(&c,529,s) && (!s->has_match_for(ISEL::areg_or_simm8_NT) || COST_LESS(c,s->matches[ISEL::areg_or_simm8_NT].cost))) {
          s->set_match(ISEL::areg_or_simm8_NT,c,529);
        }
      break;
    case 26:
        if(ISEL_cost_code(&c,527,s) && (!s->has_match_for(ISEL::areg_or_simm12_NT) || COST_LESS(c,s->matches[ISEL::areg_or_simm12_NT].cost))) {
          s->set_match(ISEL::areg_or_simm12_NT,c,527);
        }
        if(ISEL_cost_code(&c,523,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
          s->set_match(ISEL::areg_NT,c,523);
          ISEL::closure(s,ISEL::areg_NT);
        }
      break;
    case 27:
        if(ISEL_cost_code(&c,524,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
          s->set_match(ISEL::areg_NT,c,524);
          ISEL::closure(s,ISEL::areg_NT);
        }
      break;
    case 30:
        if(ISEL_cost_code(&c,533,s) && (!s->has_match_for(ISEL::areg_or_b4constu_NT) || COST_LESS(c,s->matches[ISEL::areg_or_b4constu_NT].cost))) {
          s->set_match(ISEL::areg_or_b4constu_NT,c,533);
        }
      break;
    case 31:
        if(ISEL_cost_code(&c,531,s) && (!s->has_match_for(ISEL::areg_or_b4const_NT) || COST_LESS(c,s->matches[ISEL::areg_or_b4const_NT].cost))) {
          s->set_match(ISEL::areg_or_b4const_NT,c,531);
        }
      break;
    case 36:
        if(ISEL_cost_code(&c,525,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
          s->set_match(ISEL::areg_NT,c,525);
          ISEL::closure(s,ISEL::areg_NT);
        }
      break;
  }
  for(Rule_info *ri = ntchains[rhs]; ri; ri=ri->next){
    if(ri->f(s->node,c)) {
      s->set_match(ri->lhs,c,rule_no(ri));
      closure(s,ri->lhs);
    }
  }
}

ISEL::State *ISEL::alloc_state(NODEPTR u,int arity)
{
  int i;
  State *p, **k;
  p = (State *)ALLOC_FOR_TREE(sizeof(State));
  ISEL_assert(p, PANIC("1:ALLOC returned NULL in ISEL::alloc_state\n"));
  p->op = OP_LABEL(u);
  p->node = u;
  p->arity = arity;
  if(arity){
    k=(State **)ALLOC_FOR_TREE(sizeof(State *)*arity);
    ISEL_assert(k, PANIC("2:ALLOC returned NULL in ISEL::alloc_state\n"));
    p->kids=k;
  }else
    p->kids=0;
  for(i=0;i<ISEL_NT_BITVECTOR_SIZE;i++)
    p->has_match[i]=0;
  p->matches = (Match *)ALLOC_FOR_TREE(sizeof(Match)*max_nt);
  return p;
}
ISEL::State *ISEL::label1(NODEPTR u)
{
  int op = OP_LABEL(u);
  Op_info *oi = find_op_info(op);
  COST c;
  State *s;
  if(oi) {
    s = oi->labeller(u);
    for(Rule_info *ri = oi->dynamic_rules; ri; ri=ri->next ) {
      if(ri->f(u,c) && (!s->has_match_for(ri->lhs) || COST_LESS(c,s->matches[ri->lhs].cost))){
        s->set_match(ri->lhs,c,rule_no(ri));
        closure(s,ri->lhs);
      }
    }
    return s;
  } else
    throw ISEL::Exception("Bad operator in ISEL_state",u);
}
ISEL::State *ISEL_label_OPC_XTBOOL16CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_XTBOOL16CALL */
  if(ISEL_cost_code(&c,705,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,705);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_XTBOOL8CALL */
  if(ISEL_cost_code(&c,704,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,704);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_XTBOOL4CALL */
  if(ISEL_cost_code(&c,703,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,703);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_XTBOOL2CALL */
  if(ISEL_cost_code(&c,702,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,702);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLCALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_XTBOOLCALL */
  if(ISEL_cost_code(&c,701,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,701);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U4XTBOOL16CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4XTBOOL16CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,687,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,687);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4XTBOOL8CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4XTBOOL8CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,686,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,686);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4XTBOOL4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4XTBOOL4CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,685,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,685);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4XTBOOL2CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4XTBOOL2CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,684,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,684);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4XTBOOLCVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4XTBOOLCVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,683,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,683);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16U4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL16U4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,682,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,682);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8U4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL8U4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,681,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,681);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4U4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL4U4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,680,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,680);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2U4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL2U4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,679,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,679);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLU4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOLU4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,678,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,678);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4XTBOOL16CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4XTBOOL16CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,677,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,677);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4XTBOOL8CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4XTBOOL8CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,676,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,676);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4XTBOOL4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4XTBOOL4CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,675,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,675);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4XTBOOL2CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4XTBOOL2CVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,674,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,674);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16I4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL16I4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,672,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,672);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8I4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL8I4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,671,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,671);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4I4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL4I4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,670,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,670);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2I4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL2I4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,669,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,669);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL16ISTORE(bareg,areg) */
        k[0]->has_match_for(ISEL::bareg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,667,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,667);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
  if (     /* expr: OPC_XTBOOL16ISTORE(breg,areg) */
        k[0]->has_match_for(ISEL::breg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,662,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,662);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL8ISTORE(bareg,areg) */
        k[0]->has_match_for(ISEL::bareg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,666,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,666);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
  if (     /* expr: OPC_XTBOOL8ISTORE(breg,areg) */
        k[0]->has_match_for(ISEL::breg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,661,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,661);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL4ISTORE(bareg,areg) */
        k[0]->has_match_for(ISEL::bareg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,665,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,665);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
  if (     /* expr: OPC_XTBOOL4ISTORE(breg,areg) */
        k[0]->has_match_for(ISEL::breg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,660,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,660);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL2ISTORE(bareg,areg) */
        k[0]->has_match_for(ISEL::bareg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,664,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,664);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
  if (     /* expr: OPC_XTBOOL2ISTORE(breg,areg) */
        k[0]->has_match_for(ISEL::breg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,659,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,659);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOLISTORE(bareg,areg) */
        k[0]->has_match_for(ISEL::bareg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,663,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,663);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
  if (     /* expr: OPC_XTBOOLISTORE(breg,areg) */
        k[0]->has_match_for(ISEL::breg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,658,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,658);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16XTBOOL16ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL16XTBOOL16ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,657,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,657);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
  if (     /* breg: OPC_XTBOOL16XTBOOL16ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,652,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,652);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8XTBOOL8ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL8XTBOOL8ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,656,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,656);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
  if (     /* breg: OPC_XTBOOL8XTBOOL8ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,651,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,651);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4XTBOOL4ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL4XTBOOL4ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,655,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,655);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
  if (     /* breg: OPC_XTBOOL4XTBOOL4ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,650,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,650);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2XTBOOL2ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOL2XTBOOL2ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,654,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,654);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
  if (     /* breg: OPC_XTBOOL2XTBOOL2ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,649,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,649);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLXTBOOLILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOLXTBOOLILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,653,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,653);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
  if (     /* breg: OPC_XTBOOLXTBOOLILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,648,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,648);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL16STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,647,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,647);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL16STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,642,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,642);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL16STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,637,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,637);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL16STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,632,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,632);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL8STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,646,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,646);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL8STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,641,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,641);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL8STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,636,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,636);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL8STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,631,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,631);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL4STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,645,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,645);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL4STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,640,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,640);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL4STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,635,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,635);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL4STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,630,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,630);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOL2STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,644,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,644);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL2STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,639,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,639);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL2STID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,634,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,634);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOL2STID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,629,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,629);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLSTID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_XTBOOLSTID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,643,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,643);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOLSTID(breg) */
        k[0]->has_match_for(ISEL::breg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,638,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,638);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOLSTID(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,633,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,633);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_XTBOOLSTID(b1reg) */
        k[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,628,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,628);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLI4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* bareg: OPC_XTBOOLI4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,668,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,668);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  }
  if (     /* b1reg: OPC_XTBOOLI4CVT(b1reg) */
        k[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,618,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,618);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16XTBOOL16LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* bareg: OPC_XTBOOL16XTBOOL16LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,623,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,623);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  /* breg: OPC_XTBOOL16XTBOOL16LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,617,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,617);
      ISEL::closure(s,ISEL::breg_NT);
    }
  /* breg: OPC_XTBOOL16XTBOOL16LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,612,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,612);
      ISEL::closure(s,ISEL::breg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8XTBOOL8LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* bareg: OPC_XTBOOL8XTBOOL8LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,622,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,622);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  /* breg: OPC_XTBOOL8XTBOOL8LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,616,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,616);
      ISEL::closure(s,ISEL::breg_NT);
    }
  /* breg: OPC_XTBOOL8XTBOOL8LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,611,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,611);
      ISEL::closure(s,ISEL::breg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4XTBOOL4LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* bareg: OPC_XTBOOL4XTBOOL4LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,621,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,621);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  /* breg: OPC_XTBOOL4XTBOOL4LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,615,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,615);
      ISEL::closure(s,ISEL::breg_NT);
    }
  /* breg: OPC_XTBOOL4XTBOOL4LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,610,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,610);
      ISEL::closure(s,ISEL::breg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2XTBOOL2LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* bareg: OPC_XTBOOL2XTBOOL2LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,620,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,620);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  /* breg: OPC_XTBOOL2XTBOOL2LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,614,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,614);
      ISEL::closure(s,ISEL::breg_NT);
    }
  /* breg: OPC_XTBOOL2XTBOOL2LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,609,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,609);
      ISEL::closure(s,ISEL::breg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLXTBOOLLDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* bareg: OPC_XTBOOLXTBOOLLDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,619,s) && (!s->has_match_for(ISEL::bareg_NT) || COST_LESS(c,s->matches[ISEL::bareg_NT].cost))) {
      s->set_match(ISEL::bareg_NT,c,619);
      ISEL::closure(s,ISEL::bareg_NT);
    }
  /* breg: OPC_XTBOOLXTBOOLLDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,613,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,613);
      ISEL::closure(s,ISEL::breg_NT);
    }
  /* b1reg: OPC_XTBOOLXTBOOLLDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,608,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,608);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_F4CONST(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* float_const: OPC_F4CONST */
  if(ISEL_cost_code(&c,544,s) && (!s->has_match_for(ISEL::float_const_NT) || COST_LESS(c,s->matches[ISEL::float_const_NT].cost))) {
    s->set_match(ISEL::float_const_NT,c,544);
    ISEL::closure(s,ISEL::float_const_NT);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U4INTCONST(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* msalp32: OPC_U4INTCONST */
  if(is_msalp32(u))
    if(ISEL_cost_code(&c,604,s) && (!s->has_match_for(ISEL::msalp32_NT) || COST_LESS(c,s->matches[ISEL::msalp32_NT].cost))) {
      s->set_match(ISEL::msalp32_NT,c,604);
    }
  /* b4const: OPC_U4INTCONST */
  if(is_b4const(u))
    if(ISEL_cost_code(&c,599,s) && (!s->has_match_for(ISEL::b4const_NT) || COST_LESS(c,s->matches[ISEL::b4const_NT].cost))) {
      s->set_match(ISEL::b4const_NT,c,599);
      ISEL::closure(s,ISEL::b4const_NT);
    }
  /* b4constu: OPC_U4INTCONST */
  if(is_b4constu(u))
    if(ISEL_cost_code(&c,594,s) && (!s->has_match_for(ISEL::b4constu_NT) || COST_LESS(c,s->matches[ISEL::b4constu_NT].cost))) {
      s->set_match(ISEL::b4constu_NT,c,594);
      ISEL::closure(s,ISEL::b4constu_NT);
    }
  /* uimm5: OPC_U4INTCONST */
  if(is_uimm5(u))
    if(ISEL_cost_code(&c,589,s) && (!s->has_match_for(ISEL::uimm5_NT) || COST_LESS(c,s->matches[ISEL::uimm5_NT].cost))) {
      s->set_match(ISEL::uimm5_NT,c,589);
    }
  /* uimm4: OPC_U4INTCONST */
  if(is_uimm4(u))
    if(ISEL_cost_code(&c,584,s) && (!s->has_match_for(ISEL::uimm4_NT) || COST_LESS(c,s->matches[ISEL::uimm4_NT].cost))) {
      s->set_match(ISEL::uimm4_NT,c,584);
    }
  /* tie_imm: OPC_U4INTCONST */
  if(ISEL_cost_code(&c,580,s) && (!s->has_match_for(ISEL::tie_imm_NT) || COST_LESS(c,s->matches[ISEL::tie_imm_NT].cost))) {
    s->set_match(ISEL::tie_imm_NT,c,580);
    ISEL::closure(s,ISEL::tie_imm_NT);
  }
  /* simm32: OPC_U4INTCONST */
  if(is_simm32(u))
    if(ISEL_cost_code(&c,577,s) && (!s->has_match_for(ISEL::simm32_NT) || COST_LESS(c,s->matches[ISEL::simm32_NT].cost))) {
      s->set_match(ISEL::simm32_NT,c,577);
      ISEL::closure(s,ISEL::simm32_NT);
    }
  /* simm12: OPC_U4INTCONST */
  if(is_simm12(u))
    if(ISEL_cost_code(&c,574,s) && (!s->has_match_for(ISEL::simm12_NT) || COST_LESS(c,s->matches[ISEL::simm12_NT].cost))) {
      s->set_match(ISEL::simm12_NT,c,574);
      ISEL::closure(s,ISEL::simm12_NT);
    }
  /* simm8: OPC_U4INTCONST */
  if(is_simm8(u))
    if(ISEL_cost_code(&c,569,s) && (!s->has_match_for(ISEL::simm8_NT) || COST_LESS(c,s->matches[ISEL::simm8_NT].cost))) {
      s->set_match(ISEL::simm8_NT,c,569);
      ISEL::closure(s,ISEL::simm8_NT);
    }
  /* simm8x256: OPC_U4INTCONST */
  if(is_simm8x256(u))
    if(ISEL_cost_code(&c,564,s) && (!s->has_match_for(ISEL::simm8x256_NT) || COST_LESS(c,s->matches[ISEL::simm8x256_NT].cost))) {
      s->set_match(ISEL::simm8x256_NT,c,564);
    }
  /* clamps_const: OPC_U4INTCONST */
  if(is_clamps_const(u))
    if(ISEL_cost_code(&c,560,s) && (!s->has_match_for(ISEL::clamps_const_NT) || COST_LESS(c,s->matches[ISEL::clamps_const_NT].cost))) {
      s->set_match(ISEL::clamps_const_NT,c,560);
    }
  /* logical_and_immed: OPC_U4INTCONST */
  if(is_extui_shift_mask(u)||is_bbci_bbsi_imm(u))
    if(ISEL_cost_code(&c,554,s) && (!s->has_match_for(ISEL::logical_and_immed_NT) || COST_LESS(c,s->matches[ISEL::logical_and_immed_NT].cost))) {
      s->set_match(ISEL::logical_and_immed_NT,c,554);
    }
  /* bbci_bbsi_imm: OPC_U4INTCONST */
  if(is_bbci_bbsi_imm(u))
    if(ISEL_cost_code(&c,550,s) && (!s->has_match_for(ISEL::bbci_bbsi_imm_NT) || COST_LESS(c,s->matches[ISEL::bbci_bbsi_imm_NT].cost))) {
      s->set_match(ISEL::bbci_bbsi_imm_NT,c,550);
    }
  /* extui_mask: OPC_U4INTCONST */
  if(is_extui_mask(u))
    if(ISEL_cost_code(&c,546,s) && (!s->has_match_for(ISEL::extui_mask_NT) || COST_LESS(c,s->matches[ISEL::extui_mask_NT].cost))) {
      s->set_match(ISEL::extui_mask_NT,c,546);
    }
  /* thirtytwo: OPC_U4INTCONST */
  if(is_thirtytwo(u))
    if(ISEL_cost_code(&c,541,s) && (!s->has_match_for(ISEL::thirtytwo_NT) || COST_LESS(c,s->matches[ISEL::thirtytwo_NT].cost))) {
      s->set_match(ISEL::thirtytwo_NT,c,541);
    }
  /* one: OPC_U4INTCONST */
  if(is_one(u))
    if(ISEL_cost_code(&c,537,s) && (!s->has_match_for(ISEL::one_NT) || COST_LESS(c,s->matches[ISEL::one_NT].cost))) {
      s->set_match(ISEL::one_NT,c,537);
    }
  /* zero: OPC_U4INTCONST */
  if(is_zero(u))
    if(ISEL_cost_code(&c,535,s) && (!s->has_match_for(ISEL::zero_NT) || COST_LESS(c,s->matches[ISEL::zero_NT].cost))) {
      s->set_match(ISEL::zero_NT,c,535);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4INTCONST(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* msalp32: OPC_I4INTCONST */
  if(is_msalp32(u))
    if(ISEL_cost_code(&c,603,s) && (!s->has_match_for(ISEL::msalp32_NT) || COST_LESS(c,s->matches[ISEL::msalp32_NT].cost))) {
      s->set_match(ISEL::msalp32_NT,c,603);
    }
  /* b4const: OPC_I4INTCONST */
  if(is_b4const(u))
    if(ISEL_cost_code(&c,598,s) && (!s->has_match_for(ISEL::b4const_NT) || COST_LESS(c,s->matches[ISEL::b4const_NT].cost))) {
      s->set_match(ISEL::b4const_NT,c,598);
      ISEL::closure(s,ISEL::b4const_NT);
    }
  /* b4constu: OPC_I4INTCONST */
  if(is_b4constu(u))
    if(ISEL_cost_code(&c,593,s) && (!s->has_match_for(ISEL::b4constu_NT) || COST_LESS(c,s->matches[ISEL::b4constu_NT].cost))) {
      s->set_match(ISEL::b4constu_NT,c,593);
      ISEL::closure(s,ISEL::b4constu_NT);
    }
  /* uimm5: OPC_I4INTCONST */
  if(is_uimm5(u))
    if(ISEL_cost_code(&c,588,s) && (!s->has_match_for(ISEL::uimm5_NT) || COST_LESS(c,s->matches[ISEL::uimm5_NT].cost))) {
      s->set_match(ISEL::uimm5_NT,c,588);
    }
  /* uimm4: OPC_I4INTCONST */
  if(is_uimm4(u))
    if(ISEL_cost_code(&c,583,s) && (!s->has_match_for(ISEL::uimm4_NT) || COST_LESS(c,s->matches[ISEL::uimm4_NT].cost))) {
      s->set_match(ISEL::uimm4_NT,c,583);
    }
  /* tie_imm: OPC_I4INTCONST */
  if(ISEL_cost_code(&c,579,s) && (!s->has_match_for(ISEL::tie_imm_NT) || COST_LESS(c,s->matches[ISEL::tie_imm_NT].cost))) {
    s->set_match(ISEL::tie_imm_NT,c,579);
    ISEL::closure(s,ISEL::tie_imm_NT);
  }
  /* simm32: OPC_I4INTCONST */
  if(is_simm32(u))
    if(ISEL_cost_code(&c,576,s) && (!s->has_match_for(ISEL::simm32_NT) || COST_LESS(c,s->matches[ISEL::simm32_NT].cost))) {
      s->set_match(ISEL::simm32_NT,c,576);
      ISEL::closure(s,ISEL::simm32_NT);
    }
  /* simm12: OPC_I4INTCONST */
  if(is_simm12(u))
    if(ISEL_cost_code(&c,573,s) && (!s->has_match_for(ISEL::simm12_NT) || COST_LESS(c,s->matches[ISEL::simm12_NT].cost))) {
      s->set_match(ISEL::simm12_NT,c,573);
      ISEL::closure(s,ISEL::simm12_NT);
    }
  /* simm8: OPC_I4INTCONST */
  if(is_simm8(u))
    if(ISEL_cost_code(&c,568,s) && (!s->has_match_for(ISEL::simm8_NT) || COST_LESS(c,s->matches[ISEL::simm8_NT].cost))) {
      s->set_match(ISEL::simm8_NT,c,568);
      ISEL::closure(s,ISEL::simm8_NT);
    }
  /* simm8x256: OPC_I4INTCONST */
  if(is_simm8x256(u))
    if(ISEL_cost_code(&c,563,s) && (!s->has_match_for(ISEL::simm8x256_NT) || COST_LESS(c,s->matches[ISEL::simm8x256_NT].cost))) {
      s->set_match(ISEL::simm8x256_NT,c,563);
    }
  /* clamps_const: OPC_I4INTCONST */
  if(is_clamps_const(u))
    if(ISEL_cost_code(&c,559,s) && (!s->has_match_for(ISEL::clamps_const_NT) || COST_LESS(c,s->matches[ISEL::clamps_const_NT].cost))) {
      s->set_match(ISEL::clamps_const_NT,c,559);
    }
  /* logical_and_immed: OPC_I4INTCONST */
  if(is_extui_shift_mask(u)||is_bbci_bbsi_imm(u))
    if(ISEL_cost_code(&c,553,s) && (!s->has_match_for(ISEL::logical_and_immed_NT) || COST_LESS(c,s->matches[ISEL::logical_and_immed_NT].cost))) {
      s->set_match(ISEL::logical_and_immed_NT,c,553);
    }
  /* bbci_bbsi_imm: OPC_I4INTCONST */
  if(is_bbci_bbsi_imm(u))
    if(ISEL_cost_code(&c,549,s) && (!s->has_match_for(ISEL::bbci_bbsi_imm_NT) || COST_LESS(c,s->matches[ISEL::bbci_bbsi_imm_NT].cost))) {
      s->set_match(ISEL::bbci_bbsi_imm_NT,c,549);
    }
  /* extui_mask: OPC_I4INTCONST */
  if(is_extui_mask(u))
    if(ISEL_cost_code(&c,545,s) && (!s->has_match_for(ISEL::extui_mask_NT) || COST_LESS(c,s->matches[ISEL::extui_mask_NT].cost))) {
      s->set_match(ISEL::extui_mask_NT,c,545);
    }
  /* thirtytwo: OPC_I4INTCONST */
  if(is_thirtytwo(u))
    if(ISEL_cost_code(&c,540,s) && (!s->has_match_for(ISEL::thirtytwo_NT) || COST_LESS(c,s->matches[ISEL::thirtytwo_NT].cost))) {
      s->set_match(ISEL::thirtytwo_NT,c,540);
    }
  /* one: OPC_I4INTCONST */
  if(is_one(u))
    if(ISEL_cost_code(&c,536,s) && (!s->has_match_for(ISEL::one_NT) || COST_LESS(c,s->matches[ISEL::one_NT].cost))) {
      s->set_match(ISEL::one_NT,c,536);
    }
  /* zero: OPC_I4INTCONST */
  if(is_zero(u))
    if(ISEL_cost_code(&c,534,s) && (!s->has_match_for(ISEL::zero_NT) || COST_LESS(c,s->matches[ISEL::zero_NT].cost))) {
      s->set_match(ISEL::zero_NT,c,534);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_TN(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* msalp32: OPC_TN */
  if(is_msalp32(u))
    if(ISEL_cost_code(&c,605,s) && (!s->has_match_for(ISEL::msalp32_NT) || COST_LESS(c,s->matches[ISEL::msalp32_NT].cost))) {
      s->set_match(ISEL::msalp32_NT,c,605);
    }
  /* b4const: OPC_TN */
  if(is_b4const(u))
    if(ISEL_cost_code(&c,600,s) && (!s->has_match_for(ISEL::b4const_NT) || COST_LESS(c,s->matches[ISEL::b4const_NT].cost))) {
      s->set_match(ISEL::b4const_NT,c,600);
      ISEL::closure(s,ISEL::b4const_NT);
    }
  /* b4constu: OPC_TN */
  if(is_b4constu(u))
    if(ISEL_cost_code(&c,595,s) && (!s->has_match_for(ISEL::b4constu_NT) || COST_LESS(c,s->matches[ISEL::b4constu_NT].cost))) {
      s->set_match(ISEL::b4constu_NT,c,595);
      ISEL::closure(s,ISEL::b4constu_NT);
    }
  /* uimm5: OPC_TN */
  if(is_uimm5(u))
    if(ISEL_cost_code(&c,590,s) && (!s->has_match_for(ISEL::uimm5_NT) || COST_LESS(c,s->matches[ISEL::uimm5_NT].cost))) {
      s->set_match(ISEL::uimm5_NT,c,590);
    }
  /* uimm4: OPC_TN */
  if(is_uimm4(u))
    if(ISEL_cost_code(&c,585,s) && (!s->has_match_for(ISEL::uimm4_NT) || COST_LESS(c,s->matches[ISEL::uimm4_NT].cost))) {
      s->set_match(ISEL::uimm4_NT,c,585);
    }
  /* tie_imm: OPC_TN */
  if(ISEL_cost_code(&c,581,s) && (!s->has_match_for(ISEL::tie_imm_NT) || COST_LESS(c,s->matches[ISEL::tie_imm_NT].cost))) {
    s->set_match(ISEL::tie_imm_NT,c,581);
    ISEL::closure(s,ISEL::tie_imm_NT);
  }
  /* simm32: OPC_TN */
  if(is_simm32(u))
    if(ISEL_cost_code(&c,578,s) && (!s->has_match_for(ISEL::simm32_NT) || COST_LESS(c,s->matches[ISEL::simm32_NT].cost))) {
      s->set_match(ISEL::simm32_NT,c,578);
      ISEL::closure(s,ISEL::simm32_NT);
    }
  /* simm12: OPC_TN */
  if(is_simm12(u))
    if(ISEL_cost_code(&c,575,s) && (!s->has_match_for(ISEL::simm12_NT) || COST_LESS(c,s->matches[ISEL::simm12_NT].cost))) {
      s->set_match(ISEL::simm12_NT,c,575);
      ISEL::closure(s,ISEL::simm12_NT);
    }
  /* simm8: OPC_TN */
  if(is_simm8(u))
    if(ISEL_cost_code(&c,570,s) && (!s->has_match_for(ISEL::simm8_NT) || COST_LESS(c,s->matches[ISEL::simm8_NT].cost))) {
      s->set_match(ISEL::simm8_NT,c,570);
      ISEL::closure(s,ISEL::simm8_NT);
    }
  /* simm8x256: OPC_TN */
  if(is_simm8x256(u))
    if(ISEL_cost_code(&c,565,s) && (!s->has_match_for(ISEL::simm8x256_NT) || COST_LESS(c,s->matches[ISEL::simm8x256_NT].cost))) {
      s->set_match(ISEL::simm8x256_NT,c,565);
    }
  /* freg: OPC_TN */
  if(is_preg(u)&&is_float_tn(u))
    if(ISEL_cost_code(&c,520,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
      s->set_match(ISEL::freg_NT,c,520);
      ISEL::closure(s,ISEL::freg_NT);
    }
  /* breg: OPC_TN */
  if(is_preg(u)&&is_xtbool_tn(u))
    if(ISEL_cost_code(&c,517,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,517);
      ISEL::closure(s,ISEL::breg_NT);
    }
  /* tie_reg: OPC_TN */
  if(is_preg(u)&&is_tie_tn(u))
    if(ISEL_cost_code(&c,516,s) && (!s->has_match_for(ISEL::tie_reg_NT) || COST_LESS(c,s->matches[ISEL::tie_reg_NT].cost))) {
      s->set_match(ISEL::tie_reg_NT,c,516);
      ISEL::closure(s,ISEL::tie_reg_NT);
    }
  /* areg: OPC_TN */
  if(is_preg(u)&&!is_tie_tn(u))
    if(ISEL_cost_code(&c,515,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,515);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4I4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,511,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,511);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,510,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,510);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4CVTL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4CVTL(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_nop_cvtl(u))
      if(ISEL_cost_code(&c,509,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,509);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_I4CVTL(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,507,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,507);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4CVTL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4CVTL(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_nop_cvtl(u))
      if(ISEL_cost_code(&c,508,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,508);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_U4CVTL(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,506,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,506);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I1ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I1ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,505,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,505);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4I1ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,493,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,493);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I2ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I2ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,504,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,504);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4I2ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,492,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,492);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,503,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,503);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4I4ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,491,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,491);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U1ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U1ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,502,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,502);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4U1ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,490,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,490);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U2ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U2ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,501,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,501);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4U2ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,489,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,489);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,500,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,500);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4U4ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,488,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,488);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I1ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I1ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,499,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,499);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4I1ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,487,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,487);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I2ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I2ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,498,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,498);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4I2ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,486,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,486);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,497,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,497);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4I4ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,485,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,485);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U1ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U1ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,496,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,496);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4U1ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,484,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,484);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U2ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U2ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,495,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,495);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4U2ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,483,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,483);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4ILDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4ILDBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,494,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,494);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4U4ILDBITS(OPC_U4LDA) */
        k[0]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,482,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,482);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I1LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4I1LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,481,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,481);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I1LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,469,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,469);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4I2LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4I2LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,480,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,480);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I2LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,468,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,468);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4I4LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4I4LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,479,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,479);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I4LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,467,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,467);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4U1LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4U1LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,478,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,478);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4U1LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,466,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,466);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4U2LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4U2LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,477,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,477);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4U2LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,465,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,465);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4U4LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4U4LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,476,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,476);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4U4LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,464,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,464);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4I1LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4I1LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,475,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,475);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4I1LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,463,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,463);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4I2LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4I2LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,474,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,474);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4I2LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,462,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,462);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4I4LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4I4LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,473,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,473);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4I4LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,461,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,461);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U1LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4U1LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,472,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,472);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U1LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,460,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,460);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U2LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4U2LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,471,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,471);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U2LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,459,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,459);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U4LDBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4U4LDBITS */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,470,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,470);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U4LDBITS */
  if(is_preg(u))
    if(ISEL_cost_code(&c,458,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,458);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I1ISTBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I1ISTBITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,457,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,457);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I1ISTBITS(areg,OPC_U4LDA) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,451,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,451);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I2ISTBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I2ISTBITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,456,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,456);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I2ISTBITS(areg,OPC_U4LDA) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,450,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,450);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4ISTBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4ISTBITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,455,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,455);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ISTBITS(areg,OPC_U4LDA) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,449,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,449);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U1ISTBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U1ISTBITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,454,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,454);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U1ISTBITS(areg,OPC_U4LDA) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,448,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,448);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U2ISTBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U2ISTBITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,453,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,453);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U2ISTBITS(areg,OPC_U4LDA) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,447,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,447);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4ISTBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4ISTBITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,452,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,452);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ISTBITS(areg,OPC_U4LDA) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LDA	/* OPC_U4LDA */
      ) {
    if(ISEL_cost_code(&c,446,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,446);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I1STBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I1STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,445,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,445);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_I1STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,439,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,439);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I2STBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I2STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,444,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,444);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_I2STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,438,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,438);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4STBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,443,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,443);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_I4STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,437,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,437);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U1STBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U1STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,442,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,442);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_U1STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,436,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,436);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U2STBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U2STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,441,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,441);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_U2STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,435,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,435);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4STBITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,440,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,440);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
  if (     /* areg: OPC_U4STBITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,434,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,434);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4EXTRACT_BITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4EXTRACT_BITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,433,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,433);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4EXTRACT_BITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4EXTRACT_BITS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,432,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,432);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4COMPOSE_BITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4COMPOSE_BITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,431,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,431);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4COMPOSE_BITS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4COMPOSE_BITS(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,430,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,430);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4LSHR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4LSHR(areg,sar_right) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::sar_right_NT) 
      ) {
    if(ISEL_cost_code(&c,411,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,411);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4LSHR(areg,uimm5) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::uimm5_NT) 
      ) {
    if(ISEL_cost_code(&c,405,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,405);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4LSHR(areg,uimm4) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::uimm4_NT) 
      ) {
    if(ISEL_cost_code(&c,403,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,403);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4LSHR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4LSHR(areg,sar_right) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::sar_right_NT) 
      ) {
    if(ISEL_cost_code(&c,410,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,410);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4LSHR(areg,uimm5) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::uimm5_NT) 
      ) {
    if(ISEL_cost_code(&c,404,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,404);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4LSHR(areg,uimm4) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::uimm4_NT) 
      ) {
    if(ISEL_cost_code(&c,402,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,402);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4ASHR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4ASHR(areg,sar_right) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::sar_right_NT) 
      ) {
    if(ISEL_cost_code(&c,409,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,409);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ASHR(areg,uimm5) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::uimm5_NT) 
      ) {
    if(ISEL_cost_code(&c,401,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,401);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4ASHR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4ASHR(areg,sar_right) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::sar_right_NT) 
      ) {
    if(ISEL_cost_code(&c,408,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,408);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ASHR(areg,uimm5) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::uimm5_NT) 
      ) {
    if(ISEL_cost_code(&c,400,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,400);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4LNOT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4LNOT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,397,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,397);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4LNOT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4LNOT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,396,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,396);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4BNOT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4BNOT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,395,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,395);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4BNOT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,699,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,699);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* areg: OPC_I4BNOT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,394,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,394);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4BXOR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4BXOR(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,393,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,393);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4BXOR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4BXOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,698,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,698);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* areg: OPC_I4BXOR(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,392,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,392);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4SHL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* logical_and_immed: OPC_U4SHL(one,areg) */
        k[0]->has_match_for(ISEL::one_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,558,s) && (!s->has_match_for(ISEL::logical_and_immed_NT) || COST_LESS(c,s->matches[ISEL::logical_and_immed_NT].cost))) {
      s->set_match(ISEL::logical_and_immed_NT,c,558);
    }
  }
  if (     /* areg: OPC_U4SHL(areg,sar_left) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::sar_left_NT) 
      ) {
    if(ISEL_cost_code(&c,407,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,407);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SHL(areg,msalp32) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::msalp32_NT) 
      ) {
    if(ISEL_cost_code(&c,399,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,399);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4SHL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* logical_and_immed: OPC_I4SHL(one,areg) */
        k[0]->has_match_for(ISEL::one_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,557,s) && (!s->has_match_for(ISEL::logical_and_immed_NT) || COST_LESS(c,s->matches[ISEL::logical_and_immed_NT].cost))) {
      s->set_match(ISEL::logical_and_immed_NT,c,557);
    }
  }
  if (     /* areg: OPC_I4SHL(areg,sar_left) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::sar_left_NT) 
      ) {
    if(ISEL_cost_code(&c,406,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,406);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SHL(areg,msalp32) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::msalp32_NT) 
      ) {
    if(ISEL_cost_code(&c,398,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,398);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4BIOR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4BIOR(OPC_I4SHL(areg,OPC_I4SUB(thirtytwo,areg)),OPC_U4LSHR(areg,wsar)) */
        k[0]->op == OPC_I4SHL && 	/* OPC_I4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->op == OPC_I4SUB && 	/* OPC_I4SUB */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::thirtytwo_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LSHR && 	/* OPC_U4LSHR */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::wsar_NT) 
      ) {
    if(ISEL_cost_code(&c,415,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,415);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BIOR(OPC_U4SHL(areg,OPC_I4SUB(thirtytwo,areg)),OPC_U4LSHR(areg,wsar)) */
        k[0]->op == OPC_U4SHL && 	/* OPC_U4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->op == OPC_I4SUB && 	/* OPC_I4SUB */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::thirtytwo_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4LSHR && 	/* OPC_U4LSHR */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::wsar_NT) 
      ) {
    if(ISEL_cost_code(&c,414,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,414);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BIOR(OPC_U4LSHR(areg,wsar),OPC_I4SHL(areg,OPC_I4SUB(thirtytwo,areg))) */
        k[0]->op == OPC_U4LSHR && 	/* OPC_U4LSHR */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::wsar_NT)  && 
        k[1]->op == OPC_I4SHL && 	/* OPC_I4SHL */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->op == OPC_I4SUB && 	/* OPC_I4SUB */
        k[1]->kids[1]->kids[0]->has_match_for(ISEL::thirtytwo_NT) &&
        k[1]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,413,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,413);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BIOR(OPC_U4LSHR(areg,wsar),OPC_U4SHL(areg,OPC_I4SUB(thirtytwo,areg))) */
        k[0]->op == OPC_U4LSHR && 	/* OPC_U4LSHR */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::wsar_NT)  && 
        k[1]->op == OPC_U4SHL && 	/* OPC_U4SHL */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->op == OPC_I4SUB && 	/* OPC_I4SUB */
        k[1]->kids[1]->kids[0]->has_match_for(ISEL::thirtytwo_NT) &&
        k[1]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,412,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,412);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BIOR(OPC_U4SHL(areg,one),one) */
        k[0]->op == OPC_U4SHL && 	/* OPC_U4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::one_NT)  && 
        k[1]->has_match_for(ISEL::one_NT) 
      ) {
    if(ISEL_cost_code(&c,391,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,391);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BIOR(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,389,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,389);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4BIOR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4BIOR(OPC_XTBOOLBNOT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,697,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,697);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BIOR(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4BNOT && 	/* OPC_I4BNOT */
        k[0]->kids[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,696,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,696);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,695,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,695);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4BNOT && 	/* OPC_I4BNOT */
        k[1]->kids[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,694,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,694);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,693,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,693);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* areg: OPC_I4BIOR(OPC_I4SHL(areg,one),one) */
        k[0]->op == OPC_I4SHL && 	/* OPC_I4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::one_NT)  && 
        k[1]->has_match_for(ISEL::one_NT) 
      ) {
    if(ISEL_cost_code(&c,390,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,390);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4BIOR(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,388,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,388);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4EQ(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_U4F4EQ(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,380,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,380);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_U4F4EQ(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,379,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,379);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4GE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_U4F4GE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,378,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,378);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_U4F4GE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,377,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,377);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4LE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_U4F4LE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,376,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,376);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_U4F4LE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,375,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,375);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4GT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_U4F4GT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,374,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,374);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_U4F4GT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,373,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,373);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4LT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_U4F4LT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,372,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,372);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_U4F4LT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,371,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,371);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4EQ(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4F4EQ(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,369,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,369);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_I4F4EQ(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,368,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,368);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4GE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4F4GE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,367,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,367);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_I4F4GE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,366,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,366);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4LE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4F4LE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,365,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,365);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_I4F4LE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,364,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,364);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4GT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4F4GT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,363,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,363);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_I4F4GT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,362,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,362);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4LT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4F4LT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,361,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
        s->set_match(ISEL::b1reg_NT,c,361);
        ISEL::closure(s,ISEL::b1reg_NT);
      }
  }
  if (     /* areg: OPC_I4F4LT(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,360,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,360);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4TRUNC(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4F4TRUNC(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,359,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,359);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4F4CVT(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,358,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,358);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4TRUNC(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4F4TRUNC(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,357,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,357);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4F4CVT(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,356,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,356);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4U4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4U4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,355,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,355);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4I4CVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4I4CVT(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,354,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,354);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4RSQRT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4RSQRT(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp_rsqrt(u))
      if(ISEL_cost_code(&c,353,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,353);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4RECIP(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4RECIP(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp_recip(u))
      if(ISEL_cost_code(&c,352,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,352);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4NEG(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4NEG(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,351,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,351);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4ABS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4ABS(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,350,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,350);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4MSUB(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4MSUB(freg,freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,349,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,349);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4NMSUB(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4NMSUB(freg,freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,348,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,348);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4NMADD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4NMADD(freg,freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,347,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,347);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4MADD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4MADD(freg,freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,346,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,346);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4DIV(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4DIV(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,345,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,345);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4MPY(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4MPY(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,344,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,344);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4SUB(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4SUB(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,343,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,343);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4ADD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4ADD(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,342,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,342);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4NEG(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4NEG(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,341,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,341);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4NEG(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4NEG(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,340,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,340);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4ABS(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4ABS(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,339,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,339);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4MIN(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4MIN(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,330,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,330);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4MIN(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4MIN(clamps_const,OPC_I4MAX(clamps_const,areg)) */
        k[0]->has_match_for(ISEL::clamps_const_NT)  && 
        k[1]->op == OPC_I4MAX && 	/* OPC_I4MAX */
        k[1]->kids[0]->has_match_for(ISEL::clamps_const_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,334,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,334);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MIN(OPC_I4MAX(clamps_const,areg),clamps_const) */
        k[0]->op == OPC_I4MAX && 	/* OPC_I4MAX */
        k[0]->kids[0]->has_match_for(ISEL::clamps_const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::clamps_const_NT) 
      ) {
    if(ISEL_cost_code(&c,333,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,333);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MIN(clamps_const,OPC_I4MAX(areg,clamps_const)) */
        k[0]->has_match_for(ISEL::clamps_const_NT)  && 
        k[1]->op == OPC_I4MAX && 	/* OPC_I4MAX */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::clamps_const_NT) 
      ) {
    if(ISEL_cost_code(&c,332,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,332);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MIN(OPC_I4MAX(areg,clamps_const),clamps_const) */
        k[0]->op == OPC_I4MAX && 	/* OPC_I4MAX */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::clamps_const_NT)  && 
        k[1]->has_match_for(ISEL::clamps_const_NT) 
      ) {
    if(ISEL_cost_code(&c,331,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,331);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MIN(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,329,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,329);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4MAX(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4MAX(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,328,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,328);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4MAX(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4MAX(clamps_const,OPC_I4MIN(clamps_const,areg)) */
        k[0]->has_match_for(ISEL::clamps_const_NT)  && 
        k[1]->op == OPC_I4MIN && 	/* OPC_I4MIN */
        k[1]->kids[0]->has_match_for(ISEL::clamps_const_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,338,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,338);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MAX(OPC_I4MIN(clamps_const,areg),clamps_const) */
        k[0]->op == OPC_I4MIN && 	/* OPC_I4MIN */
        k[0]->kids[0]->has_match_for(ISEL::clamps_const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::clamps_const_NT) 
      ) {
    if(ISEL_cost_code(&c,337,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,337);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MAX(clamps_const,OPC_I4MIN(areg,clamps_const)) */
        k[0]->has_match_for(ISEL::clamps_const_NT)  && 
        k[1]->op == OPC_I4MIN && 	/* OPC_I4MIN */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::clamps_const_NT) 
      ) {
    if(ISEL_cost_code(&c,336,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,336);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MAX(OPC_I4MIN(areg,clamps_const),clamps_const) */
        k[0]->op == OPC_I4MIN && 	/* OPC_I4MIN */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::clamps_const_NT)  && 
        k[1]->has_match_for(ISEL::clamps_const_NT) 
      ) {
    if(ISEL_cost_code(&c,335,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,335);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4MAX(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,327,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,327);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4MOD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4MOD(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_idiv32(u))
      if(ISEL_cost_code(&c,326,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,326);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4MOD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4MOD(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_idiv32(u))
      if(ISEL_cost_code(&c,325,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,325);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4REM(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4REM(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_idiv32(u))
      if(ISEL_cost_code(&c,324,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,324);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4REM(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4REM(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_idiv32(u))
      if(ISEL_cost_code(&c,323,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,323);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4DIV(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4DIV(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_idiv32(u))
      if(ISEL_cost_code(&c,322,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,322);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4DIV(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4DIV(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_idiv32(u))
      if(ISEL_cost_code(&c,321,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,321);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4MPY(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* acc_reg: OPC_U4MPY(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,423,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,423);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* areg: OPC_U4MPY(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,320,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,320);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4MPY(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* acc_reg: OPC_I4MPY(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,422,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,422);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* areg: OPC_I4MPY(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,319,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,319);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4SUB(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* acc_reg: OPC_U4SUB(acc_reg,OPC_I4MPY(areg,areg)) */
        k[0]->has_match_for(ISEL::acc_reg_NT)  && 
        k[1]->op == OPC_I4MPY && 	/* OPC_I4MPY */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,429,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,429);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* areg: OPC_U4SUB(OPC_U4SHL(areg,msalp32),areg) */
        k[0]->op == OPC_U4SHL && 	/* OPC_U4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::msalp32_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,421,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,421);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SUB(areg,simm8x256) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::simm8x256_NT) 
      ) {
    if(ISEL_cost_code(&c,318,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,318);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SUB(areg,areg_or_simm8) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm8_NT) 
      ) {
    if(ISEL_cost_code(&c,317,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,317);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4SUB(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* acc_reg: OPC_I4SUB(acc_reg,OPC_I4MPY(areg,areg)) */
        k[0]->has_match_for(ISEL::acc_reg_NT)  && 
        k[1]->op == OPC_I4MPY && 	/* OPC_I4MPY */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,428,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,428);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* areg: OPC_I4SUB(OPC_I4SHL(areg,msalp32),areg) */
        k[0]->op == OPC_I4SHL && 	/* OPC_I4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::msalp32_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,420,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,420);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SUB(areg,simm8x256) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::simm8x256_NT) 
      ) {
    if(ISEL_cost_code(&c,316,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,316);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SUB(areg,areg_or_simm8) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm8_NT) 
      ) {
    if(ISEL_cost_code(&c,315,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,315);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4ADD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* acc_reg: OPC_U4ADD(OPC_I4MPY(areg,areg),acc_reg) */
        k[0]->op == OPC_I4MPY && 	/* OPC_I4MPY */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::acc_reg_NT) 
      ) {
    if(ISEL_cost_code(&c,427,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,427);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* acc_reg: OPC_U4ADD(acc_reg,OPC_I4MPY(areg,areg)) */
        k[0]->has_match_for(ISEL::acc_reg_NT)  && 
        k[1]->op == OPC_I4MPY && 	/* OPC_I4MPY */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,426,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,426);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* areg: OPC_U4ADD(OPC_U4SHL(areg,msalp32),areg) */
        k[0]->op == OPC_U4SHL && 	/* OPC_U4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::msalp32_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,419,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,419);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ADD(areg,OPC_U4SHL(areg,msalp32)) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_U4SHL && 	/* OPC_U4SHL */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::msalp32_NT) 
      ) {
    if(ISEL_cost_code(&c,418,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,418);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ADD(simm8x256,areg) */
        k[0]->has_match_for(ISEL::simm8x256_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,314,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,314);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ADD(areg,simm8x256) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::simm8x256_NT) 
      ) {
    if(ISEL_cost_code(&c,313,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,313);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ADD(simm8,areg) */
        k[0]->has_match_for(ISEL::simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,312,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,312);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4ADD(areg,areg_or_simm8) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm8_NT) 
      ) {
    if(ISEL_cost_code(&c,311,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,311);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4ADD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* acc_reg: OPC_I4ADD(OPC_I4MPY(areg,areg),acc_reg) */
        k[0]->op == OPC_I4MPY && 	/* OPC_I4MPY */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::acc_reg_NT) 
      ) {
    if(ISEL_cost_code(&c,425,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,425);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* acc_reg: OPC_I4ADD(acc_reg,OPC_I4MPY(areg,areg)) */
        k[0]->has_match_for(ISEL::acc_reg_NT)  && 
        k[1]->op == OPC_I4MPY && 	/* OPC_I4MPY */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,424,s) && (!s->has_match_for(ISEL::acc_reg_NT) || COST_LESS(c,s->matches[ISEL::acc_reg_NT].cost))) {
      s->set_match(ISEL::acc_reg_NT,c,424);
      ISEL::closure(s,ISEL::acc_reg_NT);
    }
  }
  if (     /* areg: OPC_I4ADD(OPC_I4SHL(areg,msalp32),areg) */
        k[0]->op == OPC_I4SHL && 	/* OPC_I4SHL */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::msalp32_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,417,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,417);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ADD(areg,OPC_I4SHL(areg,msalp32)) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->op == OPC_I4SHL && 	/* OPC_I4SHL */
        k[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[1]->kids[1]->has_match_for(ISEL::msalp32_NT) 
      ) {
    if(ISEL_cost_code(&c,416,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,416);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ADD(simm8x256,areg) */
        k[0]->has_match_for(ISEL::simm8x256_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,310,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,310);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ADD(areg,simm8x256) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::simm8x256_NT) 
      ) {
    if(ISEL_cost_code(&c,309,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,309);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ADD(simm8,areg) */
        k[0]->has_match_for(ISEL::simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,308,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,308);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4ADD(areg,areg_or_simm8) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm8_NT) 
      ) {
    if(ISEL_cost_code(&c,307,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,307);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U8STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U8STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,306,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,306);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I8STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I8STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,305,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,305);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U8ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U8ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,304,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,304);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I8ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I8ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,303,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,303);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U8U8LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* ll_cvt_areg: OPC_U8U8LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,300,s) && (!s->has_match_for(ISEL::ll_cvt_areg_NT) || COST_LESS(c,s->matches[ISEL::ll_cvt_areg_NT].cost))) {
      s->set_match(ISEL::ll_cvt_areg_NT,c,300);
      ISEL::closure(s,ISEL::ll_cvt_areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U8LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4U8LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,302,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,302);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U8LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,299,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,299);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I8I8LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* ll_cvt_areg: OPC_I8I8LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,298,s) && (!s->has_match_for(ISEL::ll_cvt_areg_NT) || COST_LESS(c,s->matches[ISEL::ll_cvt_areg_NT].cost))) {
      s->set_match(ISEL::ll_cvt_areg_NT,c,298);
      ISEL::closure(s,ISEL::ll_cvt_areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4I8LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4I8LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,301,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,301);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I8LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,297,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,297);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4LDA_LABEL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4LDA_LABEL */
  if(ISEL_cost_code(&c,295,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
    s->set_match(ISEL::areg_NT,c,295);
    ISEL::closure(s,ISEL::areg_NT);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U4LDA(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4LDA */
  if(is_auto_or_formal(u))
    if(ISEL_cost_code(&c,296,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,296);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4LDA */
  if(!is_auto_or_formal(u))
    if(ISEL_cost_code(&c,294,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,294);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_F4F4ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4F4ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,293,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,293);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
  if (     /* areg: OPC_F4F4ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,292,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,292);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U1ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U1ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,291,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,291);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U2ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U2ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,290,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,290);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,289,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,289);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I1ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I1ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,288,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,288);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I2ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I2ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,287,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,287);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4ILOAD(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4ILOAD(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,286,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,286);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4F4LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* freg: OPC_F4F4LDID */
  if(!is_preg(u)&&hw_fp(u))
    if(ISEL_cost_code(&c,285,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
      s->set_match(ISEL::freg_NT,c,285);
      ISEL::closure(s,ISEL::freg_NT);
    }
  /* areg: OPC_F4F4LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,284,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,284);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* freg: OPC_F4F4LDID */
  if(is_preg(u)&&is_float_tn(u))
    if(ISEL_cost_code(&c,277,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
      s->set_match(ISEL::freg_NT,c,277);
      ISEL::closure(s,ISEL::freg_NT);
    }
  /* areg: OPC_F4F4LDID */
  if(is_preg(u)&&!is_float_tn(u))
    if(ISEL_cost_code(&c,276,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,276);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U1LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4U1LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,283,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,283);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U1LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,275,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,275);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U2LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_U4U2LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,282,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,282);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U2LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,274,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,274);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_U4U4LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* msalp32: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,607,s) && (!s->has_match_for(ISEL::msalp32_NT) || COST_LESS(c,s->matches[ISEL::msalp32_NT].cost))) {
    s->set_match(ISEL::msalp32_NT,c,607);
  }
  /* b4const: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,602,s) && (!s->has_match_for(ISEL::b4const_NT) || COST_LESS(c,s->matches[ISEL::b4const_NT].cost))) {
    s->set_match(ISEL::b4const_NT,c,602);
    ISEL::closure(s,ISEL::b4const_NT);
  }
  /* b4constu: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,597,s) && (!s->has_match_for(ISEL::b4constu_NT) || COST_LESS(c,s->matches[ISEL::b4constu_NT].cost))) {
    s->set_match(ISEL::b4constu_NT,c,597);
    ISEL::closure(s,ISEL::b4constu_NT);
  }
  /* uimm5: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,592,s) && (!s->has_match_for(ISEL::uimm5_NT) || COST_LESS(c,s->matches[ISEL::uimm5_NT].cost))) {
    s->set_match(ISEL::uimm5_NT,c,592);
  }
  /* uimm4: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,587,s) && (!s->has_match_for(ISEL::uimm4_NT) || COST_LESS(c,s->matches[ISEL::uimm4_NT].cost))) {
    s->set_match(ISEL::uimm4_NT,c,587);
  }
  /* simm8: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,572,s) && (!s->has_match_for(ISEL::simm8_NT) || COST_LESS(c,s->matches[ISEL::simm8_NT].cost))) {
    s->set_match(ISEL::simm8_NT,c,572);
    ISEL::closure(s,ISEL::simm8_NT);
  }
  /* simm8x256: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,567,s) && (!s->has_match_for(ISEL::simm8x256_NT) || COST_LESS(c,s->matches[ISEL::simm8x256_NT].cost))) {
    s->set_match(ISEL::simm8x256_NT,c,567);
  }
  /* clamps_const: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,562,s) && (!s->has_match_for(ISEL::clamps_const_NT) || COST_LESS(c,s->matches[ISEL::clamps_const_NT].cost))) {
    s->set_match(ISEL::clamps_const_NT,c,562);
  }
  /* logical_and_immed: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,556,s) && (!s->has_match_for(ISEL::logical_and_immed_NT) || COST_LESS(c,s->matches[ISEL::logical_and_immed_NT].cost))) {
    s->set_match(ISEL::logical_and_immed_NT,c,556);
  }
  /* bbci_bbsi_imm: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,552,s) && (!s->has_match_for(ISEL::bbci_bbsi_imm_NT) || COST_LESS(c,s->matches[ISEL::bbci_bbsi_imm_NT].cost))) {
    s->set_match(ISEL::bbci_bbsi_imm_NT,c,552);
  }
  /* extui_mask: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,548,s) && (!s->has_match_for(ISEL::extui_mask_NT) || COST_LESS(c,s->matches[ISEL::extui_mask_NT].cost))) {
    s->set_match(ISEL::extui_mask_NT,c,548);
  }
  /* one: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,543,s) && (!s->has_match_for(ISEL::one_NT) || COST_LESS(c,s->matches[ISEL::one_NT].cost))) {
    s->set_match(ISEL::one_NT,c,543);
  }
  /* one: OPC_U4U4LDID */
  if(ISEL_cost_code(&c,539,s) && (!s->has_match_for(ISEL::one_NT) || COST_LESS(c,s->matches[ISEL::one_NT].cost))) {
    s->set_match(ISEL::one_NT,c,539);
  }
  /* areg: OPC_U4U4LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,281,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,281);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_U4U4LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,273,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,273);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4I1LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4I1LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,280,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,280);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I1LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,272,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,272);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4I2LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* areg: OPC_I4I2LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,279,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,279);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I2LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,271,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,271);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_I4I4LDID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* msalp32: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,606,s) && (!s->has_match_for(ISEL::msalp32_NT) || COST_LESS(c,s->matches[ISEL::msalp32_NT].cost))) {
    s->set_match(ISEL::msalp32_NT,c,606);
  }
  /* b4const: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,601,s) && (!s->has_match_for(ISEL::b4const_NT) || COST_LESS(c,s->matches[ISEL::b4const_NT].cost))) {
    s->set_match(ISEL::b4const_NT,c,601);
    ISEL::closure(s,ISEL::b4const_NT);
  }
  /* b4constu: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,596,s) && (!s->has_match_for(ISEL::b4constu_NT) || COST_LESS(c,s->matches[ISEL::b4constu_NT].cost))) {
    s->set_match(ISEL::b4constu_NT,c,596);
    ISEL::closure(s,ISEL::b4constu_NT);
  }
  /* uimm5: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,591,s) && (!s->has_match_for(ISEL::uimm5_NT) || COST_LESS(c,s->matches[ISEL::uimm5_NT].cost))) {
    s->set_match(ISEL::uimm5_NT,c,591);
  }
  /* uimm4: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,586,s) && (!s->has_match_for(ISEL::uimm4_NT) || COST_LESS(c,s->matches[ISEL::uimm4_NT].cost))) {
    s->set_match(ISEL::uimm4_NT,c,586);
  }
  /* simm8: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,571,s) && (!s->has_match_for(ISEL::simm8_NT) || COST_LESS(c,s->matches[ISEL::simm8_NT].cost))) {
    s->set_match(ISEL::simm8_NT,c,571);
    ISEL::closure(s,ISEL::simm8_NT);
  }
  /* simm8x256: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,566,s) && (!s->has_match_for(ISEL::simm8x256_NT) || COST_LESS(c,s->matches[ISEL::simm8x256_NT].cost))) {
    s->set_match(ISEL::simm8x256_NT,c,566);
  }
  /* clamps_const: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,561,s) && (!s->has_match_for(ISEL::clamps_const_NT) || COST_LESS(c,s->matches[ISEL::clamps_const_NT].cost))) {
    s->set_match(ISEL::clamps_const_NT,c,561);
  }
  /* logical_and_immed: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,555,s) && (!s->has_match_for(ISEL::logical_and_immed_NT) || COST_LESS(c,s->matches[ISEL::logical_and_immed_NT].cost))) {
    s->set_match(ISEL::logical_and_immed_NT,c,555);
  }
  /* bbci_bbsi_imm: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,551,s) && (!s->has_match_for(ISEL::bbci_bbsi_imm_NT) || COST_LESS(c,s->matches[ISEL::bbci_bbsi_imm_NT].cost))) {
    s->set_match(ISEL::bbci_bbsi_imm_NT,c,551);
  }
  /* extui_mask: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,547,s) && (!s->has_match_for(ISEL::extui_mask_NT) || COST_LESS(c,s->matches[ISEL::extui_mask_NT].cost))) {
    s->set_match(ISEL::extui_mask_NT,c,547);
  }
  /* thirtytwo: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,542,s) && (!s->has_match_for(ISEL::thirtytwo_NT) || COST_LESS(c,s->matches[ISEL::thirtytwo_NT].cost))) {
    s->set_match(ISEL::thirtytwo_NT,c,542);
  }
  /* one: OPC_I4I4LDID */
  if(ISEL_cost_code(&c,538,s) && (!s->has_match_for(ISEL::one_NT) || COST_LESS(c,s->matches[ISEL::one_NT].cost))) {
    s->set_match(ISEL::one_NT,c,538);
  }
  /* areg: OPC_I4I4LDID */
  if(!is_preg(u))
    if(ISEL_cost_code(&c,278,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,278);
      ISEL::closure(s,ISEL::areg_NT);
    }
  /* areg: OPC_I4I4LDID */
  if(is_preg(u))
    if(ISEL_cost_code(&c,270,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,270);
      ISEL::closure(s,ISEL::areg_NT);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_F4ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_F4ISTORE(freg,areg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,263,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,263);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_F4ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,262,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,262);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I1ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I1ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,261,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,261);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I2ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I2ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,260,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,260);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I4ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,259,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,259);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U1ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U1ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,258,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,258);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U2ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U2ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,257,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,257);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4ISTORE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U4ISTORE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,256,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
      s->set_match(ISEL::expr_NT,c,256);
      ISEL::closure(s,ISEL::expr_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U1STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U1STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,253,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,253);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_U1STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,247,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,247);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I1STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I1STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,252,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,252);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_I1STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,246,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,246);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U2STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U2STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,251,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,251);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_U2STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,245,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,245);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I2STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I2STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,250,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,250);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_I2STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,244,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,244);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_F4STID(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(is_preg(u)&&is_float_tn(u))
      if(ISEL_cost_code(&c,255,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,255);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_F4STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u)&&!is_float_tn(u))
      if(ISEL_cost_code(&c,254,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,254);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_F4STID(freg) */
        k[0]->has_match_for(ISEL::freg_NT) 
      ) {
    if(!is_preg(u)&&hw_fp(u))
      if(ISEL_cost_code(&c,243,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,243);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_F4STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,242,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,242);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_U4STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,249,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,249);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_U4STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,241,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,241);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4STID(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* expr: OPC_I4STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(is_preg(u))
      if(ISEL_cost_code(&c,248,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,248);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
  if (     /* expr: OPC_I4STID(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(!is_preg(u))
      if(ISEL_cost_code(&c,240,s) && (!s->has_match_for(ISEL::expr_NT) || COST_LESS(c,s->matches[ISEL::expr_NT].cost))) {
        s->set_match(ISEL::expr_NT,c,240);
        ISEL::closure(s,ISEL::expr_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL16SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* breg: OPC_XTBOOL16SELECT(areg,breg,breg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::breg_NT)  && 
        k[2]->has_match_for(ISEL::breg_NT) 
      ) {
    if(ISEL_cost_code(&c,239,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,239);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL8SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* breg: OPC_XTBOOL8SELECT(areg,breg,breg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::breg_NT)  && 
        k[2]->has_match_for(ISEL::breg_NT) 
      ) {
    if(ISEL_cost_code(&c,238,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,238);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL4SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* breg: OPC_XTBOOL4SELECT(areg,breg,breg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::breg_NT)  && 
        k[2]->has_match_for(ISEL::breg_NT) 
      ) {
    if(ISEL_cost_code(&c,237,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,237);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOL2SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* breg: OPC_XTBOOL2SELECT(areg,breg,breg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::breg_NT)  && 
        k[2]->has_match_for(ISEL::breg_NT) 
      ) {
    if(ISEL_cost_code(&c,236,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,236);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLSELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* breg: OPC_XTBOOLSELECT(areg,breg,breg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::breg_NT)  && 
        k[2]->has_match_for(ISEL::breg_NT) 
      ) {
    if(ISEL_cost_code(&c,235,s) && (!s->has_match_for(ISEL::breg_NT) || COST_LESS(c,s->matches[ISEL::breg_NT].cost))) {
      s->set_match(ISEL::breg_NT,c,235);
      ISEL::closure(s,ISEL::breg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_F4SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* freg: OPC_F4SELECT(OPC_I4F4NE(freg,freg),freg,freg) */
        k[0]->op == OPC_I4F4NE && 	/* OPC_I4F4NE */
        k[0]->kids[0]->has_match_for(ISEL::freg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,234,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,234);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
  if (     /* freg: OPC_F4SELECT(OPC_XTBOOLBNOT(b1reg),freg,freg) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,233,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,233);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
  if (     /* areg: OPC_F4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,232,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,232);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* freg: OPC_F4SELECT(b1reg,freg,freg) */
        k[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,229,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,229);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
  if (     /* areg: OPC_F4SELECT(b1reg,areg,areg) */
        k[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,228,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,228);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* freg: OPC_F4SELECT(areg,freg,freg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT)  && 
        k[2]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,177,s) && (!s->has_match_for(ISEL::freg_NT) || COST_LESS(c,s->matches[ISEL::freg_NT].cost))) {
        s->set_match(ISEL::freg_NT,c,177);
        ISEL::closure(s,ISEL::freg_NT);
      }
  }
  if (     /* areg: OPC_F4SELECT(areg,areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,176,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,176);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,231,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,231);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(b1reg,areg,areg) */
        k[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,227,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,227);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4LE && 	/* OPC_I4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,225,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,225);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4LT && 	/* OPC_I4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,224,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,224);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4GE && 	/* OPC_I4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,223,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,223);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4GT && 	/* OPC_I4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,222,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,222);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,221,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,221);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,220,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,220);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4LE && 	/* OPC_I4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,219,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,219);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4LT && 	/* OPC_I4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,218,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,218);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4GE && 	/* OPC_I4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,217,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,217);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4GT && 	/* OPC_I4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,216,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,216);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,215,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,215);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_I4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,214,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,214);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4LE && 	/* OPC_U4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,213,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,213);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4LT && 	/* OPC_U4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,212,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,212);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4GE && 	/* OPC_U4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,211,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,211);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4GT && 	/* OPC_U4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,210,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,210);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,209,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,209);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,208,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,208);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4LE && 	/* OPC_U4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,207,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,207);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4LT && 	/* OPC_U4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,206,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,206);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4GE && 	/* OPC_U4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,205,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,205);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4GT && 	/* OPC_U4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,204,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,204);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,203,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,203);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(OPC_U4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,202,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,202);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4SELECT(areg,areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,175,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,175);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4SELECT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=3;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,230,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,230);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(b1reg,areg,areg) */
        k[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,226,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,226);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4LE && 	/* OPC_U4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,201,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,201);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4LT && 	/* OPC_U4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,200,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,200);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4GE && 	/* OPC_U4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,199,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,199);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4GT && 	/* OPC_U4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,198,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,198);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,197,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,197);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,196,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,196);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4LE && 	/* OPC_U4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,195,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,195);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4LT && 	/* OPC_U4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,194,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,194);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4GE && 	/* OPC_U4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,193,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,193);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4GT && 	/* OPC_U4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,192,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,192);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,191,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,191);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_U4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,190,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,190);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4LE && 	/* OPC_I4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,189,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,189);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4LT && 	/* OPC_I4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,188,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,188);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4GE && 	/* OPC_I4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,187,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,187);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4GT && 	/* OPC_I4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,186,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,186);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,185,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,185);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,184,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,184);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4LE && 	/* OPC_I4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,183,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,183);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4LT && 	/* OPC_I4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,182,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,182);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4GE && 	/* OPC_I4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,181,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,181);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4GT && 	/* OPC_I4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,180,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,180);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,179,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,179);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(OPC_I4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_simm8_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_simm8_NT)  && 
        k[1]->has_match_for(ISEL::areg_or_simm12_NT)  && 
        k[2]->has_match_for(ISEL::areg_or_simm12_NT) 
      ) {
    if(ISEL_cost_code(&c,178,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,178);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4SELECT(areg,areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT)  && 
        k[2]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,174,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,174);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4BAND(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4BAND(extui_mask,areg) */
        k[0]->has_match_for(ISEL::extui_mask_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,387,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,387);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BAND(areg,extui_mask) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::extui_mask_NT) 
      ) {
    if(ISEL_cost_code(&c,386,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,386);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_U4BAND(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,385,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,385);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4BAND(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_I4BAND(OPC_XTBOOLBNOT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,692,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,692);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BAND(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4BNOT && 	/* OPC_I4BNOT */
        k[0]->kids[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,691,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,691);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,690,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,690);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4BNOT && 	/* OPC_I4BNOT */
        k[1]->kids[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,689,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,689);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT)  && 
        k[1]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[1]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,688,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,688);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
  if (     /* areg: OPC_I4BAND(extui_mask,areg) */
        k[0]->has_match_for(ISEL::extui_mask_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,384,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,384);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4BAND(areg,extui_mask) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::extui_mask_NT) 
      ) {
    if(ISEL_cost_code(&c,383,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,383);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4BAND(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,382,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,382);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4LE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4LE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,159,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,159);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4LT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4LT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,154,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,154);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4GE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4GE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,158,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,158);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4GT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4GT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,155,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,155);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4NE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4NE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,156,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,156);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4I4EQ(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4I4EQ(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,157,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,157);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4LE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4LE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,153,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,153);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4LT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4LT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,148,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,148);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4GE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4GE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,152,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,152);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4GT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4GT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,149,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,149);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4NE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4NE(OPC_I4BAND(areg,bbci_bbsi_imm),zero) */
        k[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::bbci_bbsi_imm_NT)  && 
        k[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,172,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,172);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4I4NE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,150,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,150);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4I4EQ(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4I4EQ(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,151,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,151);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4LE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4LE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,171,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,171);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4LT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4LT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,166,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,166);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4GE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4GE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,170,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,170);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4GT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4GT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,167,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,167);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4NE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4NE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,168,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,168);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4U4EQ(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4U4EQ(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,169,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,169);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4LE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4LE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,165,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,165);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4LT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4LT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,160,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,160);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4GE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4GE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,164,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,164);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4GT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4GT(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,161,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,161);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4NE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4NE(OPC_U4BAND(areg,bbci_bbsi_imm),zero) */
        k[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::bbci_bbsi_imm_NT)  && 
        k[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,173,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,173);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
  if (     /* areg: OPC_I4U4NE(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,162,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,162);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4U4EQ(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4U4EQ(areg,areg) */
        k[0]->has_match_for(ISEL::areg_NT)  && 
        k[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,163,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,163);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XTBOOLBNOT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* b1reg: OPC_XTBOOLBNOT(b1reg) */
        k[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,700,s) && (!s->has_match_for(ISEL::b1reg_NT) || COST_LESS(c,s->matches[ISEL::b1reg_NT].cost))) {
      s->set_match(ISEL::b1reg_NT,c,700);
      ISEL::closure(s,ISEL::b1reg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4XTBOOLCVT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4XTBOOLCVT(bareg) */
        k[0]->has_match_for(ISEL::bareg_NT) 
      ) {
    if(ISEL_cost_code(&c,673,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,673);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_I4F4NE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_I4F4NE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,370,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,370);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4F4NE(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=2;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4F4NE(freg,freg) */
        k[0]->has_match_for(ISEL::freg_NT)  && 
        k[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,381,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
        s->set_match(ISEL::areg_NT,c,381);
        ISEL::closure(s,ISEL::areg_NT);
      }
  }
return s;
}

ISEL::State *ISEL_label_OPC_FALSEBR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4EQ(zero,OPC_U4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,147,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,147);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4EQ(zero,OPC_U4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,146,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,146);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4EQ(OPC_U4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,145,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,145);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4EQ(OPC_U4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,144,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,144);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4EQ(zero,OPC_I4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,143,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,143);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4EQ(zero,OPC_I4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,142,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,142);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4EQ(OPC_I4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,141,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,141);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4EQ(OPC_I4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,140,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,140);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4EQ(zero,OPC_U4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,139,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,139);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4EQ(zero,OPC_U4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,138,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,138);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4EQ(OPC_U4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,137,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,137);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4EQ(OPC_U4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,136,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,136);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4EQ(zero,OPC_I4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,135,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,135);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4EQ(zero,OPC_I4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,134,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,134);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4EQ(OPC_I4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,133,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,133);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4EQ(OPC_I4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,132,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,132);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(areg,areg),zero)) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,131,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,131);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(areg,areg))) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,130,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,130);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,129,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,129);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,128,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,128);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,127,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,127);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,126,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,126);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(areg,areg),zero)) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,125,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,125);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(areg,areg))) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,124,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,124);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,123,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,123);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,122,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,122);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,121,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,121);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,120,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,120);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(areg,areg),zero)) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,119,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,119);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(areg,areg))) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,118,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,118);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,117,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,117);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,116,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,116);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,115,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,115);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->op == OPC_U4BAND && 	/* OPC_U4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,114,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,114);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(areg,areg),zero)) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,113,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,113);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(areg,areg))) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,112,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,112);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(logical_and_immed,areg))) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,111,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,111);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(areg,logical_and_immed))) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::zero_NT) &&
        k[0]->kids[1]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[1]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) 
      ) {
    if(ISEL_cost_code(&c,110,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,110);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(logical_and_immed,areg),zero)) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,109,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,109);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(areg,logical_and_immed),zero)) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->op == OPC_I4BAND && 	/* OPC_I4BAND */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::areg_NT) &&
        k[0]->kids[0]->kids[1]->has_match_for(ISEL::logical_and_immed_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::zero_NT) 
      ) {
    if(ISEL_cost_code(&c,108,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,108);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4LE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4LE && 	/* OPC_U4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,107,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,107);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4LT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4LT && 	/* OPC_U4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,106,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,106);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4GE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4GE && 	/* OPC_U4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,105,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,105);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4GT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4GT && 	/* OPC_U4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,104,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,104);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,103,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,103);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4I4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,102,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,102);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4LE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4LE && 	/* OPC_I4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,95,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,95);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4LT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4LT && 	/* OPC_I4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,94,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,94);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4GE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4GE && 	/* OPC_I4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,93,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,93);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4GT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4GT && 	/* OPC_I4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,92,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,92);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,91,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,91);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4I4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,90,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,90);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4LE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4LE && 	/* OPC_U4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,83,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,83);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4LT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4LT && 	/* OPC_U4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,82,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,82);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4GE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4GE && 	/* OPC_U4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,81,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,81);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4GT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4GT && 	/* OPC_U4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,80,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,80);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,79,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,79);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4U4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,78,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,78);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4LE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4LE && 	/* OPC_I4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,71,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,71);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4LT && 	/* OPC_I4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,70,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,70);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4GE && 	/* OPC_I4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,69,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,69);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4GT && 	/* OPC_I4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,68,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,68);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,67,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,67);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,66,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,66);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_XTBOOLBNOT(b1reg)) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,59,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,59);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,58,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,58);
    }
  }
  if (     /* stmt: OPC_FALSEBR(b1reg) */
        k[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,57,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,57);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(OPC_XTBOOLBNOT(b1reg))) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,49,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,49);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,48,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,48);
    }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_I4F4NE(freg,freg)) */
        k[0]->op == OPC_I4F4NE && 	/* OPC_I4F4NE */
        k[0]->kids[0]->has_match_for(ISEL::freg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,47,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
        s->set_match(ISEL::stmt_NT,c,47);
      }
  }
  if (     /* stmt: OPC_FALSEBR(OPC_U4F4NE(freg,freg)) */
        k[0]->op == OPC_U4F4NE && 	/* OPC_U4F4NE */
        k[0]->kids[0]->has_match_for(ISEL::freg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,46,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
        s->set_match(ISEL::stmt_NT,c,46);
      }
  }
  if (     /* stmt: OPC_FALSEBR(b1reg) */
        k[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,45,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,45);
    }
  }
  if (     /* stmt: OPC_FALSEBR(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,39,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,39);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_TRUEBR(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* stmt: OPC_TRUEBR(OPC_U4I4LE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4LE && 	/* OPC_U4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,101,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,101);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4I4LT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4LT && 	/* OPC_U4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,100,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,100);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4I4GE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4GE && 	/* OPC_U4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,99,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,99);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4I4GT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4GT && 	/* OPC_U4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,98,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,98);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4I4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4NE && 	/* OPC_U4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,97,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,97);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4I4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4I4EQ && 	/* OPC_U4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,96,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,96);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4I4LE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4LE && 	/* OPC_I4I4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,89,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,89);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4I4LT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4LT && 	/* OPC_I4I4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,88,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,88);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4I4GE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4GE && 	/* OPC_I4I4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,87,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,87);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4I4GT(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4GT && 	/* OPC_I4I4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,86,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,86);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4I4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4NE && 	/* OPC_I4I4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,85,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,85);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4I4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4I4EQ && 	/* OPC_I4I4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,84,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,84);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4U4LE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4LE && 	/* OPC_U4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,77,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,77);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4U4LT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4LT && 	/* OPC_U4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,76,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,76);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4U4GE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4GE && 	/* OPC_U4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,75,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,75);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4U4GT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_U4U4GT && 	/* OPC_U4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,74,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,74);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4U4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4U4NE && 	/* OPC_U4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,73,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,73);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4U4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_U4U4EQ && 	/* OPC_U4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,72,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,72);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4LE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4LE && 	/* OPC_I4U4LE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,65,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,65);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4LT && 	/* OPC_I4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,64,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,64);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4GE && 	/* OPC_I4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,63,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,63);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4GT && 	/* OPC_I4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,62,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,62);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,61,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,61);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,60,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,60);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_XTBOOLBNOT(b1reg)) */
        k[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,56,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,56);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,55,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,55);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4LT && 	/* OPC_I4U4LT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,54,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,54);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4GE && 	/* OPC_I4U4GE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,53,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,53);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu)) */
        k[0]->op == OPC_I4U4GT && 	/* OPC_I4U4GT */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4constu_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4constu_NT) 
      ) {
    if(ISEL_cost_code(&c,52,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,52);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4U4NE && 	/* OPC_I4U4NE */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,51,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,51);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const)) */
        k[0]->op == OPC_I4U4EQ && 	/* OPC_I4U4EQ */
        k[0]->kids[0]->has_match_for(ISEL::areg_or_b4const_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::areg_or_b4const_NT) 
      ) {
    if(ISEL_cost_code(&c,50,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,50);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(OPC_XTBOOLBNOT(b1reg))) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->op == OPC_XTBOOLBNOT && 	/* OPC_XTBOOLBNOT */
        k[0]->kids[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,44,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,44);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(b1reg)) */
        k[0]->op == OPC_I4XTBOOLCVT && 	/* OPC_I4XTBOOLCVT */
        k[0]->kids[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,43,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,43);
    }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_I4F4NE(freg,freg)) */
        k[0]->op == OPC_I4F4NE && 	/* OPC_I4F4NE */
        k[0]->kids[0]->has_match_for(ISEL::freg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,42,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
        s->set_match(ISEL::stmt_NT,c,42);
      }
  }
  if (     /* stmt: OPC_TRUEBR(OPC_U4F4NE(freg,freg)) */
        k[0]->op == OPC_U4F4NE && 	/* OPC_U4F4NE */
        k[0]->kids[0]->has_match_for(ISEL::freg_NT) &&
        k[0]->kids[1]->has_match_for(ISEL::freg_NT) 
      ) {
    if(hw_fp(u))
      if(ISEL_cost_code(&c,41,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
        s->set_match(ISEL::stmt_NT,c,41);
      }
  }
  if (     /* stmt: OPC_TRUEBR(b1reg) */
        k[0]->has_match_for(ISEL::b1reg_NT) 
      ) {
    if(ISEL_cost_code(&c,40,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,40);
    }
  }
  if (     /* stmt: OPC_TRUEBR(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,38,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,38);
    }
  }
  if (     /* stmt: OPC_TRUEBR(one) */
        k[0]->has_match_for(ISEL::one_NT) 
      ) {
    if(ISEL_cost_code(&c,37,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,37);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_AGOTO(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* stmt: OPC_AGOTO(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,36,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,36);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_XGOTO(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* stmt: OPC_XGOTO(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,35,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,35);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_GOTO(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_GOTO */
  if(ISEL_cost_code(&c,34,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,34);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_REGION_EXIT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_REGION_EXIT */
  if(ISEL_cost_code(&c,33,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,33);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_MICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_MICALL */
  if(ISEL_cost_code(&c,32,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,32);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U8ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U8ICALL */
  if(ISEL_cost_code(&c,31,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,31);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I8ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I8ICALL */
  if(ISEL_cost_code(&c,30,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,30);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_F8ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_F8ICALL */
  if(ISEL_cost_code(&c,29,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,29);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U4ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U4ICALL */
  if(ISEL_cost_code(&c,28,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,28);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_F4ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_F4ICALL */
  if(ISEL_cost_code(&c,27,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,27);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I4ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I4ICALL */
  if(ISEL_cost_code(&c,26,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,26);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U2ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U2ICALL */
  if(ISEL_cost_code(&c,25,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,25);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I2ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I2ICALL */
  if(ISEL_cost_code(&c,24,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,24);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U1ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U1ICALL */
  if(ISEL_cost_code(&c,23,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,23);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I1ICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I1ICALL */
  if(ISEL_cost_code(&c,22,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,22);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_VICALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_VICALL */
  if(ISEL_cost_code(&c,21,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,21);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_MCALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_MCALL */
  if(ISEL_cost_code(&c,20,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,20);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U8CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U8CALL */
  if(ISEL_cost_code(&c,19,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,19);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I8CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I8CALL */
  if(ISEL_cost_code(&c,18,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,18);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_F8CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_F8CALL */
  if(ISEL_cost_code(&c,17,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,17);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U4CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U4CALL */
  if(ISEL_cost_code(&c,16,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,16);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_F4CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_F4CALL */
  if(ISEL_cost_code(&c,15,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,15);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I4CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I4CALL */
  if(ISEL_cost_code(&c,14,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,14);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U2CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U2CALL */
  if(ISEL_cost_code(&c,13,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,13);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I2CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I2CALL */
  if(ISEL_cost_code(&c,12,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,12);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_U1CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_U1CALL */
  if(ISEL_cost_code(&c,11,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,11);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I1CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I1CALL */
  if(ISEL_cost_code(&c,10,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,10);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_VCALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_VCALL */
  if(ISEL_cost_code(&c,9,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,9);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_I4INTRINSIC_CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_I4INTRINSIC_CALL */
  if(is_tie_intrinsic_call(u))
    if(ISEL_cost_code(&c,8,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,8);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_VINTRINSIC_CALL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_VINTRINSIC_CALL */
  if(is_tie_intrinsic_call(u))
    if(ISEL_cost_code(&c,7,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,7);
    }
  return s;
}

ISEL::State *ISEL_label_OPC_BACKWARD_BARRIER(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_BACKWARD_BARRIER */
  if(ISEL_cost_code(&c,6,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,6);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_FORWARD_BARRIER(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_FORWARD_BARRIER */
  if(ISEL_cost_code(&c,5,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,5);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_DEALLOCA(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* stmt: OPC_DEALLOCA(areg) */
        k[0]->has_match_for(ISEL::areg_NT) 
      ) {
    if(ISEL_cost_code(&c,4,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,4);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_U4ALLOCA(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* areg: OPC_U4ALLOCA(areg_or_simm8) */
        k[0]->has_match_for(ISEL::areg_or_simm8_NT) 
      ) {
    if(ISEL_cost_code(&c,3,s) && (!s->has_match_for(ISEL::areg_NT) || COST_LESS(c,s->matches[ISEL::areg_NT].cost))) {
      s->set_match(ISEL::areg_NT,c,3);
      ISEL::closure(s,ISEL::areg_NT);
    }
  }
return s;
}

ISEL::State *ISEL_label_OPC_ASM_STMT(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=0;
#ifdef LEAF_TRAP
  if(s=LEAF_TRAP(u))
  return s;
#endif
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=0;
  /* stmt: OPC_ASM_STMT */
  if(ISEL_cost_code(&c,2,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
    s->set_match(ISEL::stmt_NT,c,2);
  }
  return s;
}

ISEL::State *ISEL_label_OPC_EVAL(NODEPTR u)
{
  int arity, i, immed_matched=0;
  COST c=COST_ZERO;
  ISEL::State *s,**k;
  NODEPTR *children;
  arity=1;
  s=ISEL::alloc_state(u,arity);
  ISEL::SET_STATE(u,s);
  k=s->kids;
  children=GET_KIDS(u);
  for(i=0;i<arity;i++)
    k[i]=ISEL::label1(children[i]);
  if (     /* stmt: OPC_EVAL(expr) */
        k[0]->has_match_for(ISEL::expr_NT) 
      ) {
    if(ISEL_cost_code(&c,1,s) && (!s->has_match_for(ISEL::stmt_NT) || COST_LESS(c,s->matches[ISEL::stmt_NT].cost))) {
      s->set_match(ISEL::stmt_NT,c,1);
    }
  }
return s;
}

static ISEL::Op_info op_info[] = {
{OPC_XTBOOL16CALL,ISEL_label_OPC_XTBOOL16CALL},
{OPC_XTBOOL8CALL,ISEL_label_OPC_XTBOOL8CALL},
{OPC_XTBOOL4CALL,ISEL_label_OPC_XTBOOL4CALL},
{OPC_XTBOOL2CALL,ISEL_label_OPC_XTBOOL2CALL},
{OPC_XTBOOLCALL,ISEL_label_OPC_XTBOOLCALL},
{OPC_U4XTBOOL16CVT,ISEL_label_OPC_U4XTBOOL16CVT},
{OPC_U4XTBOOL8CVT,ISEL_label_OPC_U4XTBOOL8CVT},
{OPC_U4XTBOOL4CVT,ISEL_label_OPC_U4XTBOOL4CVT},
{OPC_U4XTBOOL2CVT,ISEL_label_OPC_U4XTBOOL2CVT},
{OPC_U4XTBOOLCVT,ISEL_label_OPC_U4XTBOOLCVT},
{OPC_XTBOOL16U4CVT,ISEL_label_OPC_XTBOOL16U4CVT},
{OPC_XTBOOL8U4CVT,ISEL_label_OPC_XTBOOL8U4CVT},
{OPC_XTBOOL4U4CVT,ISEL_label_OPC_XTBOOL4U4CVT},
{OPC_XTBOOL2U4CVT,ISEL_label_OPC_XTBOOL2U4CVT},
{OPC_XTBOOLU4CVT,ISEL_label_OPC_XTBOOLU4CVT},
{OPC_I4XTBOOL16CVT,ISEL_label_OPC_I4XTBOOL16CVT},
{OPC_I4XTBOOL8CVT,ISEL_label_OPC_I4XTBOOL8CVT},
{OPC_I4XTBOOL4CVT,ISEL_label_OPC_I4XTBOOL4CVT},
{OPC_I4XTBOOL2CVT,ISEL_label_OPC_I4XTBOOL2CVT},
{OPC_XTBOOL16I4CVT,ISEL_label_OPC_XTBOOL16I4CVT},
{OPC_XTBOOL8I4CVT,ISEL_label_OPC_XTBOOL8I4CVT},
{OPC_XTBOOL4I4CVT,ISEL_label_OPC_XTBOOL4I4CVT},
{OPC_XTBOOL2I4CVT,ISEL_label_OPC_XTBOOL2I4CVT},
{OPC_XTBOOL16ISTORE,ISEL_label_OPC_XTBOOL16ISTORE},
{OPC_XTBOOL8ISTORE,ISEL_label_OPC_XTBOOL8ISTORE},
{OPC_XTBOOL4ISTORE,ISEL_label_OPC_XTBOOL4ISTORE},
{OPC_XTBOOL2ISTORE,ISEL_label_OPC_XTBOOL2ISTORE},
{OPC_XTBOOLISTORE,ISEL_label_OPC_XTBOOLISTORE},
{OPC_XTBOOL16XTBOOL16ILOAD,ISEL_label_OPC_XTBOOL16XTBOOL16ILOAD},
{OPC_XTBOOL8XTBOOL8ILOAD,ISEL_label_OPC_XTBOOL8XTBOOL8ILOAD},
{OPC_XTBOOL4XTBOOL4ILOAD,ISEL_label_OPC_XTBOOL4XTBOOL4ILOAD},
{OPC_XTBOOL2XTBOOL2ILOAD,ISEL_label_OPC_XTBOOL2XTBOOL2ILOAD},
{OPC_XTBOOLXTBOOLILOAD,ISEL_label_OPC_XTBOOLXTBOOLILOAD},
{OPC_XTBOOL16STID,ISEL_label_OPC_XTBOOL16STID},
{OPC_XTBOOL8STID,ISEL_label_OPC_XTBOOL8STID},
{OPC_XTBOOL4STID,ISEL_label_OPC_XTBOOL4STID},
{OPC_XTBOOL2STID,ISEL_label_OPC_XTBOOL2STID},
{OPC_XTBOOLSTID,ISEL_label_OPC_XTBOOLSTID},
{OPC_XTBOOLI4CVT,ISEL_label_OPC_XTBOOLI4CVT},
{OPC_XTBOOL16XTBOOL16LDID,ISEL_label_OPC_XTBOOL16XTBOOL16LDID},
{OPC_XTBOOL8XTBOOL8LDID,ISEL_label_OPC_XTBOOL8XTBOOL8LDID},
{OPC_XTBOOL4XTBOOL4LDID,ISEL_label_OPC_XTBOOL4XTBOOL4LDID},
{OPC_XTBOOL2XTBOOL2LDID,ISEL_label_OPC_XTBOOL2XTBOOL2LDID},
{OPC_XTBOOLXTBOOLLDID,ISEL_label_OPC_XTBOOLXTBOOLLDID},
{OPC_F4CONST,ISEL_label_OPC_F4CONST},
{OPC_U4INTCONST,ISEL_label_OPC_U4INTCONST},
{OPC_I4INTCONST,ISEL_label_OPC_I4INTCONST},
{OPC_TN,ISEL_label_OPC_TN},
{OPC_U4I4CVT,ISEL_label_OPC_U4I4CVT},
{OPC_I4U4CVT,ISEL_label_OPC_I4U4CVT},
{OPC_I4CVTL,ISEL_label_OPC_I4CVTL},
{OPC_U4CVTL,ISEL_label_OPC_U4CVTL},
{OPC_I4I1ILDBITS,ISEL_label_OPC_I4I1ILDBITS},
{OPC_I4I2ILDBITS,ISEL_label_OPC_I4I2ILDBITS},
{OPC_I4I4ILDBITS,ISEL_label_OPC_I4I4ILDBITS},
{OPC_I4U1ILDBITS,ISEL_label_OPC_I4U1ILDBITS},
{OPC_I4U2ILDBITS,ISEL_label_OPC_I4U2ILDBITS},
{OPC_I4U4ILDBITS,ISEL_label_OPC_I4U4ILDBITS},
{OPC_U4I1ILDBITS,ISEL_label_OPC_U4I1ILDBITS},
{OPC_U4I2ILDBITS,ISEL_label_OPC_U4I2ILDBITS},
{OPC_U4I4ILDBITS,ISEL_label_OPC_U4I4ILDBITS},
{OPC_U4U1ILDBITS,ISEL_label_OPC_U4U1ILDBITS},
{OPC_U4U2ILDBITS,ISEL_label_OPC_U4U2ILDBITS},
{OPC_U4U4ILDBITS,ISEL_label_OPC_U4U4ILDBITS},
{OPC_I4I1LDBITS,ISEL_label_OPC_I4I1LDBITS},
{OPC_I4I2LDBITS,ISEL_label_OPC_I4I2LDBITS},
{OPC_I4I4LDBITS,ISEL_label_OPC_I4I4LDBITS},
{OPC_I4U1LDBITS,ISEL_label_OPC_I4U1LDBITS},
{OPC_I4U2LDBITS,ISEL_label_OPC_I4U2LDBITS},
{OPC_I4U4LDBITS,ISEL_label_OPC_I4U4LDBITS},
{OPC_U4I1LDBITS,ISEL_label_OPC_U4I1LDBITS},
{OPC_U4I2LDBITS,ISEL_label_OPC_U4I2LDBITS},
{OPC_U4I4LDBITS,ISEL_label_OPC_U4I4LDBITS},
{OPC_U4U1LDBITS,ISEL_label_OPC_U4U1LDBITS},
{OPC_U4U2LDBITS,ISEL_label_OPC_U4U2LDBITS},
{OPC_U4U4LDBITS,ISEL_label_OPC_U4U4LDBITS},
{OPC_I1ISTBITS,ISEL_label_OPC_I1ISTBITS},
{OPC_I2ISTBITS,ISEL_label_OPC_I2ISTBITS},
{OPC_I4ISTBITS,ISEL_label_OPC_I4ISTBITS},
{OPC_U1ISTBITS,ISEL_label_OPC_U1ISTBITS},
{OPC_U2ISTBITS,ISEL_label_OPC_U2ISTBITS},
{OPC_U4ISTBITS,ISEL_label_OPC_U4ISTBITS},
{OPC_I1STBITS,ISEL_label_OPC_I1STBITS},
{OPC_I2STBITS,ISEL_label_OPC_I2STBITS},
{OPC_I4STBITS,ISEL_label_OPC_I4STBITS},
{OPC_U1STBITS,ISEL_label_OPC_U1STBITS},
{OPC_U2STBITS,ISEL_label_OPC_U2STBITS},
{OPC_U4STBITS,ISEL_label_OPC_U4STBITS},
{OPC_U4EXTRACT_BITS,ISEL_label_OPC_U4EXTRACT_BITS},
{OPC_I4EXTRACT_BITS,ISEL_label_OPC_I4EXTRACT_BITS},
{OPC_U4COMPOSE_BITS,ISEL_label_OPC_U4COMPOSE_BITS},
{OPC_I4COMPOSE_BITS,ISEL_label_OPC_I4COMPOSE_BITS},
{OPC_U4LSHR,ISEL_label_OPC_U4LSHR},
{OPC_I4LSHR,ISEL_label_OPC_I4LSHR},
{OPC_U4ASHR,ISEL_label_OPC_U4ASHR},
{OPC_I4ASHR,ISEL_label_OPC_I4ASHR},
{OPC_U4LNOT,ISEL_label_OPC_U4LNOT},
{OPC_I4LNOT,ISEL_label_OPC_I4LNOT},
{OPC_U4BNOT,ISEL_label_OPC_U4BNOT},
{OPC_I4BNOT,ISEL_label_OPC_I4BNOT},
{OPC_U4BXOR,ISEL_label_OPC_U4BXOR},
{OPC_I4BXOR,ISEL_label_OPC_I4BXOR},
{OPC_U4SHL,ISEL_label_OPC_U4SHL},
{OPC_I4SHL,ISEL_label_OPC_I4SHL},
{OPC_U4BIOR,ISEL_label_OPC_U4BIOR},
{OPC_I4BIOR,ISEL_label_OPC_I4BIOR},
{OPC_U4F4EQ,ISEL_label_OPC_U4F4EQ},
{OPC_U4F4GE,ISEL_label_OPC_U4F4GE},
{OPC_U4F4LE,ISEL_label_OPC_U4F4LE},
{OPC_U4F4GT,ISEL_label_OPC_U4F4GT},
{OPC_U4F4LT,ISEL_label_OPC_U4F4LT},
{OPC_I4F4EQ,ISEL_label_OPC_I4F4EQ},
{OPC_I4F4GE,ISEL_label_OPC_I4F4GE},
{OPC_I4F4LE,ISEL_label_OPC_I4F4LE},
{OPC_I4F4GT,ISEL_label_OPC_I4F4GT},
{OPC_I4F4LT,ISEL_label_OPC_I4F4LT},
{OPC_U4F4TRUNC,ISEL_label_OPC_U4F4TRUNC},
{OPC_U4F4CVT,ISEL_label_OPC_U4F4CVT},
{OPC_I4F4TRUNC,ISEL_label_OPC_I4F4TRUNC},
{OPC_I4F4CVT,ISEL_label_OPC_I4F4CVT},
{OPC_F4U4CVT,ISEL_label_OPC_F4U4CVT},
{OPC_F4I4CVT,ISEL_label_OPC_F4I4CVT},
{OPC_F4RSQRT,ISEL_label_OPC_F4RSQRT},
{OPC_F4RECIP,ISEL_label_OPC_F4RECIP},
{OPC_F4NEG,ISEL_label_OPC_F4NEG},
{OPC_F4ABS,ISEL_label_OPC_F4ABS},
{OPC_F4MSUB,ISEL_label_OPC_F4MSUB},
{OPC_F4NMSUB,ISEL_label_OPC_F4NMSUB},
{OPC_F4NMADD,ISEL_label_OPC_F4NMADD},
{OPC_F4MADD,ISEL_label_OPC_F4MADD},
{OPC_F4DIV,ISEL_label_OPC_F4DIV},
{OPC_F4MPY,ISEL_label_OPC_F4MPY},
{OPC_F4SUB,ISEL_label_OPC_F4SUB},
{OPC_F4ADD,ISEL_label_OPC_F4ADD},
{OPC_U4NEG,ISEL_label_OPC_U4NEG},
{OPC_I4NEG,ISEL_label_OPC_I4NEG},
{OPC_I4ABS,ISEL_label_OPC_I4ABS},
{OPC_U4MIN,ISEL_label_OPC_U4MIN},
{OPC_I4MIN,ISEL_label_OPC_I4MIN},
{OPC_U4MAX,ISEL_label_OPC_U4MAX},
{OPC_I4MAX,ISEL_label_OPC_I4MAX},
{OPC_U4MOD,ISEL_label_OPC_U4MOD},
{OPC_I4MOD,ISEL_label_OPC_I4MOD},
{OPC_U4REM,ISEL_label_OPC_U4REM},
{OPC_I4REM,ISEL_label_OPC_I4REM},
{OPC_U4DIV,ISEL_label_OPC_U4DIV},
{OPC_I4DIV,ISEL_label_OPC_I4DIV},
{OPC_U4MPY,ISEL_label_OPC_U4MPY},
{OPC_I4MPY,ISEL_label_OPC_I4MPY},
{OPC_U4SUB,ISEL_label_OPC_U4SUB},
{OPC_I4SUB,ISEL_label_OPC_I4SUB},
{OPC_U4ADD,ISEL_label_OPC_U4ADD},
{OPC_I4ADD,ISEL_label_OPC_I4ADD},
{OPC_U8STID,ISEL_label_OPC_U8STID},
{OPC_I8STID,ISEL_label_OPC_I8STID},
{OPC_U4U8ILOAD,ISEL_label_OPC_U4U8ILOAD},
{OPC_I4I8ILOAD,ISEL_label_OPC_I4I8ILOAD},
{OPC_U8U8LDID,ISEL_label_OPC_U8U8LDID},
{OPC_U4U8LDID,ISEL_label_OPC_U4U8LDID},
{OPC_I8I8LDID,ISEL_label_OPC_I8I8LDID},
{OPC_I4I8LDID,ISEL_label_OPC_I4I8LDID},
{OPC_U4LDA_LABEL,ISEL_label_OPC_U4LDA_LABEL},
{OPC_U4LDA,ISEL_label_OPC_U4LDA},
{OPC_F4F4ILOAD,ISEL_label_OPC_F4F4ILOAD},
{OPC_U4U1ILOAD,ISEL_label_OPC_U4U1ILOAD},
{OPC_U4U2ILOAD,ISEL_label_OPC_U4U2ILOAD},
{OPC_U4U4ILOAD,ISEL_label_OPC_U4U4ILOAD},
{OPC_I4I1ILOAD,ISEL_label_OPC_I4I1ILOAD},
{OPC_I4I2ILOAD,ISEL_label_OPC_I4I2ILOAD},
{OPC_I4I4ILOAD,ISEL_label_OPC_I4I4ILOAD},
{OPC_F4F4LDID,ISEL_label_OPC_F4F4LDID},
{OPC_U4U1LDID,ISEL_label_OPC_U4U1LDID},
{OPC_U4U2LDID,ISEL_label_OPC_U4U2LDID},
{OPC_U4U4LDID,ISEL_label_OPC_U4U4LDID},
{OPC_I4I1LDID,ISEL_label_OPC_I4I1LDID},
{OPC_I4I2LDID,ISEL_label_OPC_I4I2LDID},
{OPC_I4I4LDID,ISEL_label_OPC_I4I4LDID},
{OPC_F4ISTORE,ISEL_label_OPC_F4ISTORE},
{OPC_I1ISTORE,ISEL_label_OPC_I1ISTORE},
{OPC_I2ISTORE,ISEL_label_OPC_I2ISTORE},
{OPC_I4ISTORE,ISEL_label_OPC_I4ISTORE},
{OPC_U1ISTORE,ISEL_label_OPC_U1ISTORE},
{OPC_U2ISTORE,ISEL_label_OPC_U2ISTORE},
{OPC_U4ISTORE,ISEL_label_OPC_U4ISTORE},
{OPC_U1STID,ISEL_label_OPC_U1STID},
{OPC_I1STID,ISEL_label_OPC_I1STID},
{OPC_U2STID,ISEL_label_OPC_U2STID},
{OPC_I2STID,ISEL_label_OPC_I2STID},
{OPC_F4STID,ISEL_label_OPC_F4STID},
{OPC_U4STID,ISEL_label_OPC_U4STID},
{OPC_I4STID,ISEL_label_OPC_I4STID},
{OPC_XTBOOL16SELECT,ISEL_label_OPC_XTBOOL16SELECT},
{OPC_XTBOOL8SELECT,ISEL_label_OPC_XTBOOL8SELECT},
{OPC_XTBOOL4SELECT,ISEL_label_OPC_XTBOOL4SELECT},
{OPC_XTBOOL2SELECT,ISEL_label_OPC_XTBOOL2SELECT},
{OPC_XTBOOLSELECT,ISEL_label_OPC_XTBOOLSELECT},
{OPC_F4SELECT,ISEL_label_OPC_F4SELECT},
{OPC_U4SELECT,ISEL_label_OPC_U4SELECT},
{OPC_I4SELECT,ISEL_label_OPC_I4SELECT},
{OPC_U4BAND,ISEL_label_OPC_U4BAND},
{OPC_I4BAND,ISEL_label_OPC_I4BAND},
{OPC_U4I4LE,ISEL_label_OPC_U4I4LE},
{OPC_U4I4LT,ISEL_label_OPC_U4I4LT},
{OPC_U4I4GE,ISEL_label_OPC_U4I4GE},
{OPC_U4I4GT,ISEL_label_OPC_U4I4GT},
{OPC_U4I4NE,ISEL_label_OPC_U4I4NE},
{OPC_U4I4EQ,ISEL_label_OPC_U4I4EQ},
{OPC_I4I4LE,ISEL_label_OPC_I4I4LE},
{OPC_I4I4LT,ISEL_label_OPC_I4I4LT},
{OPC_I4I4GE,ISEL_label_OPC_I4I4GE},
{OPC_I4I4GT,ISEL_label_OPC_I4I4GT},
{OPC_I4I4NE,ISEL_label_OPC_I4I4NE},
{OPC_I4I4EQ,ISEL_label_OPC_I4I4EQ},
{OPC_U4U4LE,ISEL_label_OPC_U4U4LE},
{OPC_U4U4LT,ISEL_label_OPC_U4U4LT},
{OPC_U4U4GE,ISEL_label_OPC_U4U4GE},
{OPC_U4U4GT,ISEL_label_OPC_U4U4GT},
{OPC_U4U4NE,ISEL_label_OPC_U4U4NE},
{OPC_U4U4EQ,ISEL_label_OPC_U4U4EQ},
{OPC_I4U4LE,ISEL_label_OPC_I4U4LE},
{OPC_I4U4LT,ISEL_label_OPC_I4U4LT},
{OPC_I4U4GE,ISEL_label_OPC_I4U4GE},
{OPC_I4U4GT,ISEL_label_OPC_I4U4GT},
{OPC_I4U4NE,ISEL_label_OPC_I4U4NE},
{OPC_I4U4EQ,ISEL_label_OPC_I4U4EQ},
{OPC_XTBOOLBNOT,ISEL_label_OPC_XTBOOLBNOT},
{OPC_I4XTBOOLCVT,ISEL_label_OPC_I4XTBOOLCVT},
{OPC_I4F4NE,ISEL_label_OPC_I4F4NE},
{OPC_U4F4NE,ISEL_label_OPC_U4F4NE},
{OPC_FALSEBR,ISEL_label_OPC_FALSEBR},
{OPC_TRUEBR,ISEL_label_OPC_TRUEBR},
{OPC_AGOTO,ISEL_label_OPC_AGOTO},
{OPC_XGOTO,ISEL_label_OPC_XGOTO},
{OPC_GOTO,ISEL_label_OPC_GOTO},
{OPC_REGION_EXIT,ISEL_label_OPC_REGION_EXIT},
{OPC_MICALL,ISEL_label_OPC_MICALL},
{OPC_U8ICALL,ISEL_label_OPC_U8ICALL},
{OPC_I8ICALL,ISEL_label_OPC_I8ICALL},
{OPC_F8ICALL,ISEL_label_OPC_F8ICALL},
{OPC_U4ICALL,ISEL_label_OPC_U4ICALL},
{OPC_F4ICALL,ISEL_label_OPC_F4ICALL},
{OPC_I4ICALL,ISEL_label_OPC_I4ICALL},
{OPC_U2ICALL,ISEL_label_OPC_U2ICALL},
{OPC_I2ICALL,ISEL_label_OPC_I2ICALL},
{OPC_U1ICALL,ISEL_label_OPC_U1ICALL},
{OPC_I1ICALL,ISEL_label_OPC_I1ICALL},
{OPC_VICALL,ISEL_label_OPC_VICALL},
{OPC_MCALL,ISEL_label_OPC_MCALL},
{OPC_U8CALL,ISEL_label_OPC_U8CALL},
{OPC_I8CALL,ISEL_label_OPC_I8CALL},
{OPC_F8CALL,ISEL_label_OPC_F8CALL},
{OPC_U4CALL,ISEL_label_OPC_U4CALL},
{OPC_F4CALL,ISEL_label_OPC_F4CALL},
{OPC_I4CALL,ISEL_label_OPC_I4CALL},
{OPC_U2CALL,ISEL_label_OPC_U2CALL},
{OPC_I2CALL,ISEL_label_OPC_I2CALL},
{OPC_U1CALL,ISEL_label_OPC_U1CALL},
{OPC_I1CALL,ISEL_label_OPC_I1CALL},
{OPC_VCALL,ISEL_label_OPC_VCALL},
{OPC_I4INTRINSIC_CALL,ISEL_label_OPC_I4INTRINSIC_CALL},
{OPC_VINTRINSIC_CALL,ISEL_label_OPC_VINTRINSIC_CALL},
{OPC_BACKWARD_BARRIER,ISEL_label_OPC_BACKWARD_BARRIER},
{OPC_FORWARD_BARRIER,ISEL_label_OPC_FORWARD_BARRIER},
{OPC_DEALLOCA,ISEL_label_OPC_DEALLOCA},
{OPC_U4ALLOCA,ISEL_label_OPC_U4ALLOCA},
{OPC_ASM_STMT,ISEL_label_OPC_ASM_STMT},
{OPC_EVAL,ISEL_label_OPC_EVAL},
{0,0}
};

void ISEL::initialize(void)
{
  ISEL::Op_info *oi = op_info;
  while(oi->labeller) {
    ISEL::add_op_info(oi->op,oi);
    oi++;
  }
}

ISEL::State *ISEL::label(NODEPTR p) {
    State *s;
    s = label1(p);
    return s->has_match_for(stmt_NT) ? s : 0;
}

int ISEL_start = 1;
#ifdef FREE
void ISEL_free(ISEL::State *s)
{
    int i,arity=s->arity;
    if(s->kids) {
      for(i=0;i<arity;i++)
        ISEL_free(s->kids[i]);
      FREE(s->kids);
    }
    FREE(s);
}
#endif FREE
ISEL::State *ISEL_immed(ISEL::State *s,int n)
{
    NODEPTR *children = GET_KIDS(s->node);
    if(s->kids[n])
      return s->kids[n];
    else
    return s->kids[n]=ISEL::label1(children[n]);
}
int ISEL_op_label(NODEPTR p) {
    ISEL_assert(p, PANIC("NULL tree in ISEL_op_label\n"));
    return OP_LABEL(p);
}

ISEL::State *ISEL_state_label(NODEPTR p) {
    ISEL_assert(p, PANIC("NULL tree in ISEL_state_label\n"));
    return ISEL::STATE_LABEL(p);
}

NODEPTR ISEL_child(NODEPTR p, int index) {
    NODEPTR *kids;
    ISEL_assert(p, PANIC("NULL tree in ISEL_child\n"));
    kids=GET_KIDS(p);
    ISEL_assert((0<=index && index<ISEL::STATE_LABEL(p)->arity),
      PANIC("Bad index %d in ISEL_child\n", index));

    return kids[index];
}
NODEPTR *ISEL_kids(NODEPTR p, int eruleno, NODEPTR kids[]) {
    ISEL_assert(p, PANIC("NULL tree in ISEL_kids\n"));
    ISEL_assert(kids, PANIC("NULL kids in ISEL_kids\n"));
    switch (eruleno) {
    case 627: /* breg: bareg */
    case 626: /* b1reg: bareg */
    case 625: /* breg: b1reg */
    case 624: /* bareg: breg */
    case 582: /* expr: tie_imm */
    case 533: /* areg_or_b4constu: b4constu */
    case 532: /* areg_or_b4constu: areg */
    case 531: /* areg_or_b4const: b4const */
    case 530: /* areg_or_b4const: areg */
    case 529: /* areg_or_simm8: simm8 */
    case 528: /* areg_or_simm8: areg */
    case 527: /* areg_or_simm12: simm12 */
    case 526: /* areg_or_simm12: areg */
    case 525: /* areg: float_const */
    case 524: /* areg: simm32 */
    case 523: /* areg: simm12 */
    case 522: /* areg: freg */
    case 521: /* freg: areg */
    case 519: /* areg: acc_reg */
    case 518: /* acc_reg: areg */
    case 514: /* wsar: areg */
    case 513: /* sar_right: areg */
    case 512: /* sar_left: areg */
    case 269: /* expr: freg */
    case 268: /* expr: breg */
    case 267: /* expr: ll_cvt_areg */
    case 266: /* expr: tie_cvt_reg */
    case 265: /* expr: tie_reg */
    case 264: /* expr: areg */
    case 0: /* stmt: expr */
    kids[0] = p;
      break;
    case 700: /* b1reg: OPC_XTBOOLBNOT(b1reg) */
    case 687: /* areg: OPC_U4XTBOOL16CVT(bareg) */
    case 686: /* areg: OPC_U4XTBOOL8CVT(bareg) */
    case 685: /* areg: OPC_U4XTBOOL4CVT(bareg) */
    case 684: /* areg: OPC_U4XTBOOL2CVT(bareg) */
    case 683: /* areg: OPC_U4XTBOOLCVT(bareg) */
    case 682: /* bareg: OPC_XTBOOL16U4CVT(areg) */
    case 681: /* bareg: OPC_XTBOOL8U4CVT(areg) */
    case 680: /* bareg: OPC_XTBOOL4U4CVT(areg) */
    case 679: /* bareg: OPC_XTBOOL2U4CVT(areg) */
    case 678: /* bareg: OPC_XTBOOLU4CVT(areg) */
    case 677: /* areg: OPC_I4XTBOOL16CVT(bareg) */
    case 676: /* areg: OPC_I4XTBOOL8CVT(bareg) */
    case 675: /* areg: OPC_I4XTBOOL4CVT(bareg) */
    case 674: /* areg: OPC_I4XTBOOL2CVT(bareg) */
    case 673: /* areg: OPC_I4XTBOOLCVT(bareg) */
    case 672: /* bareg: OPC_XTBOOL16I4CVT(areg) */
    case 671: /* bareg: OPC_XTBOOL8I4CVT(areg) */
    case 670: /* bareg: OPC_XTBOOL4I4CVT(areg) */
    case 669: /* bareg: OPC_XTBOOL2I4CVT(areg) */
    case 668: /* bareg: OPC_XTBOOLI4CVT(areg) */
    case 657: /* bareg: OPC_XTBOOL16XTBOOL16ILOAD(areg) */
    case 656: /* bareg: OPC_XTBOOL8XTBOOL8ILOAD(areg) */
    case 655: /* bareg: OPC_XTBOOL4XTBOOL4ILOAD(areg) */
    case 654: /* bareg: OPC_XTBOOL2XTBOOL2ILOAD(areg) */
    case 653: /* bareg: OPC_XTBOOLXTBOOLILOAD(areg) */
    case 652: /* breg: OPC_XTBOOL16XTBOOL16ILOAD(areg) */
    case 651: /* breg: OPC_XTBOOL8XTBOOL8ILOAD(areg) */
    case 650: /* breg: OPC_XTBOOL4XTBOOL4ILOAD(areg) */
    case 649: /* breg: OPC_XTBOOL2XTBOOL2ILOAD(areg) */
    case 648: /* breg: OPC_XTBOOLXTBOOLILOAD(areg) */
    case 647: /* expr: OPC_XTBOOL16STID(bareg) */
    case 646: /* expr: OPC_XTBOOL8STID(bareg) */
    case 645: /* expr: OPC_XTBOOL4STID(bareg) */
    case 644: /* expr: OPC_XTBOOL2STID(bareg) */
    case 643: /* expr: OPC_XTBOOLSTID(bareg) */
    case 642: /* expr: OPC_XTBOOL16STID(breg) */
    case 641: /* expr: OPC_XTBOOL8STID(breg) */
    case 640: /* expr: OPC_XTBOOL4STID(breg) */
    case 639: /* expr: OPC_XTBOOL2STID(breg) */
    case 638: /* expr: OPC_XTBOOLSTID(breg) */
    case 637: /* expr: OPC_XTBOOL16STID(bareg) */
    case 636: /* expr: OPC_XTBOOL8STID(bareg) */
    case 635: /* expr: OPC_XTBOOL4STID(bareg) */
    case 634: /* expr: OPC_XTBOOL2STID(bareg) */
    case 633: /* expr: OPC_XTBOOLSTID(bareg) */
    case 632: /* expr: OPC_XTBOOL16STID(breg) */
    case 631: /* expr: OPC_XTBOOL8STID(breg) */
    case 630: /* expr: OPC_XTBOOL4STID(breg) */
    case 629: /* expr: OPC_XTBOOL2STID(breg) */
    case 628: /* expr: OPC_XTBOOLSTID(b1reg) */
    case 618: /* b1reg: OPC_XTBOOLI4CVT(b1reg) */
    case 511: /* areg: OPC_U4I4CVT(areg) */
    case 510: /* areg: OPC_I4U4CVT(areg) */
    case 509: /* areg: OPC_I4CVTL(areg) */
    case 508: /* areg: OPC_U4CVTL(areg) */
    case 507: /* areg: OPC_I4CVTL(areg) */
    case 506: /* areg: OPC_U4CVTL(areg) */
    case 505: /* areg: OPC_I4I1ILDBITS(areg) */
    case 504: /* areg: OPC_I4I2ILDBITS(areg) */
    case 503: /* areg: OPC_I4I4ILDBITS(areg) */
    case 502: /* areg: OPC_I4U1ILDBITS(areg) */
    case 501: /* areg: OPC_I4U2ILDBITS(areg) */
    case 500: /* areg: OPC_I4U4ILDBITS(areg) */
    case 499: /* areg: OPC_U4I1ILDBITS(areg) */
    case 498: /* areg: OPC_U4I2ILDBITS(areg) */
    case 497: /* areg: OPC_U4I4ILDBITS(areg) */
    case 496: /* areg: OPC_U4U1ILDBITS(areg) */
    case 495: /* areg: OPC_U4U2ILDBITS(areg) */
    case 494: /* areg: OPC_U4U4ILDBITS(areg) */
    case 451: /* areg: OPC_I1ISTBITS(areg,OPC_U4LDA) */
    case 450: /* areg: OPC_I2ISTBITS(areg,OPC_U4LDA) */
    case 449: /* areg: OPC_I4ISTBITS(areg,OPC_U4LDA) */
    case 448: /* areg: OPC_U1ISTBITS(areg,OPC_U4LDA) */
    case 447: /* areg: OPC_U2ISTBITS(areg,OPC_U4LDA) */
    case 446: /* areg: OPC_U4ISTBITS(areg,OPC_U4LDA) */
    case 445: /* areg: OPC_I1STBITS(areg) */
    case 444: /* areg: OPC_I2STBITS(areg) */
    case 443: /* areg: OPC_I4STBITS(areg) */
    case 442: /* areg: OPC_U1STBITS(areg) */
    case 441: /* areg: OPC_U2STBITS(areg) */
    case 440: /* areg: OPC_U4STBITS(areg) */
    case 439: /* areg: OPC_I1STBITS(areg) */
    case 438: /* areg: OPC_I2STBITS(areg) */
    case 437: /* areg: OPC_I4STBITS(areg) */
    case 436: /* areg: OPC_U1STBITS(areg) */
    case 435: /* areg: OPC_U2STBITS(areg) */
    case 434: /* areg: OPC_U4STBITS(areg) */
    case 433: /* areg: OPC_U4EXTRACT_BITS(areg) */
    case 432: /* areg: OPC_I4EXTRACT_BITS(areg) */
    case 397: /* areg: OPC_U4LNOT(areg) */
    case 396: /* areg: OPC_I4LNOT(areg) */
    case 395: /* areg: OPC_U4BNOT(areg) */
    case 394: /* areg: OPC_I4BNOT(areg) */
    case 359: /* areg: OPC_U4F4TRUNC(freg) */
    case 358: /* areg: OPC_U4F4CVT(freg) */
    case 357: /* areg: OPC_I4F4TRUNC(freg) */
    case 356: /* areg: OPC_I4F4CVT(freg) */
    case 355: /* freg: OPC_F4U4CVT(areg) */
    case 354: /* freg: OPC_F4I4CVT(areg) */
    case 353: /* freg: OPC_F4RSQRT(freg) */
    case 352: /* freg: OPC_F4RECIP(freg) */
    case 351: /* freg: OPC_F4NEG(freg) */
    case 350: /* freg: OPC_F4ABS(freg) */
    case 341: /* areg: OPC_U4NEG(areg) */
    case 340: /* areg: OPC_I4NEG(areg) */
    case 339: /* areg: OPC_I4ABS(areg) */
    case 306: /* expr: OPC_U8STID(areg) */
    case 305: /* expr: OPC_I8STID(areg) */
    case 304: /* areg: OPC_U4U8ILOAD(areg) */
    case 303: /* areg: OPC_I4I8ILOAD(areg) */
    case 293: /* freg: OPC_F4F4ILOAD(areg) */
    case 292: /* areg: OPC_F4F4ILOAD(areg) */
    case 291: /* areg: OPC_U4U1ILOAD(areg) */
    case 290: /* areg: OPC_U4U2ILOAD(areg) */
    case 289: /* areg: OPC_U4U4ILOAD(areg) */
    case 288: /* areg: OPC_I4I1ILOAD(areg) */
    case 287: /* areg: OPC_I4I2ILOAD(areg) */
    case 286: /* areg: OPC_I4I4ILOAD(areg) */
    case 255: /* expr: OPC_F4STID(freg) */
    case 254: /* expr: OPC_F4STID(areg) */
    case 253: /* expr: OPC_U1STID(areg) */
    case 252: /* expr: OPC_I1STID(areg) */
    case 251: /* expr: OPC_U2STID(areg) */
    case 250: /* expr: OPC_I2STID(areg) */
    case 249: /* expr: OPC_U4STID(areg) */
    case 248: /* expr: OPC_I4STID(areg) */
    case 247: /* expr: OPC_U1STID(areg) */
    case 246: /* expr: OPC_I1STID(areg) */
    case 245: /* expr: OPC_U2STID(areg) */
    case 244: /* expr: OPC_I2STID(areg) */
    case 243: /* expr: OPC_F4STID(freg) */
    case 242: /* expr: OPC_F4STID(areg) */
    case 241: /* expr: OPC_U4STID(areg) */
    case 240: /* expr: OPC_I4STID(areg) */
    case 57: /* stmt: OPC_FALSEBR(b1reg) */
    case 45: /* stmt: OPC_FALSEBR(b1reg) */
    case 40: /* stmt: OPC_TRUEBR(b1reg) */
    case 39: /* stmt: OPC_FALSEBR(areg) */
    case 38: /* stmt: OPC_TRUEBR(areg) */
    case 37: /* stmt: OPC_TRUEBR(one) */
    case 36: /* stmt: OPC_AGOTO(areg) */
    case 35: /* stmt: OPC_XGOTO(areg) */
    case 4: /* stmt: OPC_DEALLOCA(areg) */
    case 3: /* areg: OPC_U4ALLOCA(areg_or_simm8) */
    case 1: /* stmt: OPC_EVAL(expr) */
    kids[0] = ISEL_child(p,0);
      break;
    case 705: /* stmt: OPC_XTBOOL16CALL */
    case 704: /* stmt: OPC_XTBOOL8CALL */
    case 703: /* stmt: OPC_XTBOOL4CALL */
    case 702: /* stmt: OPC_XTBOOL2CALL */
    case 701: /* stmt: OPC_XTBOOLCALL */
    case 623: /* bareg: OPC_XTBOOL16XTBOOL16LDID */
    case 622: /* bareg: OPC_XTBOOL8XTBOOL8LDID */
    case 621: /* bareg: OPC_XTBOOL4XTBOOL4LDID */
    case 620: /* bareg: OPC_XTBOOL2XTBOOL2LDID */
    case 619: /* bareg: OPC_XTBOOLXTBOOLLDID */
    case 617: /* breg: OPC_XTBOOL16XTBOOL16LDID */
    case 616: /* breg: OPC_XTBOOL8XTBOOL8LDID */
    case 615: /* breg: OPC_XTBOOL4XTBOOL4LDID */
    case 614: /* breg: OPC_XTBOOL2XTBOOL2LDID */
    case 613: /* breg: OPC_XTBOOLXTBOOLLDID */
    case 612: /* breg: OPC_XTBOOL16XTBOOL16LDID */
    case 611: /* breg: OPC_XTBOOL8XTBOOL8LDID */
    case 610: /* breg: OPC_XTBOOL4XTBOOL4LDID */
    case 609: /* breg: OPC_XTBOOL2XTBOOL2LDID */
    case 608: /* b1reg: OPC_XTBOOLXTBOOLLDID */
    case 607: /* msalp32: OPC_U4U4LDID */
    case 606: /* msalp32: OPC_I4I4LDID */
    case 605: /* msalp32: OPC_TN */
    case 604: /* msalp32: OPC_U4INTCONST */
    case 603: /* msalp32: OPC_I4INTCONST */
    case 602: /* b4const: OPC_U4U4LDID */
    case 601: /* b4const: OPC_I4I4LDID */
    case 600: /* b4const: OPC_TN */
    case 599: /* b4const: OPC_U4INTCONST */
    case 598: /* b4const: OPC_I4INTCONST */
    case 597: /* b4constu: OPC_U4U4LDID */
    case 596: /* b4constu: OPC_I4I4LDID */
    case 595: /* b4constu: OPC_TN */
    case 594: /* b4constu: OPC_U4INTCONST */
    case 593: /* b4constu: OPC_I4INTCONST */
    case 592: /* uimm5: OPC_U4U4LDID */
    case 591: /* uimm5: OPC_I4I4LDID */
    case 590: /* uimm5: OPC_TN */
    case 589: /* uimm5: OPC_U4INTCONST */
    case 588: /* uimm5: OPC_I4INTCONST */
    case 587: /* uimm4: OPC_U4U4LDID */
    case 586: /* uimm4: OPC_I4I4LDID */
    case 585: /* uimm4: OPC_TN */
    case 584: /* uimm4: OPC_U4INTCONST */
    case 583: /* uimm4: OPC_I4INTCONST */
    case 581: /* tie_imm: OPC_TN */
    case 580: /* tie_imm: OPC_U4INTCONST */
    case 579: /* tie_imm: OPC_I4INTCONST */
    case 578: /* simm32: OPC_TN */
    case 577: /* simm32: OPC_U4INTCONST */
    case 576: /* simm32: OPC_I4INTCONST */
    case 575: /* simm12: OPC_TN */
    case 574: /* simm12: OPC_U4INTCONST */
    case 573: /* simm12: OPC_I4INTCONST */
    case 572: /* simm8: OPC_U4U4LDID */
    case 571: /* simm8: OPC_I4I4LDID */
    case 570: /* simm8: OPC_TN */
    case 569: /* simm8: OPC_U4INTCONST */
    case 568: /* simm8: OPC_I4INTCONST */
    case 567: /* simm8x256: OPC_U4U4LDID */
    case 566: /* simm8x256: OPC_I4I4LDID */
    case 565: /* simm8x256: OPC_TN */
    case 564: /* simm8x256: OPC_U4INTCONST */
    case 563: /* simm8x256: OPC_I4INTCONST */
    case 562: /* clamps_const: OPC_U4U4LDID */
    case 561: /* clamps_const: OPC_I4I4LDID */
    case 560: /* clamps_const: OPC_U4INTCONST */
    case 559: /* clamps_const: OPC_I4INTCONST */
    case 556: /* logical_and_immed: OPC_U4U4LDID */
    case 555: /* logical_and_immed: OPC_I4I4LDID */
    case 554: /* logical_and_immed: OPC_U4INTCONST */
    case 553: /* logical_and_immed: OPC_I4INTCONST */
    case 552: /* bbci_bbsi_imm: OPC_U4U4LDID */
    case 551: /* bbci_bbsi_imm: OPC_I4I4LDID */
    case 550: /* bbci_bbsi_imm: OPC_U4INTCONST */
    case 549: /* bbci_bbsi_imm: OPC_I4INTCONST */
    case 548: /* extui_mask: OPC_U4U4LDID */
    case 547: /* extui_mask: OPC_I4I4LDID */
    case 546: /* extui_mask: OPC_U4INTCONST */
    case 545: /* extui_mask: OPC_I4INTCONST */
    case 544: /* float_const: OPC_F4CONST */
    case 543: /* one: OPC_U4U4LDID */
    case 542: /* thirtytwo: OPC_I4I4LDID */
    case 541: /* thirtytwo: OPC_U4INTCONST */
    case 540: /* thirtytwo: OPC_I4INTCONST */
    case 539: /* one: OPC_U4U4LDID */
    case 538: /* one: OPC_I4I4LDID */
    case 537: /* one: OPC_U4INTCONST */
    case 536: /* one: OPC_I4INTCONST */
    case 535: /* zero: OPC_U4INTCONST */
    case 534: /* zero: OPC_I4INTCONST */
    case 520: /* freg: OPC_TN */
    case 517: /* breg: OPC_TN */
    case 516: /* tie_reg: OPC_TN */
    case 515: /* areg: OPC_TN */
    case 493: /* areg: OPC_I4I1ILDBITS(OPC_U4LDA) */
    case 492: /* areg: OPC_I4I2ILDBITS(OPC_U4LDA) */
    case 491: /* areg: OPC_I4I4ILDBITS(OPC_U4LDA) */
    case 490: /* areg: OPC_I4U1ILDBITS(OPC_U4LDA) */
    case 489: /* areg: OPC_I4U2ILDBITS(OPC_U4LDA) */
    case 488: /* areg: OPC_I4U4ILDBITS(OPC_U4LDA) */
    case 487: /* areg: OPC_U4I1ILDBITS(OPC_U4LDA) */
    case 486: /* areg: OPC_U4I2ILDBITS(OPC_U4LDA) */
    case 485: /* areg: OPC_U4I4ILDBITS(OPC_U4LDA) */
    case 484: /* areg: OPC_U4U1ILDBITS(OPC_U4LDA) */
    case 483: /* areg: OPC_U4U2ILDBITS(OPC_U4LDA) */
    case 482: /* areg: OPC_U4U4ILDBITS(OPC_U4LDA) */
    case 481: /* areg: OPC_I4I1LDBITS */
    case 480: /* areg: OPC_I4I2LDBITS */
    case 479: /* areg: OPC_I4I4LDBITS */
    case 478: /* areg: OPC_I4U1LDBITS */
    case 477: /* areg: OPC_I4U2LDBITS */
    case 476: /* areg: OPC_I4U4LDBITS */
    case 475: /* areg: OPC_U4I1LDBITS */
    case 474: /* areg: OPC_U4I2LDBITS */
    case 473: /* areg: OPC_U4I4LDBITS */
    case 472: /* areg: OPC_U4U1LDBITS */
    case 471: /* areg: OPC_U4U2LDBITS */
    case 470: /* areg: OPC_U4U4LDBITS */
    case 469: /* areg: OPC_I4I1LDBITS */
    case 468: /* areg: OPC_I4I2LDBITS */
    case 467: /* areg: OPC_I4I4LDBITS */
    case 466: /* areg: OPC_I4U1LDBITS */
    case 465: /* areg: OPC_I4U2LDBITS */
    case 464: /* areg: OPC_I4U4LDBITS */
    case 463: /* areg: OPC_U4I1LDBITS */
    case 462: /* areg: OPC_U4I2LDBITS */
    case 461: /* areg: OPC_U4I4LDBITS */
    case 460: /* areg: OPC_U4U1LDBITS */
    case 459: /* areg: OPC_U4U2LDBITS */
    case 458: /* areg: OPC_U4U4LDBITS */
    case 302: /* areg: OPC_U4U8LDID */
    case 301: /* areg: OPC_I4I8LDID */
    case 300: /* ll_cvt_areg: OPC_U8U8LDID */
    case 299: /* areg: OPC_U4U8LDID */
    case 298: /* ll_cvt_areg: OPC_I8I8LDID */
    case 297: /* areg: OPC_I4I8LDID */
    case 296: /* areg: OPC_U4LDA */
    case 295: /* areg: OPC_U4LDA_LABEL */
    case 294: /* areg: OPC_U4LDA */
    case 285: /* freg: OPC_F4F4LDID */
    case 284: /* areg: OPC_F4F4LDID */
    case 283: /* areg: OPC_U4U1LDID */
    case 282: /* areg: OPC_U4U2LDID */
    case 281: /* areg: OPC_U4U4LDID */
    case 280: /* areg: OPC_I4I1LDID */
    case 279: /* areg: OPC_I4I2LDID */
    case 278: /* areg: OPC_I4I4LDID */
    case 277: /* freg: OPC_F4F4LDID */
    case 276: /* areg: OPC_F4F4LDID */
    case 275: /* areg: OPC_U4U1LDID */
    case 274: /* areg: OPC_U4U2LDID */
    case 273: /* areg: OPC_U4U4LDID */
    case 272: /* areg: OPC_I4I1LDID */
    case 271: /* areg: OPC_I4I2LDID */
    case 270: /* areg: OPC_I4I4LDID */
    case 34: /* stmt: OPC_GOTO */
    case 33: /* stmt: OPC_REGION_EXIT */
    case 32: /* stmt: OPC_MICALL */
    case 31: /* stmt: OPC_U8ICALL */
    case 30: /* stmt: OPC_I8ICALL */
    case 29: /* stmt: OPC_F8ICALL */
    case 28: /* stmt: OPC_U4ICALL */
    case 27: /* stmt: OPC_F4ICALL */
    case 26: /* stmt: OPC_I4ICALL */
    case 25: /* stmt: OPC_U2ICALL */
    case 24: /* stmt: OPC_I2ICALL */
    case 23: /* stmt: OPC_U1ICALL */
    case 22: /* stmt: OPC_I1ICALL */
    case 21: /* stmt: OPC_VICALL */
    case 20: /* stmt: OPC_MCALL */
    case 19: /* stmt: OPC_U8CALL */
    case 18: /* stmt: OPC_I8CALL */
    case 17: /* stmt: OPC_F8CALL */
    case 16: /* stmt: OPC_U4CALL */
    case 15: /* stmt: OPC_F4CALL */
    case 14: /* stmt: OPC_I4CALL */
    case 13: /* stmt: OPC_U2CALL */
    case 12: /* stmt: OPC_I2CALL */
    case 11: /* stmt: OPC_U1CALL */
    case 10: /* stmt: OPC_I1CALL */
    case 9: /* stmt: OPC_VCALL */
    case 8: /* stmt: OPC_I4INTRINSIC_CALL */
    case 7: /* stmt: OPC_VINTRINSIC_CALL */
    case 6: /* stmt: OPC_BACKWARD_BARRIER */
    case 5: /* stmt: OPC_FORWARD_BARRIER */
    case 2: /* stmt: OPC_ASM_STMT */
      break;
    case 107: /* stmt: OPC_FALSEBR(OPC_U4I4LE(areg_or_b4const,areg_or_b4const)) */
    case 106: /* stmt: OPC_FALSEBR(OPC_U4I4LT(areg_or_b4const,areg_or_b4const)) */
    case 105: /* stmt: OPC_FALSEBR(OPC_U4I4GE(areg_or_b4const,areg_or_b4const)) */
    case 104: /* stmt: OPC_FALSEBR(OPC_U4I4GT(areg_or_b4const,areg_or_b4const)) */
    case 103: /* stmt: OPC_FALSEBR(OPC_U4I4NE(areg_or_b4const,areg_or_b4const)) */
    case 102: /* stmt: OPC_FALSEBR(OPC_U4I4EQ(areg_or_b4const,areg_or_b4const)) */
    case 101: /* stmt: OPC_TRUEBR(OPC_U4I4LE(areg_or_b4const,areg_or_b4const)) */
    case 100: /* stmt: OPC_TRUEBR(OPC_U4I4LT(areg_or_b4const,areg_or_b4const)) */
    case 99: /* stmt: OPC_TRUEBR(OPC_U4I4GE(areg_or_b4const,areg_or_b4const)) */
    case 98: /* stmt: OPC_TRUEBR(OPC_U4I4GT(areg_or_b4const,areg_or_b4const)) */
    case 97: /* stmt: OPC_TRUEBR(OPC_U4I4NE(areg_or_b4const,areg_or_b4const)) */
    case 96: /* stmt: OPC_TRUEBR(OPC_U4I4EQ(areg_or_b4const,areg_or_b4const)) */
    case 95: /* stmt: OPC_FALSEBR(OPC_I4I4LE(areg_or_b4const,areg_or_b4const)) */
    case 94: /* stmt: OPC_FALSEBR(OPC_I4I4LT(areg_or_b4const,areg_or_b4const)) */
    case 93: /* stmt: OPC_FALSEBR(OPC_I4I4GE(areg_or_b4const,areg_or_b4const)) */
    case 92: /* stmt: OPC_FALSEBR(OPC_I4I4GT(areg_or_b4const,areg_or_b4const)) */
    case 91: /* stmt: OPC_FALSEBR(OPC_I4I4NE(areg_or_b4const,areg_or_b4const)) */
    case 90: /* stmt: OPC_FALSEBR(OPC_I4I4EQ(areg_or_b4const,areg_or_b4const)) */
    case 89: /* stmt: OPC_TRUEBR(OPC_I4I4LE(areg_or_b4const,areg_or_b4const)) */
    case 88: /* stmt: OPC_TRUEBR(OPC_I4I4LT(areg_or_b4const,areg_or_b4const)) */
    case 87: /* stmt: OPC_TRUEBR(OPC_I4I4GE(areg_or_b4const,areg_or_b4const)) */
    case 86: /* stmt: OPC_TRUEBR(OPC_I4I4GT(areg_or_b4const,areg_or_b4const)) */
    case 85: /* stmt: OPC_TRUEBR(OPC_I4I4NE(areg_or_b4const,areg_or_b4const)) */
    case 84: /* stmt: OPC_TRUEBR(OPC_I4I4EQ(areg_or_b4const,areg_or_b4const)) */
    case 83: /* stmt: OPC_FALSEBR(OPC_U4U4LE(areg_or_b4constu,areg_or_b4constu)) */
    case 82: /* stmt: OPC_FALSEBR(OPC_U4U4LT(areg_or_b4constu,areg_or_b4constu)) */
    case 81: /* stmt: OPC_FALSEBR(OPC_U4U4GE(areg_or_b4constu,areg_or_b4constu)) */
    case 80: /* stmt: OPC_FALSEBR(OPC_U4U4GT(areg_or_b4constu,areg_or_b4constu)) */
    case 79: /* stmt: OPC_FALSEBR(OPC_U4U4NE(areg_or_b4const,areg_or_b4const)) */
    case 78: /* stmt: OPC_FALSEBR(OPC_U4U4EQ(areg_or_b4const,areg_or_b4const)) */
    case 77: /* stmt: OPC_TRUEBR(OPC_U4U4LE(areg_or_b4constu,areg_or_b4constu)) */
    case 76: /* stmt: OPC_TRUEBR(OPC_U4U4LT(areg_or_b4constu,areg_or_b4constu)) */
    case 75: /* stmt: OPC_TRUEBR(OPC_U4U4GE(areg_or_b4constu,areg_or_b4constu)) */
    case 74: /* stmt: OPC_TRUEBR(OPC_U4U4GT(areg_or_b4constu,areg_or_b4constu)) */
    case 73: /* stmt: OPC_TRUEBR(OPC_U4U4NE(areg_or_b4const,areg_or_b4const)) */
    case 72: /* stmt: OPC_TRUEBR(OPC_U4U4EQ(areg_or_b4const,areg_or_b4const)) */
    case 71: /* stmt: OPC_FALSEBR(OPC_I4U4LE(areg_or_b4constu,areg_or_b4constu)) */
    case 70: /* stmt: OPC_FALSEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu)) */
    case 69: /* stmt: OPC_FALSEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu)) */
    case 68: /* stmt: OPC_FALSEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu)) */
    case 67: /* stmt: OPC_FALSEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const)) */
    case 66: /* stmt: OPC_FALSEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const)) */
    case 65: /* stmt: OPC_TRUEBR(OPC_I4U4LE(areg_or_b4constu,areg_or_b4constu)) */
    case 64: /* stmt: OPC_TRUEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu)) */
    case 63: /* stmt: OPC_TRUEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu)) */
    case 62: /* stmt: OPC_TRUEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu)) */
    case 61: /* stmt: OPC_TRUEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const)) */
    case 60: /* stmt: OPC_TRUEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const)) */
    case 54: /* stmt: OPC_TRUEBR(OPC_I4U4LT(areg_or_b4constu,areg_or_b4constu)) */
    case 53: /* stmt: OPC_TRUEBR(OPC_I4U4GE(areg_or_b4constu,areg_or_b4constu)) */
    case 52: /* stmt: OPC_TRUEBR(OPC_I4U4GT(areg_or_b4constu,areg_or_b4constu)) */
    case 51: /* stmt: OPC_TRUEBR(OPC_I4U4NE(areg_or_b4const,areg_or_b4const)) */
    case 50: /* stmt: OPC_TRUEBR(OPC_I4U4EQ(areg_or_b4const,areg_or_b4const)) */
    case 47: /* stmt: OPC_FALSEBR(OPC_I4F4NE(freg,freg)) */
    case 46: /* stmt: OPC_FALSEBR(OPC_U4F4NE(freg,freg)) */
    case 42: /* stmt: OPC_TRUEBR(OPC_I4F4NE(freg,freg)) */
    case 41: /* stmt: OPC_TRUEBR(OPC_U4F4NE(freg,freg)) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(p,0),1);
      break;
    case 699: /* b1reg: OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)) */
    case 59: /* stmt: OPC_FALSEBR(OPC_XTBOOLBNOT(b1reg)) */
    case 58: /* stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(b1reg)) */
    case 56: /* stmt: OPC_TRUEBR(OPC_XTBOOLBNOT(b1reg)) */
    case 55: /* stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(b1reg)) */
    case 48: /* stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(b1reg)) */
    case 43: /* stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(b1reg)) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
      break;
    case 49: /* stmt: OPC_FALSEBR(OPC_I4XTBOOLCVT(OPC_XTBOOLBNOT(b1reg))) */
    case 44: /* stmt: OPC_TRUEBR(OPC_I4XTBOOLCVT(OPC_XTBOOLBNOT(b1reg))) */
    kids[0] = ISEL_child(ISEL_child(ISEL_child(p,0),0),0);
      break;
    case 145: /* stmt: OPC_FALSEBR(OPC_U4U4EQ(OPC_U4BAND(logical_and_immed,areg),zero)) */
    case 144: /* stmt: OPC_FALSEBR(OPC_U4U4EQ(OPC_U4BAND(areg,logical_and_immed),zero)) */
    case 141: /* stmt: OPC_FALSEBR(OPC_U4I4EQ(OPC_I4BAND(logical_and_immed,areg),zero)) */
    case 140: /* stmt: OPC_FALSEBR(OPC_U4I4EQ(OPC_I4BAND(areg,logical_and_immed),zero)) */
    case 137: /* stmt: OPC_FALSEBR(OPC_I4U4EQ(OPC_U4BAND(logical_and_immed,areg),zero)) */
    case 136: /* stmt: OPC_FALSEBR(OPC_I4U4EQ(OPC_U4BAND(areg,logical_and_immed),zero)) */
    case 133: /* stmt: OPC_FALSEBR(OPC_I4I4EQ(OPC_I4BAND(logical_and_immed,areg),zero)) */
    case 132: /* stmt: OPC_FALSEBR(OPC_I4I4EQ(OPC_I4BAND(areg,logical_and_immed),zero)) */
    case 131: /* stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(areg,areg),zero)) */
    case 127: /* stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(logical_and_immed,areg),zero)) */
    case 126: /* stmt: OPC_FALSEBR(OPC_U4U4NE(OPC_U4BAND(areg,logical_and_immed),zero)) */
    case 125: /* stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(areg,areg),zero)) */
    case 121: /* stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(logical_and_immed,areg),zero)) */
    case 120: /* stmt: OPC_FALSEBR(OPC_U4I4NE(OPC_I4BAND(areg,logical_and_immed),zero)) */
    case 119: /* stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(areg,areg),zero)) */
    case 115: /* stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(logical_and_immed,areg),zero)) */
    case 114: /* stmt: OPC_FALSEBR(OPC_I4U4NE(OPC_U4BAND(areg,logical_and_immed),zero)) */
    case 113: /* stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(areg,areg),zero)) */
    case 109: /* stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(logical_and_immed,areg),zero)) */
    case 108: /* stmt: OPC_FALSEBR(OPC_I4I4NE(OPC_I4BAND(areg,logical_and_immed),zero)) */
    kids[0] = ISEL_child(ISEL_child(ISEL_child(p,0),0),0);
    kids[1] = ISEL_child(ISEL_child(ISEL_child(p,0),0),1);
    kids[2] = ISEL_child(ISEL_child(p,0),1);
      break;
    case 147: /* stmt: OPC_FALSEBR(OPC_U4U4EQ(zero,OPC_U4BAND(logical_and_immed,areg))) */
    case 146: /* stmt: OPC_FALSEBR(OPC_U4U4EQ(zero,OPC_U4BAND(areg,logical_and_immed))) */
    case 143: /* stmt: OPC_FALSEBR(OPC_U4I4EQ(zero,OPC_I4BAND(logical_and_immed,areg))) */
    case 142: /* stmt: OPC_FALSEBR(OPC_U4I4EQ(zero,OPC_I4BAND(areg,logical_and_immed))) */
    case 139: /* stmt: OPC_FALSEBR(OPC_I4U4EQ(zero,OPC_U4BAND(logical_and_immed,areg))) */
    case 138: /* stmt: OPC_FALSEBR(OPC_I4U4EQ(zero,OPC_U4BAND(areg,logical_and_immed))) */
    case 135: /* stmt: OPC_FALSEBR(OPC_I4I4EQ(zero,OPC_I4BAND(logical_and_immed,areg))) */
    case 134: /* stmt: OPC_FALSEBR(OPC_I4I4EQ(zero,OPC_I4BAND(areg,logical_and_immed))) */
    case 130: /* stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(areg,areg))) */
    case 129: /* stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(logical_and_immed,areg))) */
    case 128: /* stmt: OPC_FALSEBR(OPC_U4U4NE(zero,OPC_U4BAND(areg,logical_and_immed))) */
    case 124: /* stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(areg,areg))) */
    case 123: /* stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(logical_and_immed,areg))) */
    case 122: /* stmt: OPC_FALSEBR(OPC_U4I4NE(zero,OPC_I4BAND(areg,logical_and_immed))) */
    case 118: /* stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(areg,areg))) */
    case 117: /* stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(logical_and_immed,areg))) */
    case 116: /* stmt: OPC_FALSEBR(OPC_I4U4NE(zero,OPC_U4BAND(areg,logical_and_immed))) */
    case 112: /* stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(areg,areg))) */
    case 111: /* stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(logical_and_immed,areg))) */
    case 110: /* stmt: OPC_FALSEBR(OPC_I4I4NE(zero,OPC_I4BAND(areg,logical_and_immed))) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(ISEL_child(p,0),1),0);
    kids[2] = ISEL_child(ISEL_child(ISEL_child(p,0),1),1);
      break;
    case 667: /* expr: OPC_XTBOOL16ISTORE(bareg,areg) */
    case 666: /* expr: OPC_XTBOOL8ISTORE(bareg,areg) */
    case 665: /* expr: OPC_XTBOOL4ISTORE(bareg,areg) */
    case 664: /* expr: OPC_XTBOOL2ISTORE(bareg,areg) */
    case 663: /* expr: OPC_XTBOOLISTORE(bareg,areg) */
    case 662: /* expr: OPC_XTBOOL16ISTORE(breg,areg) */
    case 661: /* expr: OPC_XTBOOL8ISTORE(breg,areg) */
    case 660: /* expr: OPC_XTBOOL4ISTORE(breg,areg) */
    case 659: /* expr: OPC_XTBOOL2ISTORE(breg,areg) */
    case 658: /* expr: OPC_XTBOOLISTORE(breg,areg) */
    case 558: /* logical_and_immed: OPC_U4SHL(one,areg) */
    case 557: /* logical_and_immed: OPC_I4SHL(one,areg) */
    case 457: /* areg: OPC_I1ISTBITS(areg,areg) */
    case 456: /* areg: OPC_I2ISTBITS(areg,areg) */
    case 455: /* areg: OPC_I4ISTBITS(areg,areg) */
    case 454: /* areg: OPC_U1ISTBITS(areg,areg) */
    case 453: /* areg: OPC_U2ISTBITS(areg,areg) */
    case 452: /* areg: OPC_U4ISTBITS(areg,areg) */
    case 431: /* areg: OPC_U4COMPOSE_BITS(areg,areg) */
    case 430: /* areg: OPC_I4COMPOSE_BITS(areg,areg) */
    case 423: /* acc_reg: OPC_U4MPY(areg,areg) */
    case 422: /* acc_reg: OPC_I4MPY(areg,areg) */
    case 411: /* areg: OPC_U4LSHR(areg,sar_right) */
    case 410: /* areg: OPC_I4LSHR(areg,sar_right) */
    case 409: /* areg: OPC_U4ASHR(areg,sar_right) */
    case 408: /* areg: OPC_I4ASHR(areg,sar_right) */
    case 407: /* areg: OPC_U4SHL(areg,sar_left) */
    case 406: /* areg: OPC_I4SHL(areg,sar_left) */
    case 405: /* areg: OPC_U4LSHR(areg,uimm5) */
    case 404: /* areg: OPC_I4LSHR(areg,uimm5) */
    case 403: /* areg: OPC_U4LSHR(areg,uimm4) */
    case 402: /* areg: OPC_I4LSHR(areg,uimm4) */
    case 401: /* areg: OPC_U4ASHR(areg,uimm5) */
    case 400: /* areg: OPC_I4ASHR(areg,uimm5) */
    case 399: /* areg: OPC_U4SHL(areg,msalp32) */
    case 398: /* areg: OPC_I4SHL(areg,msalp32) */
    case 393: /* areg: OPC_U4BXOR(areg,areg) */
    case 392: /* areg: OPC_I4BXOR(areg,areg) */
    case 389: /* areg: OPC_U4BIOR(areg,areg) */
    case 388: /* areg: OPC_I4BIOR(areg,areg) */
    case 387: /* areg: OPC_U4BAND(extui_mask,areg) */
    case 386: /* areg: OPC_U4BAND(areg,extui_mask) */
    case 385: /* areg: OPC_U4BAND(areg,areg) */
    case 384: /* areg: OPC_I4BAND(extui_mask,areg) */
    case 383: /* areg: OPC_I4BAND(areg,extui_mask) */
    case 382: /* areg: OPC_I4BAND(areg,areg) */
    case 381: /* areg: OPC_U4F4NE(freg,freg) */
    case 380: /* b1reg: OPC_U4F4EQ(freg,freg) */
    case 379: /* areg: OPC_U4F4EQ(freg,freg) */
    case 378: /* b1reg: OPC_U4F4GE(freg,freg) */
    case 377: /* areg: OPC_U4F4GE(freg,freg) */
    case 376: /* b1reg: OPC_U4F4LE(freg,freg) */
    case 375: /* areg: OPC_U4F4LE(freg,freg) */
    case 374: /* b1reg: OPC_U4F4GT(freg,freg) */
    case 373: /* areg: OPC_U4F4GT(freg,freg) */
    case 372: /* b1reg: OPC_U4F4LT(freg,freg) */
    case 371: /* areg: OPC_U4F4LT(freg,freg) */
    case 370: /* areg: OPC_I4F4NE(freg,freg) */
    case 369: /* b1reg: OPC_I4F4EQ(freg,freg) */
    case 368: /* areg: OPC_I4F4EQ(freg,freg) */
    case 367: /* b1reg: OPC_I4F4GE(freg,freg) */
    case 366: /* areg: OPC_I4F4GE(freg,freg) */
    case 365: /* b1reg: OPC_I4F4LE(freg,freg) */
    case 364: /* areg: OPC_I4F4LE(freg,freg) */
    case 363: /* b1reg: OPC_I4F4GT(freg,freg) */
    case 362: /* areg: OPC_I4F4GT(freg,freg) */
    case 361: /* b1reg: OPC_I4F4LT(freg,freg) */
    case 360: /* areg: OPC_I4F4LT(freg,freg) */
    case 345: /* freg: OPC_F4DIV(freg,freg) */
    case 344: /* freg: OPC_F4MPY(freg,freg) */
    case 343: /* freg: OPC_F4SUB(freg,freg) */
    case 342: /* freg: OPC_F4ADD(freg,freg) */
    case 330: /* areg: OPC_U4MIN(areg,areg) */
    case 329: /* areg: OPC_I4MIN(areg,areg) */
    case 328: /* areg: OPC_U4MAX(areg,areg) */
    case 327: /* areg: OPC_I4MAX(areg,areg) */
    case 326: /* areg: OPC_U4MOD(areg,areg) */
    case 325: /* areg: OPC_I4MOD(areg,areg) */
    case 324: /* areg: OPC_U4REM(areg,areg) */
    case 323: /* areg: OPC_I4REM(areg,areg) */
    case 322: /* areg: OPC_U4DIV(areg,areg) */
    case 321: /* areg: OPC_I4DIV(areg,areg) */
    case 320: /* areg: OPC_U4MPY(areg,areg) */
    case 319: /* areg: OPC_I4MPY(areg,areg) */
    case 318: /* areg: OPC_U4SUB(areg,simm8x256) */
    case 317: /* areg: OPC_U4SUB(areg,areg_or_simm8) */
    case 316: /* areg: OPC_I4SUB(areg,simm8x256) */
    case 315: /* areg: OPC_I4SUB(areg,areg_or_simm8) */
    case 314: /* areg: OPC_U4ADD(simm8x256,areg) */
    case 313: /* areg: OPC_U4ADD(areg,simm8x256) */
    case 312: /* areg: OPC_U4ADD(simm8,areg) */
    case 311: /* areg: OPC_U4ADD(areg,areg_or_simm8) */
    case 310: /* areg: OPC_I4ADD(simm8x256,areg) */
    case 309: /* areg: OPC_I4ADD(areg,simm8x256) */
    case 308: /* areg: OPC_I4ADD(simm8,areg) */
    case 307: /* areg: OPC_I4ADD(areg,areg_or_simm8) */
    case 263: /* expr: OPC_F4ISTORE(freg,areg) */
    case 262: /* expr: OPC_F4ISTORE(areg,areg) */
    case 261: /* expr: OPC_I1ISTORE(areg,areg) */
    case 260: /* expr: OPC_I2ISTORE(areg,areg) */
    case 259: /* expr: OPC_I4ISTORE(areg,areg) */
    case 258: /* expr: OPC_U1ISTORE(areg,areg) */
    case 257: /* expr: OPC_U2ISTORE(areg,areg) */
    case 256: /* expr: OPC_U4ISTORE(areg,areg) */
    case 171: /* areg: OPC_U4U4LE(areg,areg) */
    case 170: /* areg: OPC_U4U4GE(areg,areg) */
    case 169: /* areg: OPC_U4U4EQ(areg,areg) */
    case 168: /* areg: OPC_U4U4NE(areg,areg) */
    case 167: /* areg: OPC_U4U4GT(areg,areg) */
    case 166: /* areg: OPC_U4U4LT(areg,areg) */
    case 165: /* areg: OPC_I4U4LE(areg,areg) */
    case 164: /* areg: OPC_I4U4GE(areg,areg) */
    case 163: /* areg: OPC_I4U4EQ(areg,areg) */
    case 162: /* areg: OPC_I4U4NE(areg,areg) */
    case 161: /* areg: OPC_I4U4GT(areg,areg) */
    case 160: /* areg: OPC_I4U4LT(areg,areg) */
    case 159: /* areg: OPC_U4I4LE(areg,areg) */
    case 158: /* areg: OPC_U4I4GE(areg,areg) */
    case 157: /* areg: OPC_U4I4EQ(areg,areg) */
    case 156: /* areg: OPC_U4I4NE(areg,areg) */
    case 155: /* areg: OPC_U4I4GT(areg,areg) */
    case 154: /* areg: OPC_U4I4LT(areg,areg) */
    case 153: /* areg: OPC_I4I4LE(areg,areg) */
    case 152: /* areg: OPC_I4I4GE(areg,areg) */
    case 151: /* areg: OPC_I4I4EQ(areg,areg) */
    case 150: /* areg: OPC_I4I4NE(areg,areg) */
    case 149: /* areg: OPC_I4I4GT(areg,areg) */
    case 148: /* areg: OPC_I4I4LT(areg,areg) */
    kids[0] = ISEL_child(p,0);
    kids[1] = ISEL_child(p,1);
      break;
    case 427: /* acc_reg: OPC_U4ADD(OPC_I4MPY(areg,areg),acc_reg) */
    case 425: /* acc_reg: OPC_I4ADD(OPC_I4MPY(areg,areg),acc_reg) */
    case 421: /* areg: OPC_U4SUB(OPC_U4SHL(areg,msalp32),areg) */
    case 420: /* areg: OPC_I4SUB(OPC_I4SHL(areg,msalp32),areg) */
    case 419: /* areg: OPC_U4ADD(OPC_U4SHL(areg,msalp32),areg) */
    case 417: /* areg: OPC_I4ADD(OPC_I4SHL(areg,msalp32),areg) */
    case 391: /* areg: OPC_U4BIOR(OPC_U4SHL(areg,one),one) */
    case 390: /* areg: OPC_I4BIOR(OPC_I4SHL(areg,one),one) */
    case 337: /* areg: OPC_I4MAX(OPC_I4MIN(clamps_const,areg),clamps_const) */
    case 335: /* areg: OPC_I4MAX(OPC_I4MIN(areg,clamps_const),clamps_const) */
    case 333: /* areg: OPC_I4MIN(OPC_I4MAX(clamps_const,areg),clamps_const) */
    case 331: /* areg: OPC_I4MIN(OPC_I4MAX(areg,clamps_const),clamps_const) */
    case 173: /* areg: OPC_I4U4NE(OPC_U4BAND(areg,bbci_bbsi_imm),zero) */
    case 172: /* areg: OPC_I4I4NE(OPC_I4BAND(areg,bbci_bbsi_imm),zero) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(p,0),1);
    kids[2] = ISEL_child(p,1);
      break;
    case 349: /* freg: OPC_F4MSUB(freg,freg,freg) */
    case 348: /* freg: OPC_F4NMSUB(freg,freg,freg) */
    case 347: /* freg: OPC_F4NMADD(freg,freg,freg) */
    case 346: /* freg: OPC_F4MADD(freg,freg,freg) */
    case 239: /* breg: OPC_XTBOOL16SELECT(areg,breg,breg) */
    case 238: /* breg: OPC_XTBOOL8SELECT(areg,breg,breg) */
    case 237: /* breg: OPC_XTBOOL4SELECT(areg,breg,breg) */
    case 236: /* breg: OPC_XTBOOL2SELECT(areg,breg,breg) */
    case 235: /* breg: OPC_XTBOOLSELECT(areg,breg,breg) */
    case 229: /* freg: OPC_F4SELECT(b1reg,freg,freg) */
    case 228: /* areg: OPC_F4SELECT(b1reg,areg,areg) */
    case 227: /* areg: OPC_U4SELECT(b1reg,areg,areg) */
    case 226: /* areg: OPC_I4SELECT(b1reg,areg,areg) */
    case 177: /* freg: OPC_F4SELECT(areg,freg,freg) */
    case 176: /* areg: OPC_F4SELECT(areg,areg,areg) */
    case 175: /* areg: OPC_U4SELECT(areg,areg,areg) */
    case 174: /* areg: OPC_I4SELECT(areg,areg,areg) */
    kids[0] = ISEL_child(p,0);
    kids[1] = ISEL_child(p,1);
    kids[2] = ISEL_child(p,2);
      break;
    case 234: /* freg: OPC_F4SELECT(OPC_I4F4NE(freg,freg),freg,freg) */
    case 225: /* areg: OPC_U4SELECT(OPC_I4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 224: /* areg: OPC_U4SELECT(OPC_I4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 223: /* areg: OPC_U4SELECT(OPC_I4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 222: /* areg: OPC_U4SELECT(OPC_I4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 221: /* areg: OPC_U4SELECT(OPC_I4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 220: /* areg: OPC_U4SELECT(OPC_I4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 219: /* areg: OPC_U4SELECT(OPC_I4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 218: /* areg: OPC_U4SELECT(OPC_I4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 217: /* areg: OPC_U4SELECT(OPC_I4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 216: /* areg: OPC_U4SELECT(OPC_I4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 215: /* areg: OPC_U4SELECT(OPC_I4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 214: /* areg: OPC_U4SELECT(OPC_I4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 213: /* areg: OPC_U4SELECT(OPC_U4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 212: /* areg: OPC_U4SELECT(OPC_U4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 211: /* areg: OPC_U4SELECT(OPC_U4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 210: /* areg: OPC_U4SELECT(OPC_U4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 209: /* areg: OPC_U4SELECT(OPC_U4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 208: /* areg: OPC_U4SELECT(OPC_U4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 207: /* areg: OPC_U4SELECT(OPC_U4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 206: /* areg: OPC_U4SELECT(OPC_U4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 205: /* areg: OPC_U4SELECT(OPC_U4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 204: /* areg: OPC_U4SELECT(OPC_U4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 203: /* areg: OPC_U4SELECT(OPC_U4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 202: /* areg: OPC_U4SELECT(OPC_U4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 201: /* areg: OPC_I4SELECT(OPC_U4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 200: /* areg: OPC_I4SELECT(OPC_U4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 199: /* areg: OPC_I4SELECT(OPC_U4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 198: /* areg: OPC_I4SELECT(OPC_U4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 197: /* areg: OPC_I4SELECT(OPC_U4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 196: /* areg: OPC_I4SELECT(OPC_U4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 195: /* areg: OPC_I4SELECT(OPC_U4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 194: /* areg: OPC_I4SELECT(OPC_U4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 193: /* areg: OPC_I4SELECT(OPC_U4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 192: /* areg: OPC_I4SELECT(OPC_U4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 191: /* areg: OPC_I4SELECT(OPC_U4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 190: /* areg: OPC_I4SELECT(OPC_U4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 189: /* areg: OPC_I4SELECT(OPC_I4I4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 188: /* areg: OPC_I4SELECT(OPC_I4I4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 187: /* areg: OPC_I4SELECT(OPC_I4I4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 186: /* areg: OPC_I4SELECT(OPC_I4I4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 185: /* areg: OPC_I4SELECT(OPC_I4I4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 184: /* areg: OPC_I4SELECT(OPC_I4I4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 183: /* areg: OPC_I4SELECT(OPC_I4U4LE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 182: /* areg: OPC_I4SELECT(OPC_I4U4LT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 181: /* areg: OPC_I4SELECT(OPC_I4U4GE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 180: /* areg: OPC_I4SELECT(OPC_I4U4GT(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 179: /* areg: OPC_I4SELECT(OPC_I4U4NE(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    case 178: /* areg: OPC_I4SELECT(OPC_I4U4EQ(areg_or_simm8,areg_or_simm8),areg_or_simm12,areg_or_simm12) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(p,0),1);
    kids[2] = ISEL_child(p,1);
    kids[3] = ISEL_child(p,2);
      break;
    case 233: /* freg: OPC_F4SELECT(OPC_XTBOOLBNOT(b1reg),freg,freg) */
    case 232: /* areg: OPC_F4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg) */
    case 231: /* areg: OPC_U4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg) */
    case 230: /* areg: OPC_I4SELECT(OPC_XTBOOLBNOT(b1reg),areg,areg) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(p,1);
    kids[2] = ISEL_child(p,2);
      break;
    case 429: /* acc_reg: OPC_U4SUB(acc_reg,OPC_I4MPY(areg,areg)) */
    case 428: /* acc_reg: OPC_I4SUB(acc_reg,OPC_I4MPY(areg,areg)) */
    case 426: /* acc_reg: OPC_U4ADD(acc_reg,OPC_I4MPY(areg,areg)) */
    case 424: /* acc_reg: OPC_I4ADD(acc_reg,OPC_I4MPY(areg,areg)) */
    case 418: /* areg: OPC_U4ADD(areg,OPC_U4SHL(areg,msalp32)) */
    case 416: /* areg: OPC_I4ADD(areg,OPC_I4SHL(areg,msalp32)) */
    case 338: /* areg: OPC_I4MAX(clamps_const,OPC_I4MIN(clamps_const,areg)) */
    case 336: /* areg: OPC_I4MAX(clamps_const,OPC_I4MIN(areg,clamps_const)) */
    case 334: /* areg: OPC_I4MIN(clamps_const,OPC_I4MAX(clamps_const,areg)) */
    case 332: /* areg: OPC_I4MIN(clamps_const,OPC_I4MAX(areg,clamps_const)) */
    kids[0] = ISEL_child(p,0);
    kids[1] = ISEL_child(ISEL_child(p,1),0);
    kids[2] = ISEL_child(ISEL_child(p,1),1);
      break;
    case 413: /* areg: OPC_U4BIOR(OPC_U4LSHR(areg,wsar),OPC_I4SHL(areg,OPC_I4SUB(thirtytwo,areg))) */
    case 412: /* areg: OPC_U4BIOR(OPC_U4LSHR(areg,wsar),OPC_U4SHL(areg,OPC_I4SUB(thirtytwo,areg))) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(p,0),1);
    kids[2] = ISEL_child(ISEL_child(p,1),0);
    kids[3] = ISEL_child(ISEL_child(ISEL_child(p,1),1),0);
    kids[4] = ISEL_child(ISEL_child(ISEL_child(p,1),1),1);
      break;
    case 415: /* areg: OPC_U4BIOR(OPC_I4SHL(areg,OPC_I4SUB(thirtytwo,areg)),OPC_U4LSHR(areg,wsar)) */
    case 414: /* areg: OPC_U4BIOR(OPC_U4SHL(areg,OPC_I4SUB(thirtytwo,areg)),OPC_U4LSHR(areg,wsar)) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(ISEL_child(p,0),1),0);
    kids[2] = ISEL_child(ISEL_child(ISEL_child(p,0),1),1);
    kids[3] = ISEL_child(ISEL_child(p,1),0);
    kids[4] = ISEL_child(ISEL_child(p,1),1);
      break;
    case 698: /* b1reg: OPC_I4BXOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
    case 697: /* b1reg: OPC_I4BIOR(OPC_XTBOOLBNOT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
    case 695: /* b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg)) */
    case 693: /* b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
    case 692: /* b1reg: OPC_I4BAND(OPC_XTBOOLBNOT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
    case 690: /* b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg)) */
    case 688: /* b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(p,1),0);
      break;
    case 694: /* b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))) */
    case 689: /* b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))) */
    kids[0] = ISEL_child(ISEL_child(p,0),0);
    kids[1] = ISEL_child(ISEL_child(ISEL_child(p,1),0),0);
      break;
    case 696: /* b1reg: OPC_I4BIOR(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)),OPC_I4XTBOOLCVT(b1reg)) */
    case 691: /* b1reg: OPC_I4BAND(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)),OPC_I4XTBOOLCVT(b1reg)) */
    kids[0] = ISEL_child(ISEL_child(ISEL_child(p,0),0),0);
    kids[1] = ISEL_child(ISEL_child(p,1),0);
      break;
    default:
      /*CONSTCOND*/
      ISEL_assert(0, PANIC("Bad external rule number %d in ISEL_kids\n", eruleno));
    }
    return kids;
}

/* line 10670 /build/tree/RB-2008.4_kuma/p4root/Xtensa/Software/xcalibur/common/targ_info/static/be/cg/xtensa/isel.pat */

static int trace;

/* ISEL_trace - print trace message for matching p; decrement trace */
static void ISEL_trace(NODEPTR p, int eruleno, int cost, int bestcost) {
	if (trace < 0)
		fprintf(stderr, "0x%x matched %s = %d with cost %d vs. %d\n", p,
			ISEL_string[eruleno], eruleno, cost, bestcost);
	else if (trace > 0 && cost < bestcost) {
		--trace;
		fprintf(stderr, "0x%x matched %s = %d with cost %d\n", p,
			ISEL_string[eruleno], eruleno, cost);
	}
}

/* dumpCover - print the matched cover for p */
static void dumpCover(NODEPTR p, int goalnt, int indent) {
	int eruleno = ISEL::rule(ISEL::STATE_LABEL(p), goalnt);
	short *nts = ISEL_nts[eruleno];
	NODEPTR kids[10];
	int i;

	for (i = 0; i < indent; i++)
		fprintf(stderr, " ");
	fprintf(stderr, "%s\n", ISEL_string[eruleno]);
	ISEL_kids(p, eruleno, kids);
	for (i = 0; nts[i]; i++)
		dumpCover(kids[i], nts[i], indent + 1);
}

MEM_POOL ISEL_Mem_Pool, ISEL_Map_Pool;
WN_MAP ISEL_State_Map;

//=============================================================================
//
// Utility functions to support the pattern matcher.
//
// add_op_info: associate an ISEL::Op_info data structure with the opcode opc.
//    This information is used to store information about rules in which
//    the root of the RHS is a node with the opcode opc.  We use a hash table
//    to do this.
//
// find_op_info: find the op_info associated above.
//
//=============================================================================

/* Maps MTYPE to the 2-bit value for hashing, the table is design such
   that we minimize collison for the most common types */
static unsigned char opc_hash_map[ MTYPE_CORE_LAST+1 ] = {
  0, 0, 0, 0, 
  1 /* MTYPE_I4 */, 0, 0, 0,
  2 /* MTYPE_U4 */, 0, 0, 0,
  0 /* MTYPE_F10 */, 0, 0, 0,
  0 /* MTYPE_M */, 0, 0, 0,
  3 /* MTYPE_V */, 0, 0, 0,
};

struct opcode_hash {
  HASH operator() (const OPCODE opc) const
    {
      int rtype = opc_hash_map[OPCODE_rtype(opc)];
      int desc = opc_hash_map[OPCODE_desc(opc)];
      return (OPCODE_operator(opc)<<4)|(desc<<2)|rtype;
    }
};

struct opcode_eq {
  BOOL operator() (const OPCODE l, const OPCODE r) const
    {
      return l==r;
    }
};

USER_HASH_TABLE<OPCODE,ISEL::Op_info *,opcode_hash,opcode_eq>
                op_info_hash(1<<(OPERATOR_BIT_SIZE+4),Malloc_Mem_Pool);

void ISEL::add_op_info( int opc, ISEL::Op_info *oi )
{
  op_info_hash.Enter( (OPCODE)opc, oi );
}

ISEL::Op_info *ISEL::find_op_info( int opc )
{
  return op_info_hash.Find( (OPCODE)opc );
}

inline ISEL::State *ISEL::STATE_LABEL(WN *p)
{	
  return (ISEL::State *)WN_MAP_Get(ISEL_State_Map,p);
}

inline void ISEL::SET_STATE(WN *p, ISEL::State *s)
{
  WN_MAP_Set(ISEL_State_Map,p,s);
}

inline void *ISEL::ALLOC_FOR_TREE( int size )
{
  return MEM_POOL_Alloc( &ISEL_Mem_Pool, size );
}

inline void *ISEL::ALLOC( int size )
{
  return MEM_POOL_Alloc( &ISEL_Map_Pool, size );
}

inline void *ISEL::REALLOC( void *a, int old_size, int new_size )
{
  return MEM_POOL_Realloc( &ISEL_Map_Pool, a, old_size, new_size ); 
}


//
// ISEL_{Initialize,Finalize}_For_Tree set ups memory allocation for
// the mactching process.  We allocate state structures from a pool
// during labelling and we use Finalize to deallocate them in one fell
// swoop.
//
static void
ISEL_Initialize_For_Tree()
{
  MEM_POOL_Push(&ISEL_Mem_Pool);
}

static void
ISEL_Finalize_For_Tree()
{
  MEM_POOL_Pop(&ISEL_Mem_Pool);
}

/* Given that we want to fit 'value' into an op like:

   op    x, p, value
   
  Compute 'k1', 'k2', 'a', and 'y' to be used like:

   addmi t, p, k1
   addmi t, t, k2
   addi  t, t, a
   op    x, t, y
   
   such that:

   1. k1, k2 >= 0
   2, if 'imm_lcs' contains LC_UNDEFINED then 'y' must be 0, otherwise 'y'
      must fit in every litclass in 'imm_lcs'
   3. if k2 > 0 then k1 > 0
   
   Return true if we can split 'value' in this way. Return false if we
   can't.
*/
static BOOL split_lc_ok (INT64 value, TIE_LITCLASS_LIST *lcs)
{
  for (TIE_LITCLASS_LIST *scan = lcs; scan; scan = scan->_next)
  {
    ISA_LITCLASS lc = scan->_lc;
    
    if (lc == LC_UNDEFINED)
      return value == 0;

    if (!TI_ISA_LC_Value_In_Class(value, lc))
      return FALSE;
  }

  return TRUE;
}

static BOOL split_addi_ok (INT64 value, TIE_LITCLASS_LIST *lcs, INT32 &a)
{
  /* We can use an addi along with 'op' to create offsets from -128 +
     'y' to 127 + 'y'. Most (at least for core instructions) literal
     classes provide a contiguous range of immediates, so we try the
     extremes. If the extremes fail we try every value to catch cases
     where 'lcs' does not contain all contiguous values. Is this too
     expensive? */
  
  if (split_lc_ok(value, lcs))
  {
    a = 0;
    return TRUE;
  }
  else if (split_lc_ok(value-127, lcs))
  {
    a = 127;
    return TRUE;
  }
  else if (split_lc_ok(value+128, lcs))
  {
    a = -128;
    return TRUE;
  }

  for (INT i = -126; i <= 127; i++)
  {
    if (split_lc_ok(value+i, lcs))
    {
      a = -i;
      return TRUE;
    }
  }
  
  return FALSE;
}

static BOOL split_immediate (INT64 value, TIE_LITCLASS_LIST *imm_lcs,
			     INT32 &y, INT32 &k1, INT32 &k2, INT32 &a)
{
  BOOL found = FALSE;

#if 0
  {
    fprintf(TFile, "split_immediate for offset %d, LC = ", (INT32)value);
    for (TIE_LITCLASS_LIST *scan = imm_lcs; scan; scan = scan->_next)
      fprintf(TFile, "%s ", TI_ISA_LC_Name(scan->_lc));
    fprintf(TFile, "\n");
  }
#endif
	  
  /* Maybe 'value' fits as is... */
  y = k1 = k2 = a = 0;
  if (split_lc_ok(value, imm_lcs))
  {
    y = value;
    found = TRUE;
  }
  else
  {
    /* We can use one or two addmi's along with 'op' to create offsets
       from -256*n + 'y' to 256*n + 'y'. We assume that 'imm_lcs'
       accepts a range that is somewhat centered around zero, so we
       try to make 'n' as large as possible so that we leave as little
       for 'y' as possible. We try both leaving the smallest positive
       and negative 'y' value. We could search through all possible
       'n' values here, but that might be too expensive and wuoldn't
       necessarily buy us much. */

    INT32 k = value / 256;
    if (value < 0)
      k--;

    if (split_addi_ok(value - (k * 256), imm_lcs, a))
    {
      found = TRUE;
    }
    else if (split_addi_ok(value - (k * 256) - 256, imm_lcs, a))
    {
      k++;
      found = TRUE;
    }
    
    y = value - (k * 256) - a;

    /* Break 'k' into 'k1' and 'k2'. */

    k1 = k;
    if (k1 > 127)
      k1 = 127;
    else if (k1 < -128)
      k1 = -128;
  
    k2 = k - k1;

    if ((k2 > 127) || (k2 < -128))
      found = FALSE;

    k1 *= 256;
    k2 *= 256;
  }

  return found;
}

static TIE_LITCLASS_LIST *offset_litclasses (TOP op)
{
  static TIE_LITCLASS_LIST lc_undef(LC_UNDEFINED, NULL);
  static TIE_LITCLASS_LIST lc_simm8(LC_simm8, NULL);

  if (op == TOP_UNDEFINED)
    return &lc_undef;

  /* Special cases... */
  if (op == TOP_addi)
    return &lc_simm8;
  
  /* From here we only expect memory ops. Find the offset field and
     return it's litclass. If 'op' doesn't have an offset field,
     return LC_UNDEFINED to indicate that only offset 0 is allowed. */
  Is_True(TI_ISA_Property_Set(PROP_load, op) ||
	  TI_ISA_Property_Set(PROP_store, op) ||
	  TI_ISA_Property_Set(PROP_prefetch, op),
	  ("expecting memory op"));
  
  INT offset_opnd = TI_TOP_Find_Operand_Use(op, OU_offset);
  if (offset_opnd == -1)
    return &lc_undef;

  const ISA_OPERAND_INFO *info = TI_ISA_Operand_Info(op);
  const ISA_OPERAND_VALTYP *vt = TI_ISA_Op_Operand(info, offset_opnd);
  if (!TI_ISA_Valtyp_Is_Literal(vt))
    return &lc_undef;
  return CXX_NEW(TIE_LITCLASS_LIST(TI_ISA_Valtyp_Litclass(vt), NULL), &ISEL_Mem_Pool);
}

static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    ST *s, INT64 o, OPS *ops,
                            bool conservative_addr,
			    bool is_tie_macro,
			    bool is_float)
{
  TN *base_tn;
  ST *base_sym;
  INT32 a, k1, k2, y;
  INT64 base_ofst;
  TIE_MACRO_p tie_macro = NULL;
  TN* in_operands[3];
  TIE_LITCLASS_LIST *offset_lcs;
  
  if (is_tie_macro)
  {
    tie_macro = tie_info->tie_macro((TIE_MACRO_ID)op);
    op = TOP_UNDEFINED;
    offset_lcs = tie_offset_litclass(tie_macro, 2);
    FmtAssert(offset_lcs, ("unexpected, tie macro %s, does not use immediate operand 2",
			   tie_macro->name()));
  }
  else
  {
    offset_lcs = offset_litclasses(op);
  }
  
  Base_Symbol_And_Offset_For_Addressing( s, o, &base_sym, &base_ofst);
  if( base_sym == SP_Sym )
    base_tn = SP_TN;
  else if(base_sym == FP_Sym)
    base_tn = FP_TN;
  else
  {
    switch (ST_storage_class(*s))
    {
    case SCLASS_FSTATIC:
    case SCLASS_MERGE_STRING:
    case SCLASS_PSTATIC:
    case SCLASS_EXTERN:
    {
      base_tn = Generate_Constant(MTYPE_U4, NULL, NULL, s, o, ops);
      if (!is_tie_macro)
	if (is_float) {
	  TN* state2 = cpenable_tn(op);
	  if (state2)
	    Build_OP( op, val, base_tn, Gen_Literal_TN( 0, 4 ), state2 /* cpenable_tn() */, ops );
	  else
	    Build_OP( op, val, base_tn, Gen_Literal_TN( 0, 4 ), ops );
	} else {
	  Build_OP( op, val, base_tn, Gen_Literal_TN( 0, 4 ), ops );
	}
      else {
	in_operands[0]=val;
	in_operands[1]=base_tn;
	in_operands[2]=Gen_Literal_TN( 0, 4 );
	expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
      }
      return;
    }
      
    default:
      //
      // So far only static cases can show up here but that probably isn't true
      // in general.  Probably all sorts of C++ stuff will get here and fail.
      //
      FmtAssert(FALSE, ("Unhandled storage class %s for symbol %s",
			Sclass_Name(ST_storage_class(*s)), ST_name(*s)));
    }
  }

  /* split base_ofst into three numbers y appropriate for the offset
     field of 'op', and k1, and k2 appropriate for addmi */

  BOOL split = split_immediate(base_ofst, offset_lcs, y, k1, k2, a);

  if (conservative_addr || !split)
  {
    /* generate constant, add, 'op' */
    
    TN *tmp;
    TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);

    if( conservative_addr || (s!=base_sym) )
    {
      tmp = Generate_Constant(MTYPE_U4, NULL, NULL, s, o, ops);
    }
    else
    {
      tmp = Generate_Constant(MTYPE_I4, NULL, base_ofst, ops);
    }

    Build_OP( TOP_add, tmp1, base_tn, tmp, ops );
    if (!is_tie_macro)
    {
      if (is_float) {
	TN* state2 = cpenable_tn(op);
	if (state2)
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), state2 /* cpenable_tn() */, ops );
	else
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      } else {
        Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      }
    }
    else
    {
      in_operands[0]=val;
      in_operands[1]=tmp1;
      in_operands[2]=Gen_Literal_TN( 0, 4 );
      expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
    }
  }
  else
  {
    TN *tmp = base_tn;
    if( k2 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k2, 4 ), ops );
      tmp = tmp1;
    }

    if( k1 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k1, 4 ), ops );
      tmp = tmp1;
    }

    if( a != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addi, tmp1, tmp, Gen_Literal_TN( a, 4 ), ops );
      tmp = tmp1;
    }

    /* We must use a symbol tn so that adjustments to the symbol
       offsets made for data layout (which occur after register
       allocation, and perhaps elsewhere) can correctly adjust the
       offset of the symbol. */
    if( s!=base_sym )
    {
      if (!is_tie_macro)
      {
	if (is_float) {
	  TN* state2 = cpenable_tn(op);
	  if (state2)
	    Build_OP( op, val, tmp, Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE),
			state2 /* cpenable_tn() */, ops );
	  else
	    Build_OP( op, val, tmp, Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE), ops );
	} else {
	  Build_OP( op, val, tmp, Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE), ops );
	}
      }
      else
      {
	in_operands[0]=val;
	in_operands[1]=tmp;
	in_operands[2]=Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE);
	expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
      }
    }
    else
    {
      if (!is_tie_macro)
      {
	if (is_float) {
	  TN* state2 = cpenable_tn(op);
	  if (state2)
	    Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ),
			state2 /* cpenable_tn() */, ops );
	  else
	    Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
	} else {
	  Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
	}
      }
      else
      {
	in_operands[0]=val;
	in_operands[1]=tmp;
	in_operands[2]=Gen_Literal_TN( y, 4 );
	expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
      }
    }
  }
}

static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    TN *base_tn, INT64 base_ofst, OPS *ops,
			    bool is_tie_macro,
			    bool is_float)
{
  INT32 a, k1, k2, y;
  TIE_MACRO_p tie_macro = NULL;
  TN* in_operands[3];
  TIE_LITCLASS_LIST *offset_lcs;

  if (is_tie_macro)
  {
    tie_macro = tie_info->tie_macro((TIE_MACRO_ID)op);
    op = TOP_UNDEFINED;
    offset_lcs = tie_offset_litclass(tie_macro, 2);
    FmtAssert(offset_lcs, ("unexpected, tie macro %s, does not use immediate operand 2",
			   tie_macro->name()));
  }
  else
  {
    offset_lcs = offset_litclasses(op);
  }
  
  /* split base_ofst into three numbers y appropriate for the offset
     field of 'op', and k1, and k2 appropriate for addmi */

  BOOL split = split_immediate(base_ofst, offset_lcs, y, k1, k2, a);

  if (!split)
  {
    /* generate load_const, add, 'op' */
    
    TN *tmp = Generate_Constant(MTYPE_I4, NULL, base_ofst, ops);
    TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);

    Build_OP( TOP_add, tmp1, base_tn, tmp, ops );
    if (!is_tie_macro)
    {
      if (is_float) {
	TN* state2 = cpenable_tn(op);
	if (state2)
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), state2 /* cpenable_tn() */, ops );
	else
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      } else {
        Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      }
    }
    else
    {
      in_operands[0]=val;
      in_operands[1]=tmp1;
      in_operands[2]=Gen_Literal_TN( 0, 4 );
      expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
    }
  }
  else
  {
    TN *tmp = base_tn;
    if( k2 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k2, 4 ), ops );
      tmp = tmp1;
    }

    if( k1 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k1, 4 ), ops );
      tmp = tmp1;
    }
    
    if( a != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addi, tmp1, tmp, Gen_Literal_TN( a, 4 ), ops );
      tmp = tmp1;
    }

    if (!is_tie_macro)
    {
      if (is_float) {
	TN* state2 = cpenable_tn(op);
	if (state2)
          Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), state2 /* cpenable_tn() */, ops );
	else
          Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
      } else {
        Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
      }
    }
    else
    {
      in_operands[0]=val;
      in_operands[1]=tmp;
      in_operands[2]=Gen_Literal_TN( y, 4 );
      expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
    }
  }
}

static void Generate_Unaligned_Store(TYPE_ID mem_type, TN *val, TN *addr, 
					 INT16 variant, OPS *ops)
{
  TOP op = TOP_UNDEFINED;
  TYPE_ID piece_type;
  INT piece_size = Get_alignment(variant)*8;
  if (MTYPE_bit_size(mem_type) <= piece_size) {
    Is_True(0,("Undefined case"));
    //Build_OP( op, val, addr, Gen_Literal_TN( 0, 4 ), ops );
    return;
  }

  DevWarn("generating unaligned store");
  switch (piece_size)
  {
  case 32:
    op = TOP_s32i;
    piece_type = MTYPE_U4;
    break;
    
  case 16:
    op = TOP_s16i;
    piece_type = MTYPE_U2;
    break;

  case 8:
    op = TOP_s8i;
    piece_type = MTYPE_U1;
    break;
  }

  INT offset;
  INT bits_processed = 0;
  TN *tmp_val = Build_TN_Of_Mtype(MTYPE_U4);
  if (xt_hard_float && (mem_type == MTYPE_F4)) {
    Generate_Unary_FP(MTYPE_U4, TI_TOP_Topcode("rfr"), tmp_val, val, ops);
  } else {
    Build_OP( TOP_mov_n, tmp_val, val, ops );
  }

  while (bits_processed < MTYPE_bit_size(mem_type)) {
    bits_processed += piece_size;
    offset = (Target_Byte_Sex == BIG_ENDIAN) ? 
      MTYPE_bit_size(mem_type) - bits_processed : 
      bits_processed-piece_size;
    Build_OP( op, tmp_val, addr, Gen_Literal_TN(offset/8, 4 ), ops );
    if (bits_processed < MTYPE_bit_size(mem_type)) {
      if (piece_size < 16)
        Build_OP(TOP_srli, tmp_val, tmp_val, Gen_Literal_TN(piece_size,4), ops);
      else
        Build_OP(TOP_extui, tmp_val, tmp_val, Gen_Literal_TN(piece_size,4), Gen_Literal_TN(32-piece_size,4), ops);
    }
  }
}

static void Generate_Unaligned_Load(TYPE_ID mem_type, TN *val, TN *addr, 
					 INT16 variant, OPS *ops)
{
  TOP op = TOP_UNDEFINED;
  TYPE_ID piece_type;
  INT piece_size = Get_alignment(variant)*8;
  if (MTYPE_bit_size(mem_type) <= piece_size) {
    Is_True(0,("Undefined case"));
    //Build_OP( op, val, addr, Gen_Literal_TN( 0, 4 ), ops );
    return;
  }

  TN *tmp_val = Build_TN_Of_Mtype(MTYPE_U4);
  DevWarn("generating unaligned load");
  switch (piece_size)
  {
  case 32:
    op = TOP_l32i;
    piece_type = MTYPE_U4;
    break;
    
  case 16:
    op = TOP_l16ui;
    piece_type = MTYPE_U2;
    break;

  case 8:
    op = TOP_l8ui;
    piece_type = MTYPE_U1;
    break;
  }

  INT offset;
  INT bits_processed = piece_size;
  offset = (Target_Byte_Sex == BIG_ENDIAN) ? 
    bits_processed-piece_size:
    MTYPE_bit_size(mem_type) - piece_size ;

  /* Sign extend the upper bits */
  if (MTYPE_is_signed(mem_type) && 
      (MTYPE_bit_size(mem_type) < MTYPE_bit_size(MTYPE_I4) &&
      (piece_size == 16))) {
    Build_OP( TOP_l16si, tmp_val, addr, Gen_Literal_TN( offset/8, 4 ), ops );
  } else {
    Build_OP( op, tmp_val, addr, Gen_Literal_TN( offset/8, 4 ), ops );
  }

  while (bits_processed < MTYPE_bit_size(mem_type)) {
    TN *tmp_piece = Build_TN_Of_Mtype(piece_type);
    bits_processed += piece_size;
    offset = (Target_Byte_Sex == BIG_ENDIAN) ? 
      bits_processed-piece_size:
      MTYPE_bit_size(mem_type) - bits_processed ;
    Build_OP( TOP_slli, tmp_val, tmp_val, Gen_Literal_TN(piece_size, 4), ops );
    Build_OP( op, tmp_piece, addr, Gen_Literal_TN( offset/8, 4 ), ops );
    Build_OP( TOP_or, tmp_val, tmp_val, tmp_piece, ops );
  }

  if (MTYPE_is_signed(mem_type) && 
      (MTYPE_bit_size(mem_type) < MTYPE_bit_size(MTYPE_I4) &&
      (piece_size != 16))) {
    Generate_Extend(mem_type, val, tmp_val, MTYPE_bit_size(mem_type), ops);
  } else if (xt_hard_float && (mem_type == MTYPE_F4)) {
    Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), val, tmp_val, ops);
  } else {
    Build_OP( TOP_mov_n, val, tmp_val, ops );
  }
}

static void
Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, ST *s, INT64 o, INT16 variant, OPS *ops)
{
  Allocate_Object(s);
  Set_Last_Mem_OP( ops );

  TOP op = TOP_UNDEFINED;
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_s32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("ssi") : TOP_s32i);
    break;
    
  case MTYPE_U2:
  case MTYPE_I2:
    op = TOP_s16i;
    break;

  case MTYPE_I1:
  case MTYPE_U1:
    op = TOP_s8i;
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  TYPE_ID val_mtype = TN_mtype(val);
  if (MTYPE_is_tie(val_mtype) || MTYPE_is_tie(desc)) {
    if (TN_is_register(val) && TN_is_dedicated(val))
      val_mtype = desc;
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot store unaligned tie variable"));
    if (desc==val_mtype) {
      tie_macro = tie_info->mtype_storei_macro(desc);
    } else if (tree && WN_operator(WN_kid0(tree))==OPR_CVT) {

      // a TIE converting store
      // try to use mtypes in the CVT node if there is one since
      // that is the one checked by tie_rtom_rule_label
      // and we have problem when the source of the conversion
      // has different but compatible type and we want to make sure
      // I2 converting is used instead of I4 (see PR10880):
      //
      //	I4INTCONST 2 (0x2)
      //      _TIE_new_veclevelI2CVT
      //      U4U4LDID 0 <2,4,level> T<36,anon_ptr.,4>
      //     _TIE_new_veclevelISTORE 0 T<36,anon_ptr.,4> {freq: 0, ln: 24, col: 0}

      WN* kid = WN_kid0(tree);
      TYPE_ID cvt_desc = WN_desc(kid);
      tie_macro = tie_info->mtype_rtom_macro(cvt_desc, desc);
    } else
      tie_macro = tie_info->mtype_rtom_macro(val_mtype, desc);

    if (tie_macro==NULL && TN_is_register(val) && TN_is_dedicated(val) &&
	  TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(val))
      tie_macro = tie_info->mtype_storei_macro(desc);

    Generate_OP_And_Address_Computation((TOP)tie_macro->id(),
					val, s, o, ops,
					use_conservative_addressing(s),
					/* is_tie_macro = */true,
					/* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create store for type %s", Mtype_Name(desc)));

    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Store(desc, val, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, val, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }
  if( tree )
    Set_OP_To_WN_Map( tree );
}

static void
Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, TN *addr, INT64 o, INT16 variant, OPS *ops)
{
  Set_Last_Mem_OP( ops );

  TOP op = TOP_UNDEFINED;
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_s32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("ssi") : TOP_s32i);
    break;
    
  case MTYPE_U2:
  case MTYPE_I2:
    op = TOP_s16i;
    break;

  case MTYPE_I1:
  case MTYPE_U1:
    op = TOP_s8i;
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  TYPE_ID val_mtype = TN_mtype(val);
  if (MTYPE_is_tie(val_mtype) || MTYPE_is_tie(desc)) {
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot store unaligned tie variable"));
    if (desc==val_mtype) {
      tie_macro = tie_info->mtype_storei_macro(desc);
    } else if (tree && WN_operator(WN_kid0(tree))==OPR_CVT) {

      // a TIE converting store
      // try to use mtypes in the CVT node if there is one since
      // that is the one checked by tie_rtom_rule_label
      // and we have problem when the source of the conversion
      // has different but compatible type and we want to make sure
      // I2 converting is used instead of I4 (see PR10880):
      //
      //	I4INTCONST 2 (0x2)
      //      _TIE_new_veclevelI2CVT
      //      U4U4LDID 0 <2,4,level> T<36,anon_ptr.,4>
      //     _TIE_new_veclevelISTORE 0 T<36,anon_ptr.,4> {freq: 0, ln: 24, col: 0}

      WN* kid = WN_kid0(tree);
      TYPE_ID cvt_desc = WN_desc(kid);
      tie_macro = tie_info->mtype_rtom_macro(cvt_desc, desc);
    } else
      tie_macro = tie_info->mtype_rtom_macro(val_mtype, desc);

    if (tie_macro==NULL && TN_is_register(val) && TN_is_dedicated(val) &&
	  TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(val))
      tie_macro = tie_info->mtype_storei_macro(desc);

    Generate_OP_And_Address_Computation( (TOP)tie_macro->id(),
					    val, addr, o, ops,
					    /* is_tie_macro = */true,
					    /* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create store for type %s", Mtype_Name(desc)));

    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Store(desc, val, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, val, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }
  if( tree )
    Set_OP_To_WN_Map( tree );
}

static TN *
Generate_Load_Memory( WN *tree, TYPE_ID rtype, TYPE_ID desc,
		      TN *result, ST *s, INT64 o, INT16 variant, OPS *ops )
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  Allocate_Object(s);
  Set_Last_Mem_OP( ops );

  FmtAssert((rtype == MTYPE_U4) || (rtype == MTYPE_I4) || (rtype == MTYPE_F4)
	    || (MTYPE_is_tie(rtype)) || (MTYPE_is_tie(desc)),
	    ("cannot create load to result type %s", Mtype_Name(rtype)));
  
  TOP op = TOP_UNDEFINED;
  TN *tresult = NULL;
  
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_l32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("lsi") : TOP_l32i);
    break;
    
  case MTYPE_U2:
    op = TOP_l16ui;
    break;

  case MTYPE_I2:
    op = TOP_l16si;
    break;

  case MTYPE_U1:
    op = TOP_l8ui;
    break;

  case MTYPE_I1:
    op = TOP_l8ui;
    if (TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer()) {
      tresult = result;
      result = Build_TN_Of_Mtype(rtype);
    }
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  if (MTYPE_is_tie(rtype) || MTYPE_is_tie(desc)) {
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot load unaligned tie variable"));
    if (desc==rtype)
	tie_macro = tie_info->mtype_loadi_macro(desc);
    else {
	tie_macro = tie_info->mtype_mtor_macro(desc, rtype);

        if (tie_macro==NULL && TN_is_register(result) && TN_is_dedicated(result) &&
	    TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(result))
          tie_macro = tie_info->mtype_storei_macro(desc);
    }

    Generate_OP_And_Address_Computation((TOP)tie_macro->id(),
					result, s, o, ops, 
					use_conservative_addressing(s),
					/* is_tie_macro = */true,
					/* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create load for rtype %s, desc %s",
				    Mtype_Name(rtype), Mtype_Name(desc)));
  
    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Load(desc, result, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, result, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }

  if (desc == MTYPE_I1 &&
      TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer())
    result = Generate_Extend(MTYPE_I4, tresult, result, 8, ops);

  /* If the symbol is constant, then the last instruction we generated
     should be a load of that constant, and we can show it as not
     aliasing anything. */
  
  if (ST_is_constant(s))
  {
    OP *last = OPS_last(ops);
    if (last && OP_load(last))
      Set_OP_no_alias(last);
  }
  
  if( tree )
    Set_OP_To_WN_Map( tree );

  return result;
}

static TN *
Generate_Load_Memory( WN *tree, TYPE_ID rtype, TYPE_ID desc,
		      TN *result, TN *addr, INT64 o, INT16 variant, OPS *ops )
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  Set_Last_Mem_OP( ops );

  FmtAssert((rtype == MTYPE_U4) || (rtype == MTYPE_I4) || (rtype == MTYPE_F4)
	    || (MTYPE_is_tie(rtype)) || (MTYPE_is_tie(desc)),
	    ("cannot create load to result type %s", Mtype_Name(rtype)));
  
  TOP op = TOP_UNDEFINED;
  TN *tresult = NULL;
  
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_l32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("lsi") : TOP_l32i);
    break;
    
  case MTYPE_U2:
    op = TOP_l16ui;
    break;

  case MTYPE_I2:
    op = TOP_l16si;
    break;

  case MTYPE_U1:
    op = TOP_l8ui;
    break;

  case MTYPE_I1:
    op = TOP_l8ui;
    if (TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer()) {
      tresult = result;
      result = Build_TN_Of_Mtype(rtype);
    }
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  if (MTYPE_is_tie(rtype) || MTYPE_is_tie(desc)) {
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot load unaligned tie variable"));
    if (desc==rtype)
	tie_macro = tie_info->mtype_loadi_macro(desc);
    else {
	tie_macro = tie_info->mtype_mtor_macro(desc, rtype);

        if (tie_macro==NULL && TN_is_register(result) && TN_is_dedicated(result) &&
	    TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(result))
          tie_macro = tie_info->mtype_storei_macro(desc);
    }
    Generate_OP_And_Address_Computation((TOP)tie_macro->id(),
					result, addr, o, ops,
					/* is_tie_macro = */true,
					/* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create load for rtype %s, desc %s",
				  Mtype_Name(rtype), Mtype_Name(desc)));
  
    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Load(desc, result, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, result, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }

  if (desc == MTYPE_I1 &&
      TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer())
    result = Generate_Extend(MTYPE_I4, tresult, result, 8, ops);

  if( tree )
    Set_OP_To_WN_Map( tree );

  return result;
}

static ST *Generate_Pu_Static_Symbol(TYPE_ID mtype)
{
  ST *lc;

  /* Create a reference to the literal and put it in the  literal pool */
  lc = New_ST(CURRENT_SYMTAB);
  ST_Init( lc, Save_Str(Exp_Unique_Literal_Name()), CLASS_VAR,
	   SCLASS_PSTATIC, EXPORT_LOCAL,
	   MTYPE_To_TY(mtype));
  Set_ST_is_initialized(lc);
  Set_ST_is_const_var(lc);
  Allocate_Object(lc);
  return lc;
}

static ST *Generate_Literal_Symbol()
{
  ST *lc;

  /* Create a reference to the literal and put it in the  literal pool */
  lc = New_ST(CURRENT_SYMTAB);
  ST_Init( lc, Save_Str(Exp_Unique_Literal_Name()), CLASS_VAR,
	   SCLASS_LITERAL_POOL, EXPORT_LOCAL,
	   MTYPE_To_TY(MTYPE_U4));
  Set_ST_is_initialized(lc);
  Set_ST_is_temp_var(lc);
  Set_ST_is_const_var(lc);
  Allocate_Object(lc);
  return lc;
}

#if 0
// xtensa doesn't use this function, and if we decide to,
// we will have to update it for const16
// need to be updated for const16

// See description above
static ST *Generate_Literal_Pointer( ST *s, INT64 o )
{
  ST *base_sym;
  INT64 base_ofst;
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;

  Allocate_Object(s);
  Base_Symbol_And_Offset_For_Addressing( s, o, &base_sym, &base_ofst);

  lc = Generate_Literal_Symbol();
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Symoff(inv,base_sym,base_ofst);

  return lc;
}
#endif

static ST *Generate_Literal_Pointer_Nonbased( ST *s, INT64 o )
{
  INITV_IDX inv;

  Allocate_Object(s);

  ST *lc = Generate_Literal_Symbol();
  INITO_IDX ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Symoff(inv,s,o);

  return lc;
}

static ST *Generate_Literal_Label( LABEL_IDX lab )
{
  INITV_IDX inv;

  ST *lc = Generate_Literal_Symbol();
  INITO_IDX ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Label(inv,lab);

  return lc;
}

static ST *Generate_Literal_Float( float v )
{
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;

  lc = Generate_Literal_Symbol();
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Float(inv, MTYPE_F4, v);

  return lc;
}

static ST *Generate_Literal_Integer( int v )
{
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;

  lc = Generate_Literal_Symbol();
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Integer(inv, MTYPE_I4, v);

  return lc;
}

static ST *Generate_Literal_Tie(TYPE_ID mtype, int v)
{
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;
  int mtype_size;
  int byte_count;

  lc = Generate_Pu_Static_Symbol(mtype);
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Integer(inv, mtype, v);

  return lc;
}

static BOOL Label_ICall ( WN *n, COST *cost)
{
  COST c;
  WN *target = WN_kid(n, WN_kid_count(n) - 1);
  if (!ISEL::match(target, ISEL::find_nonterm("areg"), c))
  {
    *cost = COST_INFINITY;
    return FALSE;
  }
  
  cost->cost = c.cost + 1;
  return TRUE;
}

static void Generate_ICall( WN *n, TOP top, OPS *ops )
{
  WN *target = WN_kid(n, WN_kid_count(n) - 1);
  TN *tn = areg_action(ISEL::STATE_LABEL(target), 0, ops);
  TN *ret_addr_tn = 0;
  ISA_REGCLASS ar = TI_ISA_Regclass_Integer();
  REGISTER ret_addr_reg;
  INT first_reg = TI_ISA_Regclass_First_Reg(TI_ISA_Regclass_Info(ar)) +
    REGISTER_MIN;
  switch (top) {
  case TOP_callx0:
    ret_addr_reg = first_reg + 0; break;
  case TOP_callx4:
    ret_addr_reg = first_reg + 4; break;
  case TOP_callx8:
    ret_addr_reg = first_reg + 8; break;
  case TOP_callx12:
    ret_addr_reg = first_reg + 12; break;
  }
  ret_addr_tn = Build_Dedicated_TN(ar, ret_addr_reg, 4);
  
  PU_Has_Calls = TRUE;
  Set_Last_Mem_OP( ops );
  Build_OP( top, ret_addr_tn, tn, ops );
  Handle_Call_Site_Extras( n, WN_operator( n ) );
}

static BOOL
MUL16_arg_cost (WN *result_wn, WN *left, WN *right,
                COST *new_cost, int cost_offset)
{
  COST c;
  int cost_val = cost_offset;

  Is_True(xt_mul16 || Enable_HiFi2_Ops, ("Unable to generate 16-bit multiply instructions"));
  
  /* Check for truncation. We can't optimize away the truncation if we
     are doing unsigned 16-bit multiplication on HiFi2. */
  if (xt_mul16 || WN_Mpy_16Bit_Signed(result_wn))
  {
    if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
      left = WN_kid0(left);
    
    if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
      right = WN_kid0(right);
  }
  
  if (!ISEL::match(left, ISEL::find_nonterm("areg"), c))
  {
    *new_cost = COST_INFINITY;
    return FALSE;
  }
  cost_val += c.cost;

  if (!ISEL::match(right, ISEL::find_nonterm("areg"), c))
  {
    *new_cost = COST_INFINITY;
    return FALSE;
  }
  cost_val += c.cost;

  new_cost->cost = cost_val;
  return TRUE;
}


static TN *
Generate_MUL16(TYPE_ID rtype, TN *result, WN *result_wn,
               char *instruction_name, WN *left, WN *right, OPS *ops)
{ 
  Is_True(xt_mul16 || Enable_HiFi2_Ops, ("Unable to generate 16-bit multiply instructions"));
  
  TN *left_tn, *right_tn;
  
  /* Optimize away truncation. We can't optimize away the truncation
     if we are doing unsigned 16-bit multiplication on HiFi2. */
  if (xt_mul16 || WN_Mpy_16Bit_Signed(result_wn))
  {
    if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
      left = WN_kid0(left);
    
    if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
      right = WN_kid0(right);
  }
  
  left_tn = areg_action(ISEL::STATE_LABEL(left), 0, ops);
  right_tn = areg_action(ISEL::STATE_LABEL(right), 0, ops);
  
  return Generate_Mul(rtype, result, result_wn,
                      instruction_name, left_tn, right_tn, ops);
}


static BOOL MAC16_arg_cost(WN *left, WN *right, COST *new_cost, 
			   int cost_offset)
{
  COST c;
  int cost_val = cost_offset;

  /* Check for multiplication with the upper half of the register */
  if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
    left = WN_kid0(left);
  if (((WN_operator(left) == OPR_ASHR) || (WN_operator(left) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(left)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(left)) == 16) &&
      ISEL::match(WN_kid0(left), ISEL::find_nonterm("areg"), c)) {
    cost_val += c.cost;
  } else {
    if (!ISEL::match(left, ISEL::find_nonterm("areg"), c))
    {
      *new_cost = COST_INFINITY;
      return FALSE;
    }
    cost_val += c.cost;
  }

  /* Check for multiplication with the upper half of the register */
  if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
    right = WN_kid0(right);
  if (((WN_operator(right) == OPR_ASHR) || (WN_operator(right) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(right)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(right)) == 16) &&
      ISEL::match(WN_kid0(right), ISEL::find_nonterm("areg"), c)) {
    cost_val += c.cost;
  } else {
    if (!ISEL::match(right, ISEL::find_nonterm("areg"), c))
    {
      *new_cost = COST_INFINITY;
      return FALSE;
    }
    cost_val += c.cost;
  }

  new_cost->cost = cost_val;
  return TRUE;
}

static void Generate_MAC16(const char *opcode, WN *left, WN *right, OPS *ops)
{ 
  Is_True(xt_mac16, ("Cannot generate multiply-add instructions"));

  TN *left_tn, *right_tn;
  int code = 0;

  if (!strcmp(opcode, "umul.aa.ll"))
    code += 0;
  if (!strcmp(opcode, "mul.aa.ll"))
    code += 4;
  if (!strcmp(opcode, "mula.aa.ll"))
    code += 8;
  if (!strcmp(opcode, "muls.aa.ll"))
    code += 12;

  if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
    left = WN_kid0(left);
  if (((WN_operator(left) == OPR_ASHR) || (WN_operator(left) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(left)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(left)) == 16)) {
    left = WN_kid0(left);
    code += 2;
  }
  left_tn = areg_action(ISEL::STATE_LABEL(left), 0, ops);

  if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
    right = WN_kid0(right);
  if (((WN_operator(right) == OPR_ASHR) || (WN_operator(right) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(right)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(right)) == 16)) {
    right = WN_kid0(right);
    code += 1;
  }
  right_tn = areg_action(ISEL::STATE_LABEL(right), 0, ops);

  const char* new_tops[] = {
    "umul.aa.ll", "umul.aa.lh", "umul.aa.hl", "umul.aa.hh",
    "mul.aa.ll", "mul.aa.lh", "mul.aa.hl", "mul.aa.hh",
    "mula.aa.ll", "mula.aa.lh", "mula.aa.hl", "mula.aa.hh",
    "muls.aa.ll", "muls.aa.lh", "muls.aa.hl", "muls.aa.hh",
  };

  if (code < 8) {
    Build_OP(TI_TOP_Topcode(new_tops[code]), accum_tn(), left_tn, right_tn, 
	     ops);
  } else {
    Build_OP(TI_TOP_Topcode(new_tops[code]), accum_tn(), left_tn, right_tn, 
	     accum_tn(), ops);
  }
}

static BOOL Label_Asm ( WN *n, COST *cost)
{
  cost->cost = 1;
  
  /* Label all the input parameters... */
  
  for (INT kid = 2; kid < WN_kid_count(n); ++kid)
  {
    COST c;

    WN* load = WN_kid0(WN_kid(n, kid));
    if (!ISEL::match(load, ISEL::find_nonterm(find_nonterm_name(WN_rtype(load))), c))
    {
      *cost = COST_INFINITY;
      return FALSE;
    }
  
    cost->cost += c.cost;
  }
  
  return TRUE;
}

static const char* find_nonterm_name(TYPE_ID mtype)
{
  FmtAssert(mtype!=MTYPE_UNKNOWN, ("Unknown TIE type"));

  if (MTYPE_is_tie(mtype))
    return "tie_reg";
  else if (mtype==MTYPE_XTBOOL)
    return "b1reg";
  else if (MTYPE_is_xtbool(mtype))
    return "breg";
  else if (mtype==MTYPE_F4 && xt_hard_float)
    return "freg";

  return "areg";
}

static const char* find_nonterm_name(const char* tie_proto_type) {

  if (!strcmp("immediate", tie_proto_type))
    return "tie_imm";

  TYPE_ID mtype = tie_info->mtype_id(tie_proto_type);
  return find_nonterm_name(mtype);
}

static TN* action_by_type(WN* n, TYPE_ID mtype, TN *result, OPS* ops) {

  FmtAssert(mtype!=MTYPE_UNKNOWN, ("Unknown TIE type"));
  if (MTYPE_is_tie(mtype))
    return tie_reg_action(ISEL::STATE_LABEL(n), result, ops);
  else if (mtype==MTYPE_XTBOOL)
    return b1reg_action(ISEL::STATE_LABEL(n), result, ops);
  else if (MTYPE_is_xtbool(mtype))
    return breg_action(ISEL::STATE_LABEL(n), result, ops);
  else if (mtype==MTYPE_F4 && xt_hard_float)
    return freg_action(ISEL::STATE_LABEL(n), result, ops);
  else
    return areg_action(ISEL::STATE_LABEL(n), result, ops);

  FmtAssert(FALSE, ("Unreachable code reached"));
}

static TN* action_by_type(WN* n, const char* tie_proto_type, TN *result, OPS* ops) {

  if (!strcmp("immediate", tie_proto_type))
    return tie_imm_action(ISEL::STATE_LABEL(n));

  TYPE_ID mtype = tie_info->mtype_id(tie_proto_type);
  return action_by_type(n, mtype, result, ops);
}

static bool
tie_select_rule_label(WN* n, COST &c) 
{

  COST c1;
  WN* kid0=WN_kid0(n);
  WN* kid1=WN_kid1(n);
  WN* kid2=WN_kid(n,2);

  if (WN_rtype(kid1) != WN_rtype(n) || WN_rtype(kid2) != WN_rtype(n)) {
      c = COST_INFINITY;
      return FALSE;
  }

  if (!ISEL::match(kid0, ISEL::find_nonterm("areg"), c1)) {
      c = COST_INFINITY;
      return FALSE;
  }
  c.cost += c1.cost;
  if (!ISEL::match(kid1, ISEL::find_nonterm("tie_reg"), c1)) {
      c = COST_INFINITY;
      return FALSE;
  }
  c.cost += c1.cost;
  if (!ISEL::match(kid2, ISEL::find_nonterm("tie_reg"), c1)) {
      c = COST_INFINITY;
      return FALSE;
  }
  c.cost += c1.cost;
  c.cost += 3;

  return true;
}

static TN*
tie_select_rule_action(ISEL::State* _s, TN* result, OPS* ops)
{
  WN* n = _s->node;
  WN* kid0=WN_kid0(n);
  WN* kid1=WN_kid1(n);
  WN* kid2=WN_kid(n,2);
  TYPE_ID rtype = WN_rtype(n);
  TYPE_ID desc = WN_desc(kid0);
  FmtAssert(WN_rtype(kid1)==rtype, ("Expecting tie type"));
  FmtAssert(WN_rtype(kid2)==rtype, ("Expecting tie type"));

  TN * l = areg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  TN * tn_true = tie_reg_action(ISEL::STATE_LABEL(kid1), 0, ops);
  TN * tn_false = tie_reg_action(ISEL::STATE_LABEL(kid2), 0, ops);

  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};

static bool tie_intr_op_rule_label(WN* n, COST &c) {

  if (!is_tie_intrinsic_call(n)) {
    c = COST_INFINITY;
    return false;
  }

  COST intr_cost;
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(n));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count(n);
  intr_cost.cost=tie_macro->num_instructions();
  FmtAssert(tie_macro->is_whirl_intrinsic_op(),
	    ("Non-function TIE intrinsic %s used as operation",
	     tie_macro->name()));
  if (tie_macro->is_c_function())
    FmtAssert(kid_count+1==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));
  else if (MTYPE_is_tie_packed(WN_rtype(n)))
    FmtAssert(kid_count+tie_macro->num_output_protos()==
	      tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));
  else
    FmtAssert(kid_count==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));

#if 0
printf("isel tie intr op label: %s\n", tie_macro->name());
#endif
  for (int i=0,opnd_index=0; i<kid_count; i++,opnd_index++) {
    WN* kid = WN_kid0(WN_kid(n,i));

    while (tie_macro->proto_is_out(opnd_index))
      opnd_index++;
    if (tie_macro->proto_is_immed(opnd_index) &&
	ISEL::match(kid, ISEL::find_nonterm("tie_imm"), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else if (ISEL::match(kid, ISEL::find_nonterm(
		find_nonterm_name(tie_macro->proto_mtype_id(tie_info,opnd_index))), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else {
      c = COST_INFINITY;
      return false;
    }
  }

  c = intr_cost;
  return true;
}

static TN* tie_intr_op_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  OPS* copy_ops = NULL;
  WN* n = _s->node;
  TN* in_operands[128];
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(n));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  bool packed_output = false;

  TYPE_ID rtype = WN_rtype(n);
  if (MTYPE_is_tie_packed(rtype)) {
    packed_output = true;
    if (result==NULL) {
      TYPE_ID ret_mtype = tie_macro->output_mtype(tie_info);
      ST* packed_st = MTYPE_To_PREG(ret_mtype);
      TY_IDX packed_ty = MTYPE_To_TY(ret_mtype);
      PREG_NUM packed_preg = Create_Preg(ret_mtype, "tie_intr_struct_out");
      result = PREG_To_TN(packed_st, packed_preg);
    }
  }
#if 0
printf("isel tie intr op action: %s\n", tie_macro->name());
#endif

  int num_outputs=0;
  for (int i=0,opnd_index=0; opnd_index<tie_macro->num_protos(); opnd_index++) {
      WN* kid = NULL;
      TYPE_ID mtype = tie_macro->proto_mtype_id(tie_info,opnd_index);
      if (tie_macro->proto_is_out(opnd_index)) {
	if (packed_output) {
	  PREG_NUM preg_num = TN_To_PREG(result);
          in_operands[opnd_index]=
		PREG_To_TN(MTYPE_To_PREG(mtype),preg_num+num_outputs);
	} else if (result)
          in_operands[opnd_index]=result;
	else {
          result=Build_TN_Of_Mtype(mtype);
          in_operands[opnd_index]=result;
	}
	num_outputs++;
      } else if (tie_macro->proto_is_inout(opnd_index)) {
	/* for inout parameter, we need to make sure a different TN
	   is used and a copy-in is made or we might use a int const
	   TN (from copy-prop optimization) and later cg may think it is
	   rematerializable
	*/
	TN* in_tn;
        kid = WN_kid0(WN_kid(n,i));
        in_tn=action_by_type(kid, mtype, 0, ops);

	if (copy_ops==NULL)
	  copy_ops = OPS_Create();

	if (packed_output) {
	  PREG_NUM preg_num = TN_To_PREG(result);
	  TN* dst = PREG_To_TN(MTYPE_To_PREG(mtype),preg_num+num_outputs);
	  Move_To_Register(mtype, dst, in_tn, copy_ops);
          in_operands[opnd_index]=dst;
	} else {
	  if (result==NULL) {
            result=Build_TN_Of_Mtype(mtype);
	  }
	  Move_To_Register(mtype,result, in_tn, copy_ops);
          in_operands[opnd_index]=result;
	}
        i++;
	num_outputs++;
      } else {
        kid = WN_kid0(WN_kid(n,i));
	if (tie_macro->proto_is_immed(opnd_index))
          in_operands[opnd_index]=action_by_type(kid, "immediate", 0, ops);
	else
          in_operands[opnd_index]=action_by_type(kid, mtype, 0, ops);
        i++;
      }
  }

  if (copy_ops)
    OPS_Append_Ops(ops, copy_ops);

  expand_tie_macro_to_ops(
	ops, Intrinsic_To_Tie_Macro_Id(WN_intrinsic(n)), in_operands);
  return result;
};

static bool tie_call_rule_label(WN* n, COST &c) { 
  c.cost = 1;
  return TRUE;
}

static TN* tie_call_rule_action(ISEL::State* _s, TN* result, OPS* ops) {
  WN* n = _s->node;
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( n, ABI_CALL, ops);
  return 0;
}

static bool
tie_ldid_rule_label(WN* n, COST &c) {

  c.cost = 1;
  return TRUE;

}

static TN*
tie_ldid_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID mtype_id = WN_rtype(n);

  if (MTYPE_is_tie_packed(mtype_id)) {

    FmtAssert(is_preg(n),("Expecting PREG of type '%s'", MTYPE_name(mtype_id)));
    ST *s = WN_st(n);
    INT64 preg_num = WN_load_offset(n);

    if (result==NULL)
      return PREG_To_TN(s,preg_num);

    FmtAssert(TN_register(result) &&
	      !TN_is_dedicated(result) && TN_To_PREG(result),
		("Missing result for LDID of type '%s'", MTYPE_name(mtype_id)));
    INT64 dst_preg_num = TN_To_PREG(result);
    for (int i=0; i<tie_info->num_scalar_mtypes(mtype_id); i++) {
      TYPE_ID mtype = tie_info->get_scalar_mtype(mtype_id, i);
      TN* src=PREG_To_TN(s,preg_num+i);
      TN* dst=PREG_To_TN(s,dst_preg_num+i);
      FmtAssert(TN_mtype(src)==TN_mtype(dst),("Mtypes mismatch"));
      Move_To_Register(mtype,dst,src,ops);
    }
    return PREG_To_TN(s,dst_preg_num);
  } else if (is_preg(n)) {
    Check_For_Dedicated_Preg(n);
    ST *s = WN_st(n);
    INT64 o = WN_load_offset(n);
    return Move_To_Register(mtype_id,result,PREG_To_TN(s,o),ops);
  } else {
    Check_For_Dedicated_Preg(n);
    return Generate_Load_Memory(n, mtype_id, mtype_id, result,
			      WN_st(n), WN_load_offset(n), Variant_LDID(n), ops);
  }
}

static bool
tie_iload_rule_label(WN* n, COST &c) {

  ISEL::Nonterm areg_nt = ISEL::find_nonterm("areg");
  COST c1;
  WN* value = WN_kid0(n);
  if (ISEL::match(value, areg_nt, c1)) {
    c.cost = c1.cost + 1;
    return TRUE;
  } else {
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_iload_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID mtype_id = WN_desc(n);
  TN *addr = expr_action(ISEL::STATE_LABEL(WN_kid0(n)), 0, ops);
  return Generate_Load_Memory(n, mtype_id, mtype_id, result,
			      addr, WN_offset(n), Variant_ILOAD(n), ops);
}

static bool
tie_istore_rule_label(WN* n, COST &c) {

  ISEL::Nonterm areg_nt = ISEL::find_nonterm("areg");
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  COST c1, c2;
  WN* value = WN_kid0(n);
  WN* addr = WN_kid1(n);
  if (ISEL::match(addr, areg_nt, c1)==false) {
    c = COST_INFINITY;
    return FALSE;
  }

  TYPE_ID value_mtype = WN_desc(n);
  ISEL::Nonterm reg_nt = MTYPE_is_tie(value_mtype)?
			ISEL::find_nonterm("tie_reg"):
			ISEL::find_nonterm("areg");
  if (ISEL::match(value, tie_cvt_reg_nt, c2)) {
    c.cost = c1.cost + c2.cost + 1;
    return TRUE;
  } else {
    /* only try to match for the TIE register file case here
       because tie_istore rules may be created for built-in mtypes which
       takes a TIE type conversion result and we want to add the
       tie_cvt_reg_nt rule for value but do not want to conflict with the
       static istore rules
    */
    if (MTYPE_is_tie(value_mtype)) {
      if (ISEL::match(value, reg_nt, c2)) {
        c.cost = c1.cost + c2.cost;
        return TRUE;
      }
    }
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_istore_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID value_mtype = WN_desc(n);

  Is_True( result==0, ("Requesting result from store"));
  WN* kid0 = WN_kid0(n);
  TN *val;
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  TN *addr = areg_action(ISEL::STATE_LABEL(WN_kid1(n)), 0, ops);

  if (ISEL::STATE_LABEL(kid0)->has_match_for(tie_cvt_reg_nt)) {
    val = tie_cvt_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  } else {
    FmtAssert(MTYPE_is_tie(value_mtype),
		 ("Dynamic istore rules without conversion used for non-TIE"));
    val = tie_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  }
  Generate_Store_Memory(n, value_mtype, val, addr, WN_offset(n), Variant_ISTORE(n), ops );
  return val;
};

static bool
mtype_need_paired_tn(TYPE_ID mtype) {
  switch (mtype) {
    case MTYPE_I8:
    case MTYPE_U8:
	return TRUE;
  }
  return FALSE;
}

static bool
tie_rtor_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  if (mtype_need_paired_tn(src_mtype) ||
      mtype_need_paired_tn(dst_mtype))
    return FALSE;

  TIE_MACRO_p rtor_macro = tie_info->mtype_rtor_macro(src_mtype,dst_mtype);
  if (rtor_macro==NULL)
    return FALSE;

  ISEL::Nonterm reg_nt = ISEL::find_nonterm(find_nonterm_name(src_mtype));

  WN* value = WN_kid0(n);
  if (ISEL::match(value, reg_nt, c1)) {
    c = c1;
    c.cost+= rtor_macro->num_instructions();
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_rtor_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);
  TIE_MACRO_p rtor_macro = tie_info->mtype_rtor_macro(src_mtype,dst_mtype);

  FmtAssert(rtor_macro,("Missing rtor macro"));

  TN* in_operands[128];
  if (result==NULL)
    result=Build_TN_Of_Mtype(dst_mtype);

  TN* src_tn = action_by_type(WN_kid0(n), src_mtype, 0, ops);

  in_operands[0] = result;
  in_operands[1] = src_tn;

  expand_tie_macro_to_ops(ops, rtor_macro->id(), in_operands);

  return result;
}

static bool
tie_rtom_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  if (mtype_need_paired_tn(src_mtype) ||
      mtype_need_paired_tn(dst_mtype))
    return FALSE;

  TIE_MACRO_p rtom_macro = tie_info->mtype_rtom_macro(src_mtype,dst_mtype);
  if (rtom_macro==NULL)
    return FALSE;

  ISEL::Nonterm reg_nt = MTYPE_is_tie(src_mtype)?
			ISEL::find_nonterm("tie_reg") :
			ISEL::find_nonterm("areg");
  WN* value = WN_kid0(n);
  if (ISEL::match(value, reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_rtom_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID src_mtype = WN_desc(n);

  result = MTYPE_is_tie(src_mtype)?
		tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), result, ops):
		areg_action(ISEL::STATE_LABEL(WN_kid0(n)), result, ops);

  return result;
}

static bool
tie_mtor_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  if (mtype_need_paired_tn(src_mtype) ||
      mtype_need_paired_tn(dst_mtype))
    return FALSE;

  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
  if (mtor_macro==NULL)
    return FALSE;

  ISEL::Nonterm simm32_nt = ISEL::find_nonterm("simm32");
  WN* load = WN_kid0(n);
  if (WN_operator(load)==OPR_ILOAD &&
      WN_desc(load)==src_mtype &&
      tie_iload_rule_label(load, c1)) {
    c = c1;
    /* c.cost++; */
    /* cost is free here as it is included in the iload labelling */
    return TRUE;
  } else if (WN_operator(load)==OPR_LDID &&
	     WN_desc(load)==src_mtype && !is_preg(load) &&
	     tie_ldid_rule_label(load, c1)) {
    c = c1;
    /* c.cost++; */
    /* cost is free here as it is included in the ldid labelling */
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_mtor_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* cvt = _s->node;
  FmtAssert(WN_operator(cvt)==OPR_CVT,("Bad operator"));

  TYPE_ID src_mtype = WN_desc(cvt);
  TYPE_ID dst_mtype = WN_rtype(cvt);
  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);

  FmtAssert(mtor_macro,("Missing mtor macro"));

  WN* load = WN_kid0(cvt);
  FmtAssert(WN_operator(load)==OPR_ILOAD ||
	    WN_operator(load)==OPR_LDID,
	    ("Bad operator"));

  if (result==NULL)
    result=Build_TN_Of_Mtype(dst_mtype);
  FmtAssert((dst_mtype==TN_mtype(result)) ||
	    (TN_is_dedicated(result) &&
	     (TN_register_class(result) == TI_ISA_Regclass_For_Mtype(dst_mtype))),
	    ("Mtype mis-match, result = %s, dst_mtype = %s\n",
	     MTYPE_name(TN_mtype(result)), MTYPE_name(dst_mtype)));

  if (WN_operator(load)==OPR_ILOAD) {
    TN *addr;
    addr = areg_action(ISEL::STATE_LABEL(WN_kid0(load)), 0, ops);
    return Generate_Load_Memory(load, dst_mtype, src_mtype, result,
			      addr, WN_offset(load), Variant_ILOAD(load), ops);
  } else {
    return Generate_Load_Memory(load, dst_mtype, src_mtype, result,
			      WN_st(load), WN_load_offset(load), Variant_LDID(load), ops);
  }
}

static bool
tie_rtor_spill_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
  TIE_MACRO_p rtom_macro = tie_info->mtype_rtom_macro(src_mtype,dst_mtype);
  if (mtor_macro==NULL && rtom_macro==NULL)
    return FALSE;

  ISEL::Nonterm reg_nt = MTYPE_is_tie(src_mtype)?
			ISEL::find_nonterm("tie_reg"):
			  (mtype_need_paired_tn(src_mtype)?
				ISEL::find_nonterm("ll_cvt_areg"):
				ISEL::find_nonterm("areg"));
  ISEL::Nonterm simm32_nt = ISEL::find_nonterm("simm32");
  WN* kid0 = WN_kid0(n);
  if (mtor_macro && ISEL::match(kid0, simm32_nt, c1)) {
    /* if the value can be put in literal pool to save a store */
    c = c1;
    c.cost+=100;
    return TRUE;
  } else if (ISEL::match(kid0, reg_nt, c1)) {
    c = c1;
    c.cost+=100;
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_rtor_spill_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);
  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
  TIE_MACRO_p rtom_macro = tie_info->mtype_rtom_macro(src_mtype,dst_mtype);

  FmtAssert(mtor_macro || rtom_macro, ("Missing rtor with spill macro"));

  TN* in_operands[128];

  ISEL::Nonterm simm32_nt = ISEL::find_nonterm("simm32");
  ISEL::Nonterm ll_cvt_areg_nt = ISEL::find_nonterm("ll_cvt_areg");
  WN* kid0 = WN_kid0(n);
  TN* dst;
  TN* src;
  TN* src_1 = NULL; /* for paired tn if needed */
  TN* dst_1 = NULL; /* for paired tn if needed */
  char buffer[256];

  if (mtype_need_paired_tn(dst_mtype)) {
    FmtAssert(dst_mtype==MTYPE_I8 || dst_mtype==MTYPE_U8, ("Unknown type"));
    TYPE_ID new_dst_mtype=(dst_mtype==MTYPE_I8)?MTYPE_I4:MTYPE_U4;
    if (result==NULL)
      result=Build_TN_Of_Mtype(new_dst_mtype);
    dst=result;
    dst_1=Build_TN_Of_Mtype(new_dst_mtype);
  } else {
    if (result==NULL)
      result=Build_TN_Of_Mtype(dst_mtype);
    dst=result;
  }

  if (MTYPE_is_tie(src_mtype)) {
    src = tie_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  } else if (src_mtype == MTYPE_F4 && xt_hard_float) {
    src = freg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  } else {
    if (mtor_macro && ISEL::STATE_LABEL(kid0)->has_match_for(simm32_nt)) {
      ST* lc;
      src = simm32_action(ISEL::STATE_LABEL(kid0));
      lc = Generate_Literal_Tie(src_mtype, TN_value(src));
      if (MTYPE_is_tie(dst_mtype)) {
	Generate_Load_Memory(0, dst_mtype, src_mtype, dst, lc, 0, 0, ops );
      } else {
	/* cannot use dst_mtype as result type as it can be I1/U1/I2/U2 */
        TYPE_ID int_rtype = Mtype_TransferSize(MTYPE_U4, dst_mtype);
        Generate_Load_Memory(0, int_rtype, src_mtype, dst, lc, 0, 0, ops );
      }
      return result;
    } else if (ISEL::STATE_LABEL(kid0)->has_match_for(ll_cvt_areg_nt)) {
      src = ll_cvt_areg_action(ISEL::STATE_LABEL(kid0), 0, ops);
    } else {
      src = areg_action(ISEL::STATE_LABEL(kid0), 0, ops);
    }
  }

  if (mtor_macro) {
    sprintf(buffer, "mtor_spill_%s", MTYPE_name(src_mtype));
    ST* temp_st = Gen_Temp_Symbol(MTYPE_To_TY(src_mtype), buffer);
    Allocate_Temp_To_Memory(temp_st);
    if (mtype_need_paired_tn(src_mtype)) {
      FmtAssert(src_mtype==MTYPE_I8 || src_mtype==MTYPE_U8, ("Unknown type"));
      TYPE_ID new_src_mtype=(src_mtype==MTYPE_I8)?MTYPE_I4:MTYPE_U4;
      src_1=get_reg_tn_pair(src);
      FmtAssert(src_1,("Missing register pair"));
      if (Target_Byte_Sex == BIG_ENDIAN) {
	Generate_Store_Memory (0, new_src_mtype, src, temp_st, 4, 0, ops);
	Generate_Store_Memory (0, new_src_mtype, src_1, temp_st, 0, 0, ops);
      } else {
	Generate_Store_Memory (0, new_src_mtype, src, temp_st, 0, 0, ops);
	Generate_Store_Memory (0, new_src_mtype, src_1, temp_st, 4, 0, ops);
      }
    } else {
      Generate_Store_Memory (0, src_mtype, src, temp_st, 0, 0, ops);
    }
    Generate_Load_Memory  (0, dst_mtype, src_mtype, dst, temp_st, 0, 0, ops );
  } else {
    sprintf(buffer, "rtom_spill_%s", MTYPE_name(dst_mtype));
    ST* temp_st = Gen_Temp_Symbol(MTYPE_To_TY(dst_mtype), buffer);
    Allocate_Temp_To_Memory(temp_st);
    Generate_Store_Memory (0, dst_mtype, src, temp_st, 0, 0, ops);
    if (mtype_need_paired_tn(dst_mtype)) {
      FmtAssert(dst_mtype==MTYPE_I8 || dst_mtype==MTYPE_U8, ("Unknown type"));
      TYPE_ID new_dst_mtype=(dst_mtype==MTYPE_I8)?MTYPE_I4:MTYPE_U4;
      FmtAssert(dst_1,("Missing register pair"));
      if (Target_Byte_Sex == BIG_ENDIAN) {
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst,temp_st,4,0,ops );
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst_1,temp_st,0,0,ops );
      } else {
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst,temp_st,0,0,ops );
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst_1,temp_st,4,0,ops );
      }
      set_reg_tn_pair(dst,dst_1);
    } else {
      if (MTYPE_is_tie(dst_mtype)) {
	Generate_Load_Memory(0, dst_mtype, dst_mtype, dst, temp_st, 0, 0, ops );
      } else {
	/* cannot use dst_mtype as result type as it can be I1/U1/I2/U2 */
        TYPE_ID int_rtype = Mtype_TransferSize(MTYPE_U4, dst_mtype);
	Generate_Load_Memory(0, int_rtype, dst_mtype, dst, temp_st, 0, 0, ops );
      }
    }
  }

  return result;
}

static bool
tie_outpart_rule_label(WN* n, COST &c) {

  COST c1;
  WN* kid = WN_kid0(n);
  TYPE_ID kid_mtype = WN_rtype(kid);
  ISEL::Nonterm reg_nt = ISEL::find_nonterm("tie_reg");

  /* we allow OUTPART(LDID) or OUTPART(INTRINISIC_OP)
     the second kind is normally a result of copy propagation from WOPT
  */
  if (!MTYPE_is_tie_packed(kid_mtype) ||
      (!(WN_operator(kid)==OPR_LDID && is_preg(kid)) &&
       !(WN_operator(kid)==OPR_INTRINSIC_OP))) {
    c = COST_INFINITY;
    return FALSE;
  } else if (ISEL::match(kid, reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else {
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_outpart_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  WN* kid = WN_kid0(n);
  int outpart = WN_outpart(n);
  TYPE_ID kid_rtype = WN_rtype(kid);
  TYPE_ID value_mtype = tie_info->get_scalar_mtype(kid_rtype, outpart-1);

  TN *src = tie_reg_action(ISEL::STATE_LABEL(kid), 0, ops);
  TN *value = PREG_To_TN(MTYPE_To_PREG(value_mtype),TN_To_PREG(src)+(outpart-1));
  FmtAssert(value_mtype==TN_mtype(value),("Mtypes mismatch"));
  if (result) {
    FmtAssert(((TN_is_dedicated(result) ||
		TN_register_class(result)==TI_ISA_Regclass_Integer()) &&
	       TN_register_class(result)==TN_register_class(value)) ||
	      TN_mtype(result)==TN_mtype(value),("Mtypes mismatch"));
    return Move_To_Register(value_mtype,result,value,ops);
  } else {
    return value;
  }
}

static bool
tie_stid_rule_label(WN* n, COST &c) {

  TYPE_ID value_mtype = WN_desc(n);
  COST c1;
  WN* value = WN_kid0(n);
  ISEL::Nonterm reg_nt = MTYPE_is_tie(value_mtype)?
			ISEL::find_nonterm("tie_reg"):
			ISEL::find_nonterm("areg");
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");

  if (!is_preg(n) && ISEL::match(value, tie_cvt_reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else if (ISEL::match(value, reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else {
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_stid_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID value_mtype = WN_desc(n);
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  WN* kid0 = WN_kid0(n);

  Is_True( result==0, ("Requesting result from store"));

  if (MTYPE_is_tie_packed(value_mtype)) {
    FmtAssert(is_preg(n),
	("Expecting PREG of type '%s'", MTYPE_name(value_mtype)));
    ST *s = WN_st(n);
    INT64 o = WN_store_offset(n);
    TN *dst = PREG_To_TN(s,o);
    dst = tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), dst, ops);
    return dst;
  } else if (is_preg(n)) {
    Check_For_Dedicated_Preg(n);
    ST *s = WN_st(n);
    INT64 o = WN_store_offset(n);
    TN *dst = PREG_To_TN(s,o);
    dst = MTYPE_is_tie(value_mtype)?
    		tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), dst, ops):
    		areg_action(ISEL::STATE_LABEL(WN_kid0(n)), dst, ops);
    return dst;
  } else {
    Check_For_Dedicated_Preg(n);
    TN *val;
    if (ISEL::STATE_LABEL(kid0)->has_match_for(tie_cvt_reg_nt)) {
      val = tie_cvt_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
    } else {
      val = MTYPE_is_tie(value_mtype)?
    		tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), 0, ops):
    		areg_action(ISEL::STATE_LABEL(WN_kid0(n)), 0, ops);
    }
    Generate_Store_Memory( n, value_mtype, val, WN_st(n), WN_store_offset(n), Variant_STID(n), ops);
    return val;
  }

}

static void
add_isel_rule_for_tie_type(TYPE_ID mtype_id) {

  if (MTYPE_is_tie(mtype_id)==FALSE)
    return;

  ISEL::Nonterm stmt_nt = ISEL::find_nonterm("stmt");
  ISEL::Nonterm tie_reg_nt = ISEL::find_nonterm("tie_reg");

  OPCODE tie_ldid_opc = OPCODE_make_op(OPR_LDID, mtype_id, mtype_id);
  OPCODE tie_stid_opc = OPCODE_make_op(OPR_STID, MTYPE_V, mtype_id);
  OPCODE tie_iload_opc = OPCODE_make_op(OPR_ILOAD, mtype_id, mtype_id);
  OPCODE tie_istore_opc = OPCODE_make_op(OPR_ISTORE, MTYPE_V, mtype_id);
  OPCODE tie_select_opc = OPCODE_make_op(OPR_SELECT, mtype_id, MTYPE_V);
  OPCODE tie_call_opc = OPCODE_make_op(OPR_CALL, mtype_id, MTYPE_V);

  ISEL::Rule tie_ldid_rule =
	ISEL::add_rule((int)tie_ldid_opc, tie_reg_nt, 0, tie_ldid_rule_label);
  ISEL::add_tie_reg_action(tie_ldid_rule, tie_ldid_rule_action);

  ISEL::Rule tie_stid_rule =
	ISEL::add_rule((int)tie_stid_opc, stmt_nt, 1, tie_stid_rule_label);
  ISEL::add_stmt_action(tie_stid_rule, tie_stid_rule_action);

  /* packed mtype for TIE needs only ldid/stid rules */
  if (MTYPE_is_tie_packed(mtype_id)) {
    return;
  }

  ISEL::Rule tie_iload_rule =
	ISEL::add_rule((int)tie_iload_opc, tie_reg_nt, 1, tie_iload_rule_label);
  ISEL::add_tie_reg_action(tie_iload_rule, tie_iload_rule_action);

  ISEL::Rule tie_istore_rule =
	ISEL::add_rule((int)tie_istore_opc, stmt_nt, 2, tie_istore_rule_label);
  ISEL::add_stmt_action(tie_istore_rule, tie_istore_rule_action);

  ISEL::Rule tie_select_rule =
	ISEL::add_rule((int)tie_select_opc, tie_reg_nt, 3, tie_select_rule_label);
  ISEL::add_tie_reg_action(tie_select_rule, tie_select_rule_action);

  ISEL::Rule tie_call_rule =
	ISEL::add_rule((int)tie_call_opc, stmt_nt, 0, tie_call_rule_label);
  ISEL::add_stmt_action(tie_call_rule, tie_call_rule_action);
}

static void
add_isel_rule_for_tie_macros() {

  ISEL::Nonterm areg_nt = ISEL::find_nonterm("areg");
  ISEL::Nonterm freg_nt = ISEL::find_nonterm("freg");
  ISEL::Nonterm b1reg_nt = ISEL::find_nonterm("b1reg");
  ISEL::Nonterm breg_nt = ISEL::find_nonterm("breg");
  ISEL::Nonterm stmt_nt = ISEL::find_nonterm("stmt");
  ISEL::Nonterm tie_reg_nt = ISEL::find_nonterm("tie_reg");
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  TYPE_ID mtype_id;
  TIE_MACRO_ID tie_macro_id;

  FmtAssert(Mtype_Last<MTYPE_MAX,("Too many (>%d) mtypes\n",MTYPE_MAX));
  bool mtype_has_tie_intrinsic_op[MTYPE_MAX];
  bool mtype_has_tie_outpart[MTYPE_MAX];

  for (mtype_id=1; mtype_id<=Mtype_Last; mtype_id++) {
    mtype_has_tie_intrinsic_op[mtype_id]=false;
    mtype_has_tie_outpart[mtype_id]=false;
  }

  for (tie_macro_id=0; tie_macro_id<tie_info->num_macros(); tie_macro_id++) {

    TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
    if (tie_macro->is_whirl_intrinsic_op()) {
      mtype_id = tie_macro->output_mtype(tie_info);
      if (mtype_id==MTYPE_I1 || mtype_id ==MTYPE_I2)
	mtype_id=MTYPE_I4;
      else if (mtype_id==MTYPE_U1 || mtype_id ==MTYPE_U2)
	mtype_id=MTYPE_U4;
      mtype_has_tie_intrinsic_op[mtype_id]=true;

      if (MTYPE_is_tie_packed(mtype_id)) {
	for (int i=0; i<tie_info->num_scalar_mtypes(mtype_id); i++) {
	  TYPE_ID scalar_mtype = tie_info->get_scalar_mtype(mtype_id,i);

	  if (scalar_mtype==MTYPE_I1 || scalar_mtype==MTYPE_I2)
	    scalar_mtype = MTYPE_I4;
	  else if (scalar_mtype==MTYPE_U1 || scalar_mtype==MTYPE_U2)
	    scalar_mtype = MTYPE_U4;

	  mtype_has_tie_outpart[scalar_mtype]=true;
	}
      }
    }
  }

  for (mtype_id=1; mtype_id<=Mtype_Last; mtype_id++) {
    if (mtype_has_tie_intrinsic_op[mtype_id] && (mtype_id != MTYPE_V)) {
      OPCODE tie_intr_op_opc =
		OPCODE_make_op(OPR_INTRINSIC_OP, mtype_id, MTYPE_V);
      ISEL::Rule tie_intr_op_rule;
      if (MTYPE_is_tie(mtype_id)) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, tie_reg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_tie_reg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else if (mtype_id==MTYPE_XTBOOL) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, b1reg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_areg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else if (MTYPE_is_xtbool(mtype_id)) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, breg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_areg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else if (MTYPE_is_float(mtype_id) && xt_hard_float) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, freg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_tie_reg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, areg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_tie_reg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      }
    }
    if (mtype_has_tie_outpart[mtype_id]) {
      OPCODE tie_outpart_opc = OPCODE_make_op(OPR_OUTPART, mtype_id, MTYPE_V);
      ISEL::Rule tie_outpart_rule;
      if (MTYPE_is_tie(mtype_id)) {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, tie_reg_nt, 0, tie_outpart_rule_label);
        ISEL::add_tie_reg_action(tie_outpart_rule, tie_outpart_rule_action);
      } else if (mtype_id==MTYPE_XTBOOL) {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, b1reg_nt, 0, tie_outpart_rule_label);
        ISEL::add_areg_action(tie_outpart_rule, tie_outpart_rule_action);
      } else if (MTYPE_is_xtbool(mtype_id)) {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, breg_nt, 0, tie_outpart_rule_label);
        ISEL::add_areg_action(tie_outpart_rule, tie_outpart_rule_action);
      } else {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, areg_nt, 0, tie_outpart_rule_label);
        ISEL::add_tie_reg_action(tie_outpart_rule, tie_outpart_rule_action);
      }
    }
  }

  TYPE_ID src_mtype;
  TYPE_ID dst_mtype;
  ISEL::Nonterm reg_nt;
  for (src_mtype=1; src_mtype<=Mtype_Last; src_mtype++)
    for (dst_mtype=1; dst_mtype<=Mtype_Last; dst_mtype++)
      if ((MTYPE_is_tie(src_mtype) || MTYPE_is_tie(dst_mtype)) &&
	  !(MTYPE_is_tie_packed(src_mtype) || MTYPE_is_tie_packed(dst_mtype))) {
	TIE_MACRO_p rtor_macro=tie_info->mtype_rtor_macro(src_mtype,dst_mtype);
	TIE_MACRO_p rtom_macro=tie_info->mtype_rtom_macro(src_mtype,dst_mtype);
	TIE_MACRO_p mtor_macro=tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
	ISEL::Rule tie_cvt_rule;
	if (MTYPE_is_tie(dst_mtype))
	  reg_nt = tie_reg_nt;
	else
	  reg_nt = areg_nt;
	OPCODE tie_cvt_opc =
		OPCODE_make_op(OPR_CVT, dst_mtype, src_mtype);
	if (rtor_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, reg_nt, 1, tie_rtor_rule_label);
          ISEL::add_tie_reg_action(tie_cvt_rule, tie_rtor_rule_action);
	}
	if (rtom_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, tie_cvt_reg_nt, 1, tie_rtom_rule_label);
          ISEL::add_tie_cvt_reg_action(tie_cvt_rule, tie_rtom_rule_action);
	  if (MTYPE_is_tie(dst_mtype)==false) {
	     /* a rtom conversion from TIE to non-TIE */
  	     OPCODE istore_opc =
			OPCODE_make_op(OPR_ISTORE, MTYPE_V, dst_mtype);
	     ISEL::Rule tie_istore_rule =
			ISEL::add_rule((int)istore_opc, stmt_nt, 2,
				       tie_istore_rule_label);
	     ISEL::add_stmt_action(tie_istore_rule, tie_istore_rule_action);
	  }
	}
	if (mtor_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, reg_nt, 1, tie_mtor_rule_label);
          ISEL::add_tie_reg_action(tie_cvt_rule, tie_mtor_rule_action);
	}
	if (mtor_macro!=NULL || rtom_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, reg_nt, 1, tie_rtor_spill_rule_label);
          ISEL::add_tie_reg_action(tie_cvt_rule, tie_rtor_spill_rule_action);
	}
      }
}

static void
asm_action_callback (WN *n, TN *result, OPS *ops)
{
#if 0
  fPrint_TN(stderr, "callback: result %s, tree:\n", result);
  fdump_tree(stderr, n);
#endif
  
  /* whirl2ops.cxx:Handle_ASM will call back here for us to generate
     ops to evaluate 'n' into 'result'. */
  action_by_type(n, WN_rtype(n), result, ops);
}


void ISEL_initialize(void)
{
  static int initialized=0;

  if( !initialized ) {

    MEM_POOL_Initialize(&ISEL_Mem_Pool,"Instruction Selection", TRUE);
    MEM_POOL_Initialize(&ISEL_Map_Pool,"Instruction Selection", TRUE);
    MEM_POOL_Push(&ISEL_Mem_Pool);
    MEM_POOL_Push(&ISEL_Map_Pool);

    ISEL::initialize();
    for (TYPE_ID i=MTYPE_CORE_LAST+1; i<=Mtype_Last; i++)
      if (MTYPE_is_tie(i))
        add_isel_rule_for_tie_type(i);

    add_isel_rule_for_tie_macros();

    initialized=1;
  }
  ISEL_State_Map = WN_MAP_Create(&ISEL_Map_Pool);

}

void ISEL_finalize(void)
{
  WN_MAP_Delete(ISEL_State_Map);

  // should pop and delete in the last finalize but cannot detect that
  // MEM_POOL_Pop(&ISEL_Mem_Pool);
  // MEM_POOL_Pop(&ISEL_Map_Pool);
  // MEM_POOL_Delete(&ISEL_Mem_Pool);
  // MEM_POOL_Delete(&ISEL_Map_Pool);
}

bool
ISEL_gen(WN *stmt, TN *result, OPS *ops)
{
  extern void debug();
  bool res;
  OPCODE opc;

  Is_True( result==0 || TN_is_register(result), ("Result tn not a register"));

  opc = WN_opcode(stmt);
  switch( opc ) {
  case OPC_PRAGMA:
  case OPC_XPRAGMA:
    /* We want the preamble to be in it's own BB initially, to help in
       recognizing FP_TN uses that are referencing the incoming
       argument from FP_TN uses as the frame pointer. */
    if (WN_pragma(stmt) == WN_PRAGMA_PREAMBLE_END)
    {
      BB *cur_bb = Get_Cur_BB();
      BB *new_bb = Start_New_Basic_Block();
      if (cur_bb != new_bb)
        Link_Pred_Succ(cur_bb, new_bb);
      Set_BB_end_preamble(Get_Cur_BB());
    }
    return false;

  case OPC_COMMENT:
  case OPC_RETURN:
  case OPC_LABEL:
    return false;
  }

  ISEL_Initialize_For_Tree();

  //fprintf(stderr, "\n\n *** lowering ***\n\n");
  //fdump_tree(stderr, stmt);

  try {
    res = (ISEL::label(stmt) != 0 );
    if( !res ) {
      if (WN_operator(stmt) == OPR_ASM_STMT) {
        ErrMsgSrcpos(EC_Inv_Asm_Opnd, WN_Get_Linenum(stmt));
      } else {
        fdump_tree(stderr, stmt);
        FmtAssert(FALSE, ("no cover"));
      }
    } else {
      (void) stmt_action(ISEL::STATE_LABEL(stmt),result,ops);
    }
  }
  catch(ISEL::Exception e) {
    if (WN_operator(stmt) == OPR_ASM_STMT) {
      ErrMsgSrcpos(EC_Inv_Asm_Opnd, WN_Get_Linenum(stmt));
    } else { 
      if (e.node) {
        fprintf(stderr, "node =\n");
        fdump_tree(stderr, e.node);
      }
      fprintf(stderr, "tree =\n");
      fdump_tree(stderr, stmt);
      FmtAssert(FALSE, ("ISEL error: %s\n", e.reason));
    }
  }

  ISEL_Finalize_For_Tree();
  return res;
}

// Local Variables:
// mode: c++
// c-style-variables-are-local-p: t
// c-file-style: "mongoose"
// End:
