%{

/*

  Copyright (C) 2003-2007 Tensilica, Inc.  All Rights Reserved.

  This program is free software; you can redistribute it and/or modify it
  under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it would be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

  Further, this software is distributed without any warranty that it is
  free of the rightful claim of any third person regarding infringement 
  or the like.  Any license provided herein, whether implied or 
  otherwise, applies only to this software file.  Patent licenses, if 
  any, provided herein do not apply to combinations of this program with 
  other software, or any other product whatsoever.  

  You should have received a copy of the GNU General Public License along
  with this program; if not, write the Free Software Foundation, Inc., 59
  Temple Place - Suite 330, Boston MA 02111-1307, USA.


  isel.cxx and isel.h were generated by Olive from input files developed
  by Tensilica, Inc. Olive is a code-generator generator copyright 1994 by 
  Synopsys, Inc. All bug reports regarding isel.cxx or isel.h should be
  reported to Tensilica, Inc.

  For more information regarding Olive itself, contact Synopsis, Inc.

*/

#include "defs.h"

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <alloca.h>

#include <elf.h>
#include <vector>
#include "em_elf.h"
#include "erglob.h"
#include "ercg.h"
#include "tracing.h"
#include "config.h"
#include "config_targ_options.h"
#include "config_debug.h"
#include "config_opt.h"
#include "xstats.h"
#include "topcode.h"
#include "tn.h"
#include "cg_flags.h"
#include "targ_isa_lits.h"
#include "op.h"
#include "stblock.h"
#include "data_layout.h"
#include "strtab.h"
#include "stab.h"
#include "cg.h"
#include "cgexp.h"
#include "cgexp_internals.h"
#include "whirl2ops.h"
#include "const.h"
#include "targ_const.h"
#include "targ_const_private.h"
#include "label_util.h"
#include "cxx_hash.h"
#include "cg_tie.h"
#include "intrn_info.h"
#include "util.h"
#include "libti.h"
#include "wn_util.h"
#include "be_util.h"
  
extern WN_MAP ISEL_State_Map;
 
#define ABI_CALL (Target_ABI == ABI_WINDOWED ? TOP_call8 : TOP_call0)
#define ABI_ICALL (Target_ABI == ABI_WINDOWED ? TOP_callx8 : TOP_callx0)

//
// Define two pools.  One ISEL_Mem_Pool is used for memory allocated during
// the matching of one tree.  The other ISEL_Map_Pool is used to hold the map
// that associates state structures with a WN node.
//
extern MEM_POOL ISEL_Mem_Pool, ISEL_Map_Pool;
extern void fdump_tree(FILE *, WN *);

// A structure to represent a pair of preg as TNs.  Note that
// the register pair should differ by one.
struct preg_pair {
  TN *lo;
  TN *hi;
};

typedef WN * NODEPTR;
#define GET_KIDS(p)	(&(WN_kid0(p)))
#define PANIC printf
#define DEFAULT_COST	break
#define NO_MATCH        return(0)
#define NO_ACTION(x)
#define OP_LABEL(p) (WN_opcode(p))

//#define ALLOC(t,n) (TYPE_MEM_POOL_ALLOC_N(t,&ISEL_Mem_Pool,n))
typedef struct COST {
    int cost;
} COST;
#define COST_LESS(a,b) ((a).cost < (b).cost)

static COST COST_INFINITY = { 32767 };
static COST COST_ZERO     = { 0 };

#define IS_POWER_OF_2(val)      ((val != 0) && ((val & (val-1)) == 0))
#define SWAP_TNS(a, b) (_swap_tmp = a, a = b, b = _swap_tmp)
static TN *_swap_tmp;
  
static int _ern = 0;

static void ISEL_trace(NODEPTR, int, int, int);
static void asm_action_callback (WN *n, TN *result, OPS *ops);
static void Generate_ICall( WN *n, TOP top, OPS *ops );
static BOOL Label_ICall ( WN *n, COST *cost);
static BOOL MUL16_arg_cost (WN *result_wn, WN *left, WN *right,
                            COST *new_cost, int cost_offset);
static TN *Generate_MUL16(TYPE_ID rtype, TN *result, WN *result_wn,
                          char *instruction_name, WN *left, WN *right, OPS *ops);
static BOOL MAC16_arg_cost(WN *left, WN *right, COST *new_cost, int cost_offset);
static void Generate_MAC16(const char *opcode, WN *left, WN *right, OPS *ops);
static BOOL Label_Asm ( WN *n, COST *cost);
static BOOL Get_Extui_Shift_Mask (UINT64 val, INT32 *shift =NULL, INT32 *size =NULL);
static BOOL Get_Bbci_Bbsi_Immediate (INT64 val, INT32 *imm =NULL);
static const char* find_nonterm_name(const char* tie_proto_type);
static const char* find_nonterm_name(TYPE_ID mtype);
static TN* action_by_type(WN* n, TYPE_ID mtype, TN *result, OPS* ops);
static TN* action_by_type(WN* n, const char* tie_proto_type, TN *result, OPS* ops);
static WN *preg_home (WN *ldid);
static WN *preg_equivalent_literal (WN *ldid);


static void print_sym( ST *sym, INT64 ofst )
  {
    ST *base_sym;
    INT64 base_ofst;

    putc('<',stderr);
    fprintf(stderr,"%s+%ld", &Str_Table[sym->u1.name_idx], ofst );
    Base_Symbol_And_Offset_For_Addressing (sym, ofst, &base_sym, &base_ofst);
    if( base_sym != sym )
      fprintf(stderr,"=%s+%ld", &Str_Table[base_sym->u1.name_idx], base_ofst );
    putc('>',stderr);
  }

/* Predicates */

static bool is_tie_intrinsic_call(WN *n)
  {
    return INTRN_is_tie_intrinsic(WN_intrinsic(n));
  }

static bool is_tie_tn(WN *n)
  {
    if( WN_operator(n)==OPR_TN &&
	MTYPE_is_tie(TN_mtype(WN_tn(n))))
      return true;
    return false;
  }

static bool is_xtbool_tn(WN *n)
  {
    if( WN_operator(n)==OPR_TN &&
	MTYPE_is_xtbool(TN_mtype(WN_tn(n))))
      return true;
    return false;
  }

static bool is_preg(WN *n)
  {
    if (WN_operator(n) == OPR_TN )
      return TN_is_register(WN_tn(n));
    else if (WN_class(n) == CLASS_PREG)
      return true;
    else if ((WN_operator(n) == OPR_LDID) || (WN_operator(n) == OPR_STID))
      return ST_assigned_to_dedicated_preg(WN_st(n));
    return false;
  }

static bool is_float_tn(WN *n)
  {
    Is_True(is_preg(n), ("is_float_tn requires is_preg"));
    if (!xt_hard_float)
      return false;
    if (WN_operator(n) == OPR_TN) 
      return MTYPE_is_float(TN_mtype(WN_tn(n)));
    if (WN_class(n) == CLASS_PREG)
      return !Preg_Is_Dedicated(WN_offset(n)) || 
              Preg_Is_Dedicated_Float(WN_offset(n));
    return !ST_assigned_to_dedicated_preg(WN_st(n)) ||
            Preg_Is_Dedicated_Float(Find_PREG_For_Symbol(WN_st(n)));
  }

static bool hw_fp(WN *n)
  {
    return xt_hard_float;
  }

static bool hw_fp_recip(WN *n)
  {
    return xt_hard_float_recip;
  }

static bool hw_fp_rsqrt(WN *n)
  {
    return xt_hard_float_rsqrt;
  }

static bool is_const(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_class(s)==CLASS_CONST;
  }

static bool is_var(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_class(s)==CLASS_VAR;
  }

static bool is_auto(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_storage_class(*s)==SCLASS_AUTO;
  }

static bool is_formal(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_storage_class(*s)==SCLASS_FORMAL;
  }

static bool is_formal_ref(WN *n)
  {
    ST *s = WN_st(n);
    return s && ST_storage_class(*s)==SCLASS_FORMAL_REF;
  }

static bool is_auto_or_formal(WN *n)
  {
    return is_auto(n) || is_formal(n) || is_formal_ref(n);
  }

static bool use_conservative_addressing (ST *st)
  {
    return(st &&
	   ((ST_sclass(st) == SCLASS_FORMAL) ||
	    (ST_sclass(st) == SCLASS_FORMAL_REF)));
  }

static bool allowed_shiftadd_immed (WN *n)
  {
    if (!xt_addx)
      return FALSE;
    return((WN_operator(n) == OPR_INTCONST) &&
	   (WN_const_val(n) >= 0) &&
	   (WN_const_val(n) <= 3));
  }
 
static bool is_nop_cvtl (WN *n)
  {
    if (WN_operator(n) == OPR_CVTL)
    {
      WN *kid0 = WN_kid0(n);
      if (WN_operator(kid0) == OPR_LDID && !is_preg(kid0))
      {
	if ((WN_rtype(kid0) == WN_rtype(n)) &&
	    (MTYPE_bit_size(WN_desc(kid0)) == WN_cvtl_bits(n)))
	  return TRUE;

#if 0
	/* peng says we can't assume the rtype and desc indicated by
           the home location are valid over the entire live-range of
           the preg. */
	WN *home = preg_home(kid0);
	if (home &&
	    (WN_operator(home) == OPR_LDID) &&
	    (WN_rtype(home) == WN_rtype(n)) &&
	    (MTYPE_bit_size(WN_desc(home)) == WN_cvtl_bits(n)))
	  return TRUE;
#endif
      } else if (WN_operator(kid0) == OPR_INTRINSIC_OP &&
		 INTRN_is_tie_intrinsic(WN_intrinsic(kid0))) {
	  TIE_MACRO_ID tie_macro_id =
		Intrinsic_To_Tie_Macro_Id(WN_intrinsic(kid0));
	  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
	  if ((WN_rtype(kid0) == WN_rtype(n)) &&
	      (MTYPE_bit_size(
		tie_info->mtype_id(tie_macro->return_type_name())) ==
	       WN_cvtl_bits(n)))
	    return TRUE;
      }
    }

    return FALSE;
  }
 
/* Predicates for allowed immediates. */ 

static bool tn_has_value (TN *tn, INT32 val)
  {
    return TN_has_value(tn) && (TN_value(tn) == val);
  }
 
static bool tn_immediate_value (TN *tn, INT64 *val, bool allow_symbol_tn)
  {
    if (TN_is_constant(tn))
      {
	if (TN_has_value(tn))
	  {
	    *val = TN_value(tn);
	    return true;
	  }
	else if (allow_symbol_tn && TN_is_symbol(tn))
	  {
	    ST *st = TN_var(tn);
	    ST *base_st;
	    INT64 base_ofst;
	    
	    *val = TN_value(tn);
	    
	    Base_Symbol_And_Offset(st, &base_st, &base_ofst);
	    if (base_st == SP_Sym || base_st == FP_Sym)
	      {
		*val += base_ofst;
	      }
	    
	    return true;
	  }
      }

    return false;
  }

static bool wn_immediate_value (WN *n, ISA_LITCLASS lc,
				bool allow_symbol_tn =false,
				bool negate =false)
  {
    INT64 val;
    if( WN_operator(n)==OPR_TN )
      {
	if (!tn_immediate_value(WN_tn(n), &val, allow_symbol_tn))
	  return false;
      }
    else if (WN_operator(n)==OPR_INTCONST)
      {
	val = WN_const_val(n);
      }
    else
      return false;

    if (negate)
      val = -val;
    
    return TI_ISA_LC_Value_In_Class(val, lc);
  }

static bool is_one(WN *n)
{
  return WN_const_val(n)==1;
}

static bool is_zero(WN *n)
{
  return WN_const_val(n)==0;
}

static bool is_thirtytwo(WN *n)
{
  return WN_const_val(n)==32;
}

static bool hw_idiv32(WN *n)
{
  return xt_div32;
}

static bool is_extui_mask(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  INT64 val = WN_const_val(n);
  return((val > 0) && (val < 65536) && IS_POWER_OF_2(val + 1));
}

static bool is_extui_shift_mask(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  return Get_Extui_Shift_Mask(WN_const_val(n));
}

static bool is_bbci_bbsi_imm(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  return Get_Bbci_Bbsi_Immediate(WN_const_val(n));
}

static bool is_clamps_const(WN *n)
{
  Is_True(WN_operator(n) == OPR_INTCONST, ("expecting OPR_INTCONST"));
  INT64 val = WN_const_val(n);
  if (val >= 0)
    return((val >= 127) && (val < 4194304) && IS_POWER_OF_2(val + 1));
  else
    return((val <= -128) && (val >= -4194304) && IS_POWER_OF_2(-val));
}

static bool is_left_right_shift_pair(WN *c0, WN *c1)
{
  if (WN_operator(c0) != OPR_INTCONST)
  {
    c0 = preg_equivalent_literal(c0);
    if (!c0)
      return FALSE;
  }

  if (WN_operator(c1) != OPR_INTCONST)
  {
    c1 = preg_equivalent_literal(c1);
    if (!c1)
      return FALSE;
  }

  return(WN_const_val(c0) == 32 - WN_const_val(c1));
}

static bool is_clamps_const_pair(WN *c0, WN *c1)
{
  if (WN_operator(c0) != OPR_INTCONST)
  {
    c0 = preg_equivalent_literal(c0);
    if (!c0)
      return FALSE;
  }

  if (WN_operator(c1) != OPR_INTCONST)
  {
    c1 = preg_equivalent_literal(c1);
    if (!c1)
      return FALSE;
  }

  Is_True(is_clamps_const(c0) && is_clamps_const(c1), (""));
  return(WN_const_val(c0) == (-WN_const_val(c1) - 1));
}


static bool is_simm8x256(WN *n) { return wn_immediate_value(n, LC_simm8x256); }
static bool is_simm4(WN *n)     { return wn_immediate_value(n, LC_simm4); }
static bool is_simm7(WN *n)     { return wn_immediate_value(n, LC_simm7); }
static bool is_simm8(WN *n)     { return wn_immediate_value(n, LC_simm8); }
static bool is_simm12(WN *n)    { return wn_immediate_value(n, LC_simm12); }
static bool is_simm16(WN *n)    { return wn_immediate_value(n, LC_simm16); }
static bool is_simm32(WN *n)    { return wn_immediate_value(n, LC_simm32, true); }
static bool is_uimm12x8(WN *n)  { return wn_immediate_value(n, LC_uimm12x8); }
static bool is_uimm16x4(WN *n)  { return wn_immediate_value(n, LC_uimm16x4); }
static bool is_uimm4(WN *n)     { return wn_immediate_value(n, LC_uimm4); }
static bool is_uimm5(WN *n)     { return wn_immediate_value(n, LC_uimm5); }
static bool is_uimm8(WN *n)     { return wn_immediate_value(n, LC_uimm8); }
static bool is_uimm8x2(WN *n)   { return wn_immediate_value(n, LC_uimm8x2); }
static bool is_uimm8x4(WN *n)   { return wn_immediate_value(n, LC_uimm8x4); }
static bool is_ai4const(WN *n)  { return wn_immediate_value(n, LC_ai4const); }
static bool is_b4constu(WN *n)  { return wn_immediate_value(n, LC_b4constu); }
static bool is_b4const(WN *n)   { return wn_immediate_value(n, LC_b4const); }
static bool is_lsi4x4(WN *n)    { return wn_immediate_value(n, LC_lsi4x4); }
static bool is_op2p1(WN *n)     { return wn_immediate_value(n, LC_op2p1); }
static bool is_tp7(WN *n)       { return wn_immediate_value(n, LC_tp7); }
static bool is_msalp32(WN *n)   { return wn_immediate_value(n, LC_msalp32); }

static bool is_simm8x256_negated(WN *n) { return wn_immediate_value(n, LC_simm8x256, false, true); }
 
/* Code generation function */

static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    TN *base_tn, INT64 base_ofst, OPS *ops,
			    bool is_tie_macro, bool is_float);
static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    ST *s, INT64 o, OPS *ops,
			    bool conservative_addr,
			    bool is_tie_macro, bool is_float);

// Given a symbol which may represent a constant, create a literal whose value
// is a pointer to it.  Put the literal value in the .begin literal section for
// the current function.

static ST *Generate_Literal_Pointer_Nonbased( ST *s, INT64 o );
static ST *Generate_Literal_Label( LABEL_IDX lab );
static ST *Generate_Literal_Pointer( ST *s, INT64 o );

//constant loading functions
extern TN *Generate_Constant (TYPE_ID rtype, TN *result, INT32 val, OPS *ops);
extern TN *Generate_Constant (TYPE_ID rtype, WN* wn, TN *result, TN *src, OPS *ops);
extern TN *Generate_Constant (TYPE_ID rtype, WN *wn, TN* result, ST *s, INT64 o, OPS *ops);
static ST *Generate_Literal_Float( float );

static void Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, ST *s, INT64 o, INT16 variant, OPS *ops);
static void Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, TN *addr, INT64 o, INT16 variant, OPS *ops);
static TN *Generate_Load_Memory (WN *tree, TYPE_ID rtype, TYPE_ID desc, TN *result,
				 ST *s, INT64 o, INT16 variant, OPS *ops);
static TN *Generate_Load_Memory (WN *tree, TYPE_ID rtype, TYPE_ID desc, TN *result,
				 TN *addr, INT64 o, INT16 variant, OPS *ops);

static TN *
round_mode_tn()
{
  static TN *rm_tn = NULL;
  FmtAssert(xt_hard_float, ("RoundMode state register requires FP hardware"));
  if (rm_tn == NULL) {
    rm_tn = Gen_State_Register_TN("RoundMode");
  }
  return rm_tn;
}

static TN *
xtsync_tn()
{
  static TN *xtsync_tn = NULL;
  if (xtsync_tn == NULL) {
    xtsync_tn = Gen_State_Register_TN("XTSYNC");
  }
  return xtsync_tn;
}

static TN *
accum_tn()
{
  static TN *acc_tn = NULL;
  FmtAssert(xt_mac16, ("Accumulator state register requires MAC16 hardware"));
  if (acc_tn == NULL) {
    acc_tn = Gen_State_Register_TN("ACC");
  }
  return acc_tn;
}

static TN *
float_preg_to_int_tn(ST *preg_st, PREG_NUM preg_num)
{
  TN *tn = PREG_To_TN(preg_st, preg_num);
  if (TN_mtype(tn) == MTYPE_F4) {
    Set_TN_mtype(tn, MTYPE_I4);
    Set_TN_register_class(tn, TI_ISA_Regclass_Integer());
    PREG_To_TN_Mtype[preg_num] = MTYPE_I4;
  }
  return tn;
}


static TN *
build_hifi2_pr_tn ()
{
  Is_True(xt_hifi2, ("Expected HiFi2"));
  return Build_TN_Of_Mtype(TI_ISA_Mtype_For_Regclass(TI_ISA_Regclass_HiFi2_PR()));
}


static TN *
build_hifi2_qr_tn ()
{
  Is_True(xt_hifi2, ("Expected HiFi2"));
  return Build_TN_Of_Mtype(TI_ISA_Mtype_For_Regclass(TI_ISA_Regclass_HiFi2_QR()));
}


static void Check_For_Dedicated_Preg (WN *n)
{
  if (ST_assigned_to_dedicated_preg(WN_st(n)))
  {
    WN_offset(n) = Find_PREG_For_Symbol(WN_st(n));
    WN_st_idx(n) = ST_st_idx(MTYPE_To_PREG(ST_mtype(WN_st(n))));
    Set_TN_is_asm_reg(PREG_To_TN(WN_st(n),WN_offset(n)));
  }
}

static WN *preg_home (WN *ldid)
{
  BOOL dum;

  if ((WN_class(ldid) == CLASS_PREG) && !Preg_Is_Dedicated(WN_load_offset(ldid)))
    return Preg_Is_Rematerializable(WN_load_offset(ldid), &dum);

  return NULL;
}

static WN *preg_equivalent_literal (WN *ldid)
{
  WN *lit = preg_home(ldid);
  if (lit && (WN_operator(lit) == OPR_INTCONST))
    return lit;

  return NULL;
}

static BOOL
tn_is_const_equiv (TN *tn)
{
  if (TN_has_value(tn))
    return TRUE;

  if (TN_is_register(tn) && TN_is_rematerializable(tn) &&
      TN_home(tn) && (WN_operator(TN_home(tn)) == OPR_INTCONST))
    return TRUE;

  return FALSE;
}

static INT64
tn_equiv_const (TN *tn)
{
  if (TN_has_value(tn))
    return TN_value(tn);

  if (TN_is_register(tn) && TN_is_rematerializable(tn) &&
      TN_home(tn) && (WN_operator(TN_home(tn)) == OPR_INTCONST))
    return WN_const_val(TN_home(tn));

  FmtAssert(FALSE, ("expecting tn equivalent to constant\n"));
}


static BOOL
Get_Extui_Shift_Mask (UINT64 val, INT32 *shift, INT32 *size)
{
  /* we only get here for MTYPE_I4 or MTYPE_U4, so we can truncate
     upper bits. */
  val = val & 0x00000000ffffffffll;

  INT64 hb = TARG_INT_Most_Sig_One(val);
  INT64 lb = TARG_INT_Least_Sig_One(val);
  if ((lb == -1) || (hb == -1) ||
      (lb > 31) || (hb > 31) ||
      ((hb-lb) >= 16) ||
      !Immediate_Has_All_Ones(val, hb, lb))
    return FALSE;

  if (shift)
    *shift = lb;
  if (size)
    *size = hb - lb + 1;

  return TRUE;
}

static BOOL
Get_Bbci_Bbsi_Immediate (INT64 val, INT32 *imm)
{
  if ((val < 0) || !IS_POWER_OF_2(val))
    return FALSE;

  INT64 bit = TARG_INT_Least_Sig_One(val);
  if ((bit == -1) || (bit > 31))
    return FALSE;

  if (imm)
    *imm = bit;

  return TRUE;
}

static void
Generate_Const16 (TYPE_ID rtype, TN *result, TN *src, OPS *ops)
{
  Is_True(xt_const16, ("Config doesn't support const16"));
  Build_OP(TOP_const16hi, result, src, ops);
  Build_OP(TOP_const16lo, result, result, src, ops);
}

static void
Generate_Movi (TYPE_ID rtype, TN *result, TN *src, OPS *ops)
{
  Build_OP(TOP_movi, result, src, ops);
}

static void
Generate_Load_Const (TYPE_ID rtype, TN *result, TN *src, OPS *ops)
{
  Build_OP(TOP_load_const, result, src, ops);
}

/* Sign or zero extend, based on 'rtype', the lower 'bits' of 'src'
   into 'result'. To extend a byte, 'bits' should be 8, for a short
   'bits' should be 16, etc. */
static TN *
Generate_Extend (TYPE_ID rtype, TN *result, TN *src, UINT32 bits, OPS *ops)
{
  Is_True((bits > 0) && (bits < 32), ("Generate_Extend: unexpected bits value %d", bits));

  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  /* If we have sext instruction then use it, otherwise we have to use either
     an extract or shifts. */

  if (xt_sext && MTYPE_is_signed(rtype) && (bits >= 8) && (bits <= 23))
  {
    Build_OP(TOP_sext, result, src, Gen_Literal_TN(bits - 1, 4), ops);
  }
  else if (MTYPE_is_unsigned(rtype) && (bits <= 16))
  {
    Build_OP(TOP_extui, result, src, Gen_Literal_TN(0, 4), Gen_Literal_TN(bits, 4), ops);
  }
  else
  {
    TN *tmp = Build_TN_Of_Mtype(rtype);
    Build_OP(TOP_slli, tmp, src, Gen_Literal_TN(32 - bits, 4), ops);
    Build_OP(MTYPE_is_unsigned(rtype) ? TOP_srli : TOP_srai,
	     result, tmp, Gen_Literal_TN(32 - bits, 4), ops);
  }

  return result;
}

TN *
Generate_Constant (TYPE_ID rtype, TN *result, INT32 val, OPS *ops)
{
  TN *src = Gen_Literal_TN(val, 4);
  return Generate_Constant(rtype, WN_Intconst(rtype, val), result, src, ops);
}

TN *
Generate_Constant (TYPE_ID rtype, WN* wn, TN *result, TN *src, OPS *ops)
{
  FmtAssert(TN_is_constant(src), ("not a constant TN"));

  /* If we aren't given a result tn, then create one and mark it as
     rematerializable. */
  
  if (!result)
  {
    result = Build_TN_Of_Mtype(rtype);
    if (CGSPILL_Rematerialize_Constants && wn)
    {
      Set_TN_is_rematerializable(result);
      Set_TN_home(result, wn);
    }
  }
  
  if (TN_has_value(src) && TI_ISA_LC_Value_In_Class(TN_value(src), LC_simm12))
    Generate_Movi(rtype, result, src, ops);
  else
  {
    if (xt_prefer_const16)
      Generate_Const16(rtype, result, src, ops);
    else
      Generate_Load_Const(rtype, result, src, ops);
  }
  return result;
}

TN *
Generate_Constant(TYPE_ID rtype, WN *wn, TN* result, ST *s, INT64 o, OPS *ops)
{
  /* If we aren't given a result tn, then create one and mark it as
     rematerializable. */
  
  if (!result)
  {
    result = Build_TN_Of_Mtype(rtype);
    if (CGSPILL_Rematerialize_Constants && wn)
    {
      Set_TN_is_rematerializable(result);
      Set_TN_home(result, wn);
    }
  }

  Allocate_Object(s);

  TN* tn = Gen_Symbol_TN(s, o, TN_RELOC_NONE);
  if (xt_prefer_const16)
    Generate_Const16(rtype, result, tn, ops);
  else
    Generate_Load_Const(rtype, result, tn, ops);

  return result;
}

extern TN *Move_To_Register (TYPE_ID rtype, TN *result, TN *val, OPS *ops)
{
  if (result &&
      (MTYPE_is_tie(TN_mtype(result)) ||
       MTYPE_is_tie(TN_mtype(val))))
  {
    if (result!=val) {
      FmtAssert(TN_is_register(val), ("expecting register tn"));
      result = Tie_Move_To_Result(result,val,ops);
    }
  }
  else if (MTYPE_is_xtbool(rtype)) {
    if (TN_register(val) && TN_is_dedicated(val)) {
        if (!result)
	  result = Build_TN_Of_Mtype(rtype);
    } else
      FmtAssert(rtype==TN_mtype(val) && TN_is_register(val),
				("Expecting source br register tn"));
    if (result && result != val) {
      FmtAssert(TN_is_register(result), ("Expecting result br register tn"));
      FmtAssert(TN_is_dedicated(result) ||
		TN_is_dedicated(val) ||
		TN_mtype(val)==TN_mtype(result),
				("Move between different xtbool types"));

      /* first try to see if there is a real move macro */
      TIE_MACRO_p macro = tie_info->mtype_move_macro(rtype);
      if (macro && macro->num_instructions()!=0) {
	result = Tie_Move_To_Result(result,val,ops);
      } else if (rtype == MTYPE_XTBOOL) {
        Build_OP(TOP_movbr, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      } else if (rtype == MTYPE_XTBOOL2) {
        Build_OP(TOP_movbr2, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      } else if (rtype == MTYPE_XTBOOL4) {
        Build_OP(TOP_movbr4, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      } else if (rtype == MTYPE_XTBOOL8) {
        TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
        TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
        Build_OP(TOP_get_tmp_ar, tmp1, ops );
        Build_OP(TOP_get_tmp_ar, tmp2, ops );
        Build_OP(TOP_movbr8, result, val, tmp1, tmp2, ops );
      } else {
        Build_OP(TOP_movbr16, result, val, ops );
        Set_OP_copy (OPS_last(ops));
      }
    } else
      result = val;
  }
  else if (TN_has_value(val))
  {
    result = Generate_Constant(rtype, result, TN_value(val), ops);
  }
  else if (result && result != val)
  {
    FmtAssert(TN_is_register(val), ("expecting register tn"));
    if (xt_hard_float && rtype == MTYPE_F4) {
      TOP mov = tie_info->xtfloat_move_topcode();
      TN* state1 = cpenable_tn(mov);
      if (state1)
        Build_OP(mov, result, val, state1 /* cpenable_tn()*/, ops );
      else
        Build_OP(mov, result, val, ops );
    } else {
      TOP mov = TOP_mov_n;
      Build_OP(mov, result, val, ops );
    }
    Set_OP_copy (OPS_last(ops));
  }
  else
  {
    result = val;
  }
  
  return result;
}

static void
Generate_Call ( WN *n, TOP t, OPS *ops )
{
  ST *s = WN_st(n);
  TN *tn, *ret_addr_tn;
  ISA_REGCLASS ar = TI_ISA_Regclass_Integer();
  REGISTER ret_addr_reg;
  INT first_reg = TI_ISA_Regclass_First_Reg(TI_ISA_Regclass_Info(ar)) +
    REGISTER_MIN;
  switch (t) {
  case TOP_call0:
    ret_addr_reg = first_reg + 0; break;
  case TOP_call4:
    ret_addr_reg = first_reg + 4; break;
  case TOP_call8:
    ret_addr_reg = first_reg + 8; break;
  case TOP_call12:
    ret_addr_reg = first_reg + 12; break;
  }
  ret_addr_tn = Build_Dedicated_TN(ar, ret_addr_reg, 4);

  if ( Gen_Indirect_Call || 
       (Gen_PIC_Shared && (ST_export(s) != EXPORT_LOCAL))) {
    char *buf = (char *)alloca(strlen(ST_name(s))+5);
    sprintf (buf, "%s@PLT", ST_name(s));
    ST *plt_st = Gen_Intrinsic_Function(ST_type(s), buf);
    Set_ST_suppress_asm_type(plt_st);

    tn = Generate_Constant(MTYPE_U4, NULL, NULL, plt_st, 0, ops);
    switch (t) {
    case TOP_call0: t = TOP_callx0; break;
    case TOP_call4: t = TOP_callx4; break;
    case TOP_call8: t = TOP_callx8; break;
    case TOP_call12: t = TOP_callx12; break;
    }
  } else
    tn = Gen_Symbol_TN( s, 0, TN_RELOC_NONE );
  PU_Has_Calls = TRUE;
  Set_Last_Mem_OP( ops );
  Build_OP( t, ret_addr_tn, tn, ops );
  Handle_Call_Site_Extras( n, WN_operator( n ) );
}

static TN *
Generate_Binary(TYPE_ID mtype, TOP t,
		TN *result, TN *left, TN *right, OPS *ops)
{
  Is_True(!MTYPE_is_float(mtype), ("Generate_Binary() used on float type"));
  if( !result )
    result = Build_TN_Of_Mtype(mtype);

  Build_OP(t, result, left, right, ops );
  return result;
}


static TN *
Generate_Unary_CPENABLE (TOP t, TN *result, TN *src, OPS *ops)
{
  Is_True(t != TOP_UNDEFINED, ("Unknown instruction."));
  Is_True(TI_ISA_Op_Results(TI_ISA_Operand_Info(t)) == 1,
          ("Unexpected number of results."));
  
  TN *cpenable_state = cpenable_tn(t);
  if (cpenable_state)
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 2,
            ("Unexpected number of operands."));
    Build_OP(t, result, src, cpenable_state, ops);
  }
  else
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 1,
            ("Unexpected number of operands."));
    Build_OP(t, result, src, ops);
  }

  return result;
}


static TN *
Generate_Binary_CPENABLE (TOP t, TN *result, TN *left, TN *right, OPS *ops)
{
  Is_True(t != TOP_UNDEFINED, ("Unknown instruction."));
  Is_True(TI_ISA_Op_Results(TI_ISA_Operand_Info(t)) == 1,
          ("Unexpected number of results."));
  
  TN *cpenable_state = cpenable_tn(t);
  if (cpenable_state)
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 3,
            ("Unexpected number of operands."));
    Build_OP(t, result, left, right, cpenable_state, ops);
  }
  else
  {
    Is_True(TI_ISA_Op_Operands(TI_ISA_Operand_Info(t)) == 2,
            ("Unexpected number of operands."));
    Build_OP(t, result, left, right, ops);
  }

  return result;
}


static TN *
Generate_Binary_Mul(TYPE_ID mtype, TOP t,
		TN *result, TN *left, TN *right, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(mtype);

  TN* state2 = cpenable_tn(t);
  if (state2)
    Build_OP(t, result, left, right, state2 /* cpenable_tn() */, ops );
  else
    Build_OP(t, result, left, right, ops );
  return result;
}

static TN *
Generate_Binary_FP(TYPE_ID mtype, TOP t,
		   TN *result, TN *left, TN *right, BOOL roundmode, OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(mtype);
  if (roundmode) {
    TN* state3 = cpenable_tn(t);
    if (state3)
      Build_OP(t, result, left, right, round_mode_tn(), state3 /* cpenable_tn() */, ops);
    else
      Build_OP(t, result, left, right, round_mode_tn(),  ops);
  } else {
    TN* state2 = cpenable_tn(t);
    if (state2)
      Build_OP(t, result, left, right, state2 /* cpenable_tn() */, ops);
    else
      Build_OP(t, result, left, right, ops);
  }
  return result;
}

static TN *
Generate_Unary(TYPE_ID mtype, TOP t,
	       TN *result, TN *src, OPS *ops)
{
  Is_True(!MTYPE_is_float(mtype), ("Generate_Unary() used on float type"));
  if( !result )
    result = Build_TN_Of_Mtype(mtype);
  Build_OP(t, result, src, ops);
  return result;
}

static TN *
Generate_Unary_FP(TYPE_ID mtype, TOP t,
	       TN *result, TN *src, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(mtype);
  TN* state1 = cpenable_tn(t);
  if (state1)
    Build_OP(t, result, src, state1 /* cpenable_tn() */, ops);
  else
    Build_OP(t, result, src, ops);
  return result;
}

static TN *
Generate_And_Immediate (TYPE_ID rtype, TN *result, TN *reg, TN *imm, OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  imm = Gen_Literal_TN(TARG_INT_Least_Sig_One(TN_value(imm) + 1), 4);
  Build_OP(TOP_extui, result, reg, Gen_Literal_TN(0,4), imm, ops);

  return result;
}

static TN *
Generate_Sub (TYPE_ID rtype, TN *result, TN *left, TN *right, OPS *ops)
{
  BOOL negate = FALSE;

  /* If both 'left' and 'right' are immediates, then we can just
     perform the subtraction now. */
  if ((CG_opt_level > 0) && tn_is_const_equiv(left) && tn_is_const_equiv(right))
  {
    DevWarn("both operands to subtract are constant");
    return Generate_Constant(rtype, result, tn_equiv_const(left)-tn_equiv_const(right), ops);
  }

  /* If 'left' is an immediate, we must first load it into a
     register. */
  if (TN_has_value(left))
    left = Generate_Constant(rtype, 0, TN_value(left), ops);

  FmtAssert(TN_is_register(left), ("operand 0 of subtract must be register"));
  FmtAssert(TN_is_register(right) || TN_has_value(right),
	    ("operand 1 of subtract must be register or immediate"));
  
  if (tn_is_const_equiv(right) && TI_ISA_LC_Value_In_Class(-tn_equiv_const(right), LC_simm8))
  {
    result = Generate_Binary(MTYPE_I4, TOP_addi, result, left,
			     Gen_Literal_TN(-tn_equiv_const(right), 4), ops);
  }
  else
  {
    /* If 'right' is an immediate, we must first load it into a
       register (It doesn't fit in the addi immediate field, so we get
       here...). */
    if (TN_has_value(right))
      right = Generate_Constant(rtype, 0, TN_value(right), ops);

    result = Generate_Binary(MTYPE_I4, TOP_sub, result, left, right, ops);
  }

  return result;
}

static TN *
Generate_HiFi2_Mul (TYPE_ID rtype, TN *result, WN *result_wn,
                    TN *left, TN *right, OPS *ops)
{
  Is_True(xt_hifi2, ("Expected a HiFi2 configuration."));
  Is_True(WN_Mpy_16Bit(result_wn), ("No support for 32-bit multiplcation on HiFi2"));
  
  if( !result )
    result = Build_TN_Of_Mtype(rtype);
  
  if (WN_Mpy_16Bit_Signed(result_wn))
  {
    /* Signed 16-bit multiplication. */
    TN *pr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_cvtp24a16x2.ll"),
                                      build_hifi2_pr_tn(), left, right, ops);
    TN *qr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_mulp24s.hl"),
                                      build_hifi2_qr_tn(), pr, pr, ops);
    result = Generate_Unary_CPENABLE(TI_TOP_Topcode("ae_trunca32q48"),
                                     result, qr, ops);
    return result;
  }
    
  /* Unsigned 16-bit multiplication. The TNs must be correctly
     zero-extended. */
  TN *pr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_movpa24x2"),
                                    build_hifi2_pr_tn(), left, right, ops);
  TN *qr = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_mulp24s.hl"),
                                    build_hifi2_qr_tn(), pr, pr, ops);
  TN *qr_shl = Generate_Binary_CPENABLE(TI_TOP_Topcode("ae_slliq56"),
                                        build_hifi2_qr_tn(), qr,
                                        Gen_Literal_TN(16, 4), ops);
  result = Generate_Unary_CPENABLE(TI_TOP_Topcode("ae_trunca32q48"),
                                   result, qr_shl, ops);
  return result;
}


static TN *
Generate_Mul (TYPE_ID rtype, TN *result, WN *result_wn,
              char * instruction_name, TN *left, TN *right, OPS *ops)
{
  Is_True(xt_mul16 || xt_mul32 || Enable_HiFi2_Ops,
	  ("Cannot generate multiply instructions"));

  /* If both 'left' and 'right' are immediates, then we can just
     perform the multiply now. */
  if ((CG_opt_level > 0) && tn_is_const_equiv(left) && tn_is_const_equiv(right))
  {
    DevWarn("both operands to mult are constant");
    return Generate_Constant(rtype, result, tn_equiv_const(left)*tn_equiv_const(right), ops);
  }

  /* If 'left' is an immediate, we must first load it into a
     register. */
  if (TN_has_value(left))
    left = Generate_Constant(rtype, 0, TN_value(left), ops);

  /* If 'right' is an immediate, we must first load it into a
     register */
  if (TN_has_value(right))
      right = Generate_Constant(rtype, 0, TN_value(right), ops);

  if (instruction_name)
  {
    Is_True(xt_mul16 || xt_mul32,
            ("No MUL16 or MUL32 option available."));
    TOP top = TI_TOP_Topcode(instruction_name);
    Is_True((top != TOP_UNDEFINED), ("Cannot generate %s instruction", instruction_name));
    result = Generate_Binary_Mul(rtype, top, result, left, right, ops);
  }
  else
  {
    /* Implement the multiplication through HiFi2 operations. */
    Is_True(Enable_HiFi2_Ops, ("Unable to use HiFi2 instructions."));
    result = Generate_HiFi2_Mul(rtype, result, result_wn, left, right, ops);
  }
  
  return result;
}

static TN *
Generate_iDivRem(TYPE_ID rtype, TOP divRem_top, TN *result, TN *divident, TN *divisor, OPS *ops)
{
  Is_True(xt_div32, ("Cannot generate integer divide"));

  /* If any operand is constant, load it into register */
  if (TN_has_value(divident)) {
    divident = Generate_Constant(TN_mtype(divident), 0, TN_value(divident), ops);
  }

  if (TN_has_value(divisor)) {
    divisor = Generate_Constant(TN_mtype(divisor), 0, TN_value(divisor), ops);
  }

  if ( !result ) {
    result = Build_TN_Of_Mtype(rtype);
  }
  Build_OP(divRem_top, result, divident, divisor, ops);
  return result;
}

static TN *
Generate_AddShift(WN *wn, TYPE_ID rtype, TN *result, TN *left, TN *right, TN *shift, OPS *ops)
{
  TOP top = TOP_UNDEFINED;
  
  FmtAssert(xt_addx, ("Config does not support addx"));

  if (!result) 
    result = Build_TN_Of_Mtype(rtype);

  if (TN_has_value(shift))
  {
    switch (TN_value(shift))
    {
    case 0:
      top = TOP_add;
      break;
    case 1:
      top = TOP_addx2;
      break;
    case 2:
      top = TOP_addx4;
      break;
    case 3:
      top = TOP_addx8;
      break;
    }
  }

  FmtAssert(top != TOP_UNDEFINED, ("unable to form shift-add combination"));
  Build_OP(top, result, left, right, ops);
  return result;
}

static TN *
Generate_SubShift(WN *wn, TYPE_ID rtype, TN *result, TN *left, TN *right, TN *shift, OPS *ops)
{
  TOP top = TOP_UNDEFINED;
  
  FmtAssert(xt_addx, ("Config does not support subx"));

  if (!result) 
    result = Build_TN_Of_Mtype(rtype);

  if (TN_has_value(shift))
  {
    switch (TN_value(shift))
    {
    case 0:
      top = TOP_sub;
      break;
    case 1:
      top = TOP_subx2;
      break;
    case 2:
      top = TOP_subx4;
      break;
    case 3:
      top = TOP_subx8;
      break;
    }
  }

  FmtAssert(top != TOP_UNDEFINED, ("unable to form shift-sub combination"));
  Build_OP(top, result, left, right, ops);
  return result;
}

static void
Generate_Branch (WN *wn, TYPE_ID desc, TOP top, LABEL_IDX target, TN *l, TN *r, OPS *ops)
{
  BOOL reload = FALSE;
  

  /* If 'l' and/or 'r' is a constant tn, then try to use an immediate
     form of branch 'top'. If we can't use an immediate form, then just
     load the constant into a register tn. */

  if (TN_has_value(l) || TN_has_value(r))
  {
    /* If both 'l' and 'r' are constant, then give a warning since the
       optimizer should have eliminated the branch. Below we will load
       both constants into registers for the branch. We don't bother
       to try to optimize this case by using one tn as an immediate,
       since it should be caught by the optimizer. */

    if (TN_has_value(l) && TN_has_value(r))
    {
      reload = TRUE;
      DevWarn("Found compile-time constant branch condition");
    }
    else
    {
      /* Put the immediate as the second operand. */

      BOOL flip = TN_has_value(l);
      TN *tl = l;
      TN *tr = r;
      
      if (flip)
      {
	tl = r;
	tr = l;
      }

      /* Try to create an immediate version of the branch. If we fail,
         then mark that we need to reload all constant tns into
         registers. */

      INT64 imm_val = TN_value(tr);
      if (TI_Equivalent_Immed_Branch(&top, &imm_val, flip))
      {
	/* We created an immediate version of the branch... */

	l = tl;
	r = tr;
	
	/* If the new branch has only 2 operands, then show that 'r'
           is no longer used. Otherwise, if 'imm_val' has changed then create a
           new immediate tn to represent it. */

	const ISA_OPERAND_INFO *info = TI_ISA_Operand_Info(top);
	const INT ops = TI_ISA_Op_Operands(info);
	FmtAssert((ops == 2) || (ops == 3), ("expecting branch to have 2 or 3 operands, not %d", ops));
  
	if (ops == 2)
	  r = NULL;
	else if (imm_val != TN_value(r))
	  r = Gen_Literal_TN(imm_val, 4);
      }
      else
      {
	reload = TRUE;
      }
    }
  }
  
  /* Reload constant tns into registers, if necessary. */

  if (reload)
  {
    if (TN_has_value(l))
      l = Generate_Constant(desc, 0, TN_value(l), ops);
    if (TN_has_value(r))
      r = Generate_Constant(desc, 0, TN_value(r), ops);
  }

  if (r == NULL)
    Build_OP(top, l, Gen_Label_TN(target, 0), ops);
  else
    Build_OP(top, l, r, Gen_Label_TN(target, 0), ops);

  if (wn)
    End_Basic_Block(wn);
}

static TN *
Generate_Cmov (TYPE_ID rtype, TOP top, TN *result, TN *cond, TN *tn_true, TN* tn_false, OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  /* If 'tn_true' == NULL we use literal 1. If 'tn_false' is NULL we
     use literal 0. */

  if (!tn_true)
    tn_true = Generate_Constant(rtype, tn_true, 1, ops);
  if (!tn_false)
    tn_false = Generate_Constant(rtype, tn_false, 0, ops);
  
  /* Get the condition tn. We must copy it to a temporary tn if 'cond'
     == 'result' since we clobber 'result' before using 'cond'. We
     must also put 'cond' in a register if it is a constant. */

  if ((cond == result) || TN_has_value(cond))
    cond = Move_To_Register(MTYPE_I4, Build_TN_Of_Mtype(MTYPE_I4), cond, ops);

  /* Get the true tn. We must copy it to a temporary tn if 'tn_true'
     == 'result' since we clobber 'result' before using 'tn_true'.  We
     must also put 'tn_true' in a register if it is a constant.*/

  if ((tn_true == result) || TN_has_value(tn_true))
    tn_true = Move_To_Register(rtype, Build_TN_Of_Mtype(rtype), tn_true, ops);

  /* Evaluate false side into result, then conditional move true side
     into result. */
  
  result = Move_To_Register(rtype, result, tn_false, ops);
  if (MTYPE_is_float(rtype)) {
    TN* state3 = cpenable_tn(top);
    if (state3)
      Build_OP(top, result, result, tn_true, cond, state3 /* cpenable_tn() */, ops);
    else
      Build_OP(top, result, result, tn_true, cond, ops);
  } else {
    Build_OP(top, result, result, tn_true, cond, ops);
  }
  return result;
}

static TN *
Generate_Branch_Select (TYPE_ID rtype, TYPE_ID desc, TOP t,
			TN *result, TN *l, TN *r,
			TN *tn_true, TN *tn_false,
			OPS *ops)
{
  LABEL_IDX label;
  BB *this_bb = Get_Cur_BB();

  TOP nt = CGTARG_Invert_Branch(t);
  if (nt != TOP_UNDEFINED)
  {
    BOOL swap = FALSE;
    
    /* If 'tn_false' is the same as 'result', and we can invert the
       branch, then do so and switch 'tn_true' and 'tn_false'. This
       gives better code since the copy of 'tn_true' to 'result' before
       the branch will then be a nop. */

    if (tn_false == result)
    {
      swap = TRUE;
    }
    /* If 'tn_false' is equivalent to a constant and is the same TN as
       'l' or 'r', then invert the branch, so that all uses of the
       constant occur in the first block (i.e. the copy of 'tn_true'
       to 'result' and the branch). Then, if we have to rematerialize
       the constant it can be done in a single location for both the
       copy and the branch.  */
    else if (tn_false && tn_is_const_equiv(tn_false) &&
	     ((tn_false == l) || (tn_false == r)))
    {
      swap = TRUE;
    }

    if (swap)
    {
      TN *tmp = tn_true;
      tn_true = tn_false;
      tn_false = tmp;
      t = nt;
    }
  }
  
  /* We need a temporary tn for the calculation. If 'result' is a
     non-dedicated tn and is not the same as one of the inputs that is
     used after 'result' is set (i.e. 'l', 'r', or 'tn_false'), then
     we can just use it, otherwise we must build one. */
  
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  TN *tmp = ((TN_is_dedicated(result) ||
	      (result == l) || (result == r) ||
	      (result == tn_false)) ?
	     Build_TN_Of_Mtype(rtype) : result);

  /* If 'tn_true' is non-null, then we want to use that as the true
     outcome, otherwise we just use the constant 1 as the true
     outcome. */

  if (!tn_true)
    Generate_Constant(rtype, tmp, 1, ops);
  else
    Move_To_Register(rtype, tmp, tn_true, ops);
    
  label = Gen_Temp_Label();
  Generate_Branch(NULL, desc, t, label, l, r, ops);

  Link_Pred_Succ(this_bb, Start_New_Basic_Block());

  /* If 'tn_false' is non-null, then we want to use that as the false
     outcome, otherwise we just use the constant 0 as the false
     outcome. */

  if (!tn_false)
    Generate_Constant(rtype, tmp, 0, ops);
  else
    Move_To_Register(rtype, tmp, tn_false, ops);

  /* Start a new basic block beginning with "label" and attach it to
     this_bb */
  Add_Label(label);
  Link_Pred_Succ(this_bb, Get_Cur_BB());

  /* If we used a temporary tn that is not 'result', then move that
     temporary to 'result'. */

  if (tmp != result)
    result = Move_To_Register(rtype, result, tmp, ops);
  
  return result;
}


static TN *
Generate_Conditional_Select (TYPE_ID rtype, TYPE_ID desc, OPERATOR opr,
			     TN *result, TN *l, TN *r,
			     TN *tn_true, TN *tn_false,
			     OPS *ops)
{
  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  /* If 'result' is a dedicated tn, then we must use a temporary
     register and copy that to 'result' at the end. */

  TN *orig_result = NULL;
  if (TN_is_dedicated(result))
  {
    orig_result = result;
    result = Build_TN_Of_Mtype(rtype);
  }

  /* We can sometimes use a more efficient sequence if 'l' or 'r' is a
     constant. Because of the way we are called, we can be passed 'l'
     or 'r' as a register TN that is equivalent to a constant. Below,
     when we can use a constant to simplify we use tn_is_const_equiv
     and tn_equiv_const to determine if a TN is equivalent to a
     constant. If we want to know if a TN itself is constant we use
     TN_has_value. */

  /* If 'tn_true' == NULL we assume it is literal 1. If 'tn_false' is
     NULL we assume it is literal 0. If 'tn_true' == 1 and 'tn_false'
     == 0 then we have a boolean result, for which we can sometimes
     generate better instruction sequences. */

  const BOOL boolean = ((!tn_true || (tn_is_const_equiv(tn_true) && (tn_equiv_const(tn_true) == 1))) &&
			(!tn_false || (tn_is_const_equiv(tn_false) && (tn_equiv_const(tn_false) == 0))));
  const BOOL signed_compare = MTYPE_signed(desc);
  const BOOL signed_result = MTYPE_signed(rtype);

  /* We may iterate here since some comparisons are best implemented
     by changing the operator, and we don't want to replicate all the
     logic. */

  BOOL repeat = TRUE;
  UINT repeat_cnt = 0;

  while (repeat)
  {
    FmtAssert(repeat < 3, ("expecting at most 3 iterations"));
    repeat = FALSE;
    repeat_cnt++;
    
    switch (opr)
    {
    case OPR_NE:
    {
      /* OPR_NE:

	 - for boolean we can be tricky and avoid loading an immediate
	 0, since that is available as the result of the subtract

	 - otherwise just subtract and cmov.

	 For both cases we are free to switch the order of operands in
	 the subtract since we are only interested in whether they are
	 equal or not.
      */
      if (boolean)
      {
	TN *one = Generate_Constant(MTYPE_I4, NULL, 1, ops);
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	  result = Move_To_Register(rtype, result, l, ops);
	else if (tn_is_const_equiv(l) && (tn_equiv_const(l) == 0))
	  result = Move_To_Register(rtype, result, r, ops);
	else
	{
	  if (TN_has_value(l))
	    SWAP_TNS(l, r);
      
	  result = Generate_Sub(rtype, result, l, r, ops);
	}
	
	Build_OP(TOP_movnez, result, result, one, result, ops);
      }
      else
      {
	TN *dif;
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	  dif = l;
	else if (tn_is_const_equiv(l) && (tn_equiv_const(l) == 0))
	  dif = r;
	else
	{
	  if (TN_has_value(l))
	    SWAP_TNS(l, r);

	  dif = Generate_Sub(rtype, 0, l, r, ops);
	}
	
	Generate_Cmov(rtype, TOP_movnez, result, dif, tn_true, tn_false, ops);
      }

      break;
    }

    case OPR_EQ:
    {
      /* OPR_EQ:

	 - just subtract and cmov.

	 We are free to switch the order of operands in the subtract
	 since we are only interested in whether they are equal or
	 not.
      */
      TN *dif;
      if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	dif = l;
      else if (tn_is_const_equiv(l) && (tn_equiv_const(l) == 0))
	dif = r;
      else
      {
	if (TN_has_value(l))
	  SWAP_TNS(l, r);
      
	dif = Generate_Sub(rtype, 0, l, r, ops);
      }

      Generate_Cmov(rtype, TOP_moveqz, result, dif, tn_true, tn_false, ops);
      break;
    }

    case OPR_GT:
      /* OPR_GT:

	 Just swap the comparison operands and let the OPR_LT case
	 handle it.
      */
      opr = OPR_LT;
      SWAP_TNS(l, r);
      // fall-through
      
    case OPR_LT:
    {
      /* OPR_LT:

	 if 'l' is a constant, then change to OPR_GE 'r' >= ('l'+1).

	 signed comparison

	 - if 'r' == 0, then we can use a cmov
	      
	 - otherwise we must branch

	 unsigned comparison

	 - if 'r' == 0 the result is always 'tn_false'.

	 - if 'r' == 1, then change to OPR_EQ 'l' == 0.

	 - otherwise we must use a branch
      */
      
      if (!TN_has_value(r) && TN_has_value(l) && (TN_value(l) < INT_MAX))
      {
	opr = OPR_GE;
	SWAP_TNS(l, r);
	r = Gen_Literal_TN(TN_value(r) + 1, 4);
	repeat = TRUE;
      }
      else if (signed_compare)
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  Generate_Cmov(rtype, TOP_movltz, result, l, tn_true, tn_false, ops);
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_blt,
					  result, l, r, tn_true, tn_false, ops);
	}
      }
      else
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  DevWarn("OPR_LT unsigned comparison l < 0 is always false");
	  if (!tn_false)
	    result = Generate_Constant(rtype, result, 0, ops);
	  else
	    result = Move_To_Register(rtype, result, tn_false, ops);
	}
	else if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 1))
	{
	  opr = OPR_EQ;
	  r = Gen_Literal_TN(0, 4);
	  repeat = TRUE;
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_bltu,
					  result, l, r, tn_true, tn_false, ops);
	}
      }

      break;
    }

    case OPR_LE:
      /* OPR_LE:

	 Just swap the comparison operands and let the OPR_GE case
	 handle it.
      */
      opr = OPR_GE;
      SWAP_TNS(l, r);
      // fall-through
      
    case OPR_GE:
    {
      /* OPR_GE:

	 if 'l' is a constant, then change to OPR_LT 'r' < ('l'+1).

	 signed comparison

	 - if 'r' == 0, then we can use a cmov
	      
	 - otherwise we must branch

	 unsigned comparison

	 - if 'r' == 0 the result is always 'tn_true'.

	 - if 'r' == 1, then change to OPR_NE 'l' != 0.

	 - otherwise we must use a branch
      */

      BOOL no_overflow = signed_compare ?  ((TN_value(l) < INT_MAX)) :
					   (TN_value(l)+1 != 0);
      
      if (!TN_has_value(r) && TN_has_value(l) && no_overflow)
      {
	opr = OPR_LT;
	SWAP_TNS(l, r);
	r = Gen_Literal_TN(TN_value(r) + 1, 4);
	repeat = TRUE;
      }
      else if (signed_compare)
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  Generate_Cmov(rtype, TOP_movgez, result, l, tn_true, tn_false, ops);
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_bge,
					  result, l, r, tn_true, tn_false, ops);
	}
      }
      else
      {
	if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 0))
	{
	  DevWarn("OPR_GE unsigned comparison l >= 0 is always true");
	  if (!tn_true)
	    result = Generate_Constant(rtype, result, 1, ops);
	  else
	    result = Move_To_Register(rtype, result, tn_true, ops);
	}
	else if (tn_is_const_equiv(r) && (tn_equiv_const(r) == 1))
	{
	  opr = OPR_NE;
	  r = Gen_Literal_TN(0, 4);
	  repeat = TRUE;
	}
	else
	{
	  result = Generate_Branch_Select(rtype, desc, TOP_bgeu,
					  result, l, r, tn_true, tn_false, ops);
	}
      }

      break;
    }

    default:
      FmtAssert(FALSE, ("Unknown comparison operator, %d\n", opr));
      break;
    }
  }

  if (orig_result)
    result = Move_To_Register(rtype, orig_result, result, ops);

  return result;
}

static TN *
Generate_Comparison (OPERATOR opr, TYPE_ID rtype, TYPE_ID desc,
		     TN *result, TN *l, TN *r, OPS *ops)
{
  return Generate_Conditional_Select(rtype, desc, opr, result, l, r,
				     NULL, NULL, ops);
}

// FP comparison using ar (address register) as return result
static TN *
Generate_FP_Comparison (OPERATOR opr, TYPE_ID rtype, TN *result, TN *l, TN *r, OPS *ops)
{
  FmtAssert(xt_hard_float, ("Cannot do FP compares without FP hardware"));
  Is_True(rtype == MTYPE_I4 || rtype == MTYPE_U4, 
          ("Expected MTYPE_I4 or MTYPE_U4 for FP compare result"));

  bool flip = false;
  TOP cmp = TOP_UNDEFINED, mov = TOP_UNDEFINED;

  switch (opr) {
    case OPR_EQ: 
      cmp = TI_TOP_Topcode("oeq.s");
      mov = TOP_movt;
      break;
    case OPR_NE: 
      cmp = TI_TOP_Topcode("oeq.s");
      mov = TOP_movf;
      break;
    case OPR_LT: 
      cmp = TI_TOP_Topcode("olt.s");
      mov = TOP_movt;
      break;
    case OPR_LE: 
      cmp = TI_TOP_Topcode("ole.s");
      mov = TOP_movt;
      break;
    case OPR_GT: 
      cmp = TI_TOP_Topcode("olt.s");
      mov = TOP_movt;
      flip = true;
      break;
    case OPR_GE: 
      cmp = TI_TOP_Topcode("ole.s");
      mov = TOP_movt;
      flip = true;
      break;
  }

  Is_True(cmp != TOP_UNDEFINED, ("Cannot find compare op for FP comparison"));
  Is_True(mov != TOP_UNDEFINED, ("Cannot find move op for FP comparison"));
  
  TN *orig_result = NULL;
  if (!result) {
    result = Build_TN_Of_Mtype(rtype);
  }
  if (TN_is_dedicated(result)) {
    orig_result = result;
    result = Build_TN_Of_Mtype(rtype);
  }

  TN* bres = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* state2 = cpenable_tn(cmp);
  if (flip) {
    if (state2)
      Build_OP(cmp, bres, r, l, state2 /* cpenable */, ops);
    else
      Build_OP(cmp, bres, r, l, ops);
  } else {
    if (state2)
      Build_OP(cmp, bres, l, r, state2 /* cpenable */, ops);
    else
      Build_OP(cmp, bres, l, r, ops);
  }
   
  TN *tmp = Generate_Constant(rtype, NULL, 1, ops);
  result = Generate_Constant(rtype, result, 0, ops);
  
  Build_OP(mov, result, result, tmp, bres, ops);

  if (orig_result) {
    result = Move_To_Register(rtype, orig_result, result, ops);
  }
  return result;
}

// FP comparison using br (boolean register) as return result
static TN *
Generate_FP_Comparison_br (OPERATOR opr, TN *result, TN *l, TN *r, OPS *ops)
{
  FmtAssert(xt_hard_float, ("Cannot do FP compares without FP hardware"));

  TOP cmp = TOP_UNDEFINED;

  switch (opr) {
    case OPR_EQ:
      cmp = TI_TOP_Topcode("oeq.s");
      break;
    case OPR_LT:
      cmp = TI_TOP_Topcode("olt.s");
      break;
    case OPR_LE:
      cmp = TI_TOP_Topcode("ole.s");
      break;
  }

  Is_True(cmp != TOP_UNDEFINED, ("Cannot find compare op for FP comparison"));

  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  } else {
    FmtAssert(TN_is_xtbool(result), ("Expected MTYPE_XTBOOL for FP compare result"));
  }

  TN* state2 = cpenable_tn(cmp);
  if (state2)
    Build_OP(cmp, result, l, r, state2 /* cpenable */, ops);
  else
    Build_OP(cmp, result, l, r, ops);

  return result;
}

static TN *
Generate_Logical_And_Conditional (WN *n, TYPE_ID desc, TOP br_top, TN *l, TN *r, OPS *ops)
{
  INT32 shift, size, imm;

  if (!TN_has_value(l) && TN_has_value(r)) {

    /* If 'r' is an immediate that can be used in a bbci/bbsi, then do
       that; otherwise we can use an extui feeding into a branch. */

    if (Get_Bbci_Bbsi_Immediate(TN_value(r), &imm))
    {
      switch (br_top)
      {
      case TOP_beq:
        br_top = TOP_bbc;
        break;
      
      case TOP_bne:
        br_top = TOP_bbs;
        break;

      default:
        FmtAssert(FALSE, ("unexpected topcode, %s\n", TI_TOP_Name(br_top)));
        break;
      }

      if (Target_Byte_Sex == BIG_ENDIAN)
        imm = 31 - imm;
    
      Generate_Branch(n, desc, br_top, Get_WN_Label(n), l, Gen_Literal_TN(imm, 4), ops);
    }
    else if (Get_Extui_Shift_Mask(TN_value(r), &shift, &size))
    {
      TN *cond = Build_TN_Of_Mtype(desc);
      Build_OP(TOP_extui, cond, l, Gen_Literal_TN(shift, 4), Gen_Literal_TN(size, 4), ops);
      Generate_Branch(n, desc, br_top, Get_WN_Label(n), cond, Gen_Literal_TN(0, 4), ops);
    }
    else
      FmtAssert(FALSE, ("unexpected immediate, %d\n", TN_value(r)));
  }

  else
  {
    /* recognize non-immediate version of bbc/bbs */
    if (br_top == TOP_beq)
      br_top = TOP_bbc;
    else if (br_top == TOP_bne)
      br_top = TOP_bbs;
    else 
      FmtAssert(FALSE, ("unexpected topcode, %s\n", TI_TOP_Name(br_top)));

    TN *mask = r;
    if (Target_Byte_Sex == BIG_ENDIAN) {
      mask = Build_TN_Of_Mtype(desc);
      Generate_Sub(desc, mask, Gen_Literal_TN(31, 4), r, ops);
    }

    Generate_Branch(n, desc, br_top, Get_WN_Label(n), l, mask, ops);
  }

  return 0;
}

static TN *
Generate_Compose(WN *n, TYPE_ID rtype, TYPE_ID desc,
		 TN *result, TN *into, TN *from, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  INT offset = WN_bit_offset(n);
  INT size = WN_bit_size(n);

//  if (Target_Byte_Sex == BIG_ENDIAN)
//    offset = MTYPE_bit_size(desc) - offset - size;

  Is_True((offset >= 0) && (size >= 0),
	  ("unexpected offset %d or size %d", offset, size));
  
  TN *insert = Build_TN_Of_Mtype(rtype);

  /* Mask and position the bits in 'from' so they are ready for
     insertion to 'into'. */
  if ((offset == 0) && (size <= 16))
  {
    Build_OP(TOP_extui, insert, from, Gen_Literal_TN(0, 4), Gen_Literal_TN(size, 4), ops);
  }
  else
  {
    UINT rsh = 32 - size - offset;
    Build_OP(TOP_slli, insert, from, Gen_Literal_TN(32 - size, 4), ops);
    Build_OP(TOP_srli, insert, insert, Gen_Literal_TN(32 - size - offset, 4), ops);
  }

  /* Mask bits out of 'into'. */
  UINT mask_val = ~(((1 << size) - 1) << offset);
  TN *mask = Generate_Constant(MTYPE_U4, NULL, mask_val, ops);

  TN *compose = Build_TN_Of_Mtype(rtype);
  Build_OP(TOP_and, compose, into, mask, ops);

  /* Insert 'insert' into 'compose'. */
  Build_OP(TOP_or, result, compose, insert, ops);

  return result;
}

static TN *
Generate_Extract (WN *n, TYPE_ID rtype, TYPE_ID desc, TN *result, TN *src, OPS *ops)
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  /* If 'desc' is smaller than 'rtype', then we must sign or zero
     extend 'src' to get it the same size as rtype. */
  FmtAssert((rtype == MTYPE_U4) || (rtype == MTYPE_I4),
	    ("expecting result MTYPE_U4 or MTYPE_I4, got %d", rtype));

  if ((desc == MTYPE_I1) || (desc == MTYPE_I2)
      || (desc == MTYPE_U1) || (desc == MTYPE_U2))
  {
    TN *tmp = Build_TN_Of_Mtype(rtype);
    src = Generate_Extend(desc, tmp, src, MTYPE_bit_size(desc), ops);
  }
  
  INT offset = WN_bit_offset(n);
  INT size = WN_bit_size(n);

//  if (Target_Byte_Sex == BIG_ENDIAN)
//    offset = MTYPE_bit_size(desc) - offset - size;

  Is_True((offset >= 0) && (size >= 0),
	  ("unexpected offset %d or size %d", offset, size));

  /* For unsigned result, we use extui when possible. */
  if (MTYPE_is_unsigned(rtype) && (size <= 16))
  {
    Build_OP(TOP_extui, result, src, Gen_Literal_TN(offset, 4), Gen_Literal_TN(size, 4), ops);
  }
  else
  {
    TN *tmp = Build_TN_Of_Mtype(rtype);
    Build_OP(TOP_slli, tmp, src, Gen_Literal_TN(32 - size - offset, 4), ops);
    Build_OP(MTYPE_is_unsigned(rtype) ? TOP_srli : TOP_srai,
	     result, tmp, Gen_Literal_TN(32 - size, 4), ops);
  }

  return result;
}


static TN *
Generate_IStoreLda_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc, TN *bits_tn, OPS *ops)
{
  WN *kid0 = WN_kid0(n);
  WN *kid1 = WN_kid1(n);

  // guard against U1MPY or U2MPY
  if (MTYPE_byte_size(rtype) < 4)
    rtype = Mtype_TransferSize(MTYPE_U4, rtype);
  if (MTYPE_byte_size(WN_rtype(kid0)) > MTYPE_byte_size(rtype)) 
    rtype = Mtype_TransferSize(WN_rtype(kid0), rtype);

  TN *field_tn = Generate_Load_Memory(n, rtype, desc, 0, WN_st(kid1), 
				      WN_store_offset(n) + WN_lda_offset(kid1), Variant_ISTORE(n), ops);
  TN *comp = Generate_Compose(n, rtype, desc, 0, field_tn, bits_tn, ops);
  Generate_Store_Memory(n, desc, comp, WN_st(kid1),
			WN_store_offset(n) + WN_lda_offset(kid1), Variant_ISTORE(n), ops);
  return comp;
}

static TN *
Generate_IStore_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc, TN *bits_tn, 
		      TN *addr_tn, OPS *ops)
{
  WN *kid0 = WN_kid0(n);
  WN *kid1 = WN_kid1(n);

  // guard against U1MPY or U2MPY
  if (MTYPE_byte_size(rtype) < 4)
    rtype = Mtype_TransferSize(MTYPE_U4, rtype);
  if (MTYPE_byte_size(WN_rtype(kid0)) > MTYPE_byte_size(rtype)) 
    rtype = Mtype_TransferSize(WN_rtype(kid0), rtype);

  TN *field_tn = Generate_Load_Memory(n, rtype, desc, 0,
				      addr_tn, WN_store_offset(n), Variant_ISTORE(n), ops);
  TN *comp = Generate_Compose(n, rtype, desc, 0, field_tn, bits_tn, ops);
  Generate_Store_Memory(n, desc, comp, addr_tn, WN_store_offset(n), Variant_ISTORE(n), ops);
  return comp;
}


static TN *
Generate_ILoadLda_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc,
			TN *result, OPS *ops)
{
  WN *kid0 = WN_kid0(n);

  if (!result)
    result = Build_TN_Of_Mtype(rtype);

  TN *src_tn = Generate_Load_Memory(n, rtype, desc, 0, WN_st(kid0),
				    WN_offset(n) + WN_lda_offset(kid0),
				    Variant_ILOAD(n), ops);
  return Generate_Extract(n, rtype, desc, result, src_tn, ops);
}

static TN *
Generate_ILoad_Bits (WN *n, TYPE_ID rtype, TYPE_ID desc,
		     TN *result, TN *addr_tn, OPS *ops)
{
  TN *src_tn = Generate_Load_Memory(n, rtype, desc, 0,
				    addr_tn, WN_offset(n), Variant_ILOAD(n), ops);
  return Generate_Extract(n, rtype, desc, result, src_tn, ops);
}

static TN *
Generate_Alloca (TYPE_ID rtype, TN *result, TN *adjust, OPS *ops)
{
  /* We adjust the stack by the size indicated in 'adjust', plus size
     needed for any outgoing arguments, plus any padding necessary to
     reach Stack_Alignment. Both the space allocated for the object,
     and the new SP are aligned to Stack_Alignment. */
  
  /* Align 'adjust' up to the stack alignment. */
  if (TN_has_value(adjust))
  {
    INT64 size; 
    size = TN_value(adjust);
    size += Stack_Alignment() - 1;
    size &= -Stack_Alignment();
    adjust = Gen_Literal_TN(size, Pointer_Size);
  }
  else
  {
    TN *c0 = Generate_Constant(MTYPE_I4, NULL, Stack_Alignment()-1, ops);
    TN *tn1 = Generate_Binary(TN_mtype(adjust), TOP_add, NULL,
			      adjust, c0, ops);
    TN *c1 = Generate_Constant(MTYPE_I4, NULL, -Stack_Alignment(), ops);
    adjust = Generate_Binary(TN_mtype(adjust), TOP_and, NULL,
			     tn1, c1, ops);
  }

  result = Generate_Sub(rtype, result, SP_TN, adjust, ops);

  /* We only need to move the sp if 'adjust' is non-zero. */

  if (!TN_has_value(adjust) || (TN_value(adjust) != 0))
  {
    /* If we have actuals, we must make space for them below the
       alloca space. We align the needed actual space to
       Stack_Alignment. */
    TN *actuals = result;
    if (Current_PU_Actual_Size)
    {
      INT64 size = Current_PU_Actual_Size;
      size += Stack_Alignment() - 1;
      size &= -Stack_Alignment();
      actuals = Generate_Sub(rtype, NULL, result, Gen_Literal_TN(size, Pointer_Size), ops);
    }
    
    /* call0: this seems inefficient, but the optimizer will fix it if it can */
    if (Target_ABI == ABI_WINDOWED)
      Generate_Unary(rtype, TOP_movsp, SP_TN, actuals, ops);
    else
      Generate_Unary(rtype, TOP_mov_n, SP_TN, actuals, ops);
  }

  return result;
}

static void
Generate_Dealloca (TYPE_ID rtype, TN *newsp, OPS *ops)
{
    /* call0: this seems inefficient, but the optimizer will fix it if it can */
  if (Target_ABI == ABI_WINDOWED)
    Generate_Unary(rtype, TOP_movsp, SP_TN, newsp, ops);
  else
    Generate_Unary(rtype, TOP_mov_n, SP_TN, newsp, ops);
}

static TN *
Generate_MINMAX (TYPE_ID mtype, TOP orig_op, OPERATOR cond_op,
		 TN *result, TN *left, TN *right, OPS *ops)
{
  if( xt_minmax ) {
    return Generate_Binary(mtype, orig_op, result,
			   left, right, ops );
  }
  else {
    return Generate_Conditional_Select(mtype, mtype, cond_op, result, 
				       left, right, left, right, ops);
  }

  return result;
}

static TN *
Generate_Clamps (TYPE_ID rtype, TN *result, TN *src, TN *imm, OPS *ops)
{
  Is_True(TN_is_register(src) && TN_has_value(imm), (""));
  FmtAssert(TARG_INT_Pop_Count(TN_value(imm) + 1) == 1, ("expecting power of 2"));

  /* 'imm' is the positive clamp immediate, e.g. 255, 511, ... */
  INT64 imm2 = TARG_INT_Least_Sig_One(TN_value(imm) + 1);
  return Generate_Binary(rtype, TOP_clamps, result,
			 src, Gen_Literal_TN(imm2, 4), ops);
}


// the following implements a simple mapping between a pair of reg TNs
// the map needs to be reset at the end of usage

static TN* reg1=NULL;
static TN* reg2=NULL;
static TN* get_reg_tn_pair(TN* in_tn) {
  TN* result=NULL;
  if (reg1==in_tn) result=reg2;
  else if (reg2==in_tn) result=reg1;
  else Is_True(FALSE,("Missing reg pair"));

  reg1=reg2=NULL;

  return result;
}
static void set_reg_tn_pair(TN* tn1, TN* tn2) {
  //Is_True(reg1==NULL && reg2==NULL, ("Bad reg pair"));
  Is_True(TN_is_register(tn1) && TN_is_register(tn2), ("Bad reg pair"));
  reg1 = tn1; reg2 = tn2;
}


%}
%start stmt;
%declare<TN *> expr<TN *result,OPS *ops>;
%declare<TN *> areg<TN *result,OPS *ops>;
%declare<TN *> breg<TN *result,OPS *ops>;
%declare<TN *> bareg<TN *result,OPS *ops>;
%declare<TN *> b1reg<TN *result,OPS *ops>;
%declare<TN *> freg<TN *result,OPS *ops>;
%declare<TN *> tie_reg<TN *result,OPS *ops>;
%declare<TN *> tie_cvt_reg<TN *result,OPS *ops>;
%declare<TN *> ll_cvt_areg<TN *result,OPS *ops>;
%declare<void> acc_reg<TN *result,OPS *ops>;
%declare<TN *> tie_imm<>;
%declare<TN *> wsar<OPS *ops>;
%declare<TN *> sar_left<OPS *ops>;
%declare<TN *> sar_right<OPS *ops>;
%declare<TN *> areg_or_simm12<TN *result,OPS *ops>;
%declare<TN *> areg_or_simm8<TN *result,OPS *ops>;
%declare<TN *> areg_or_b4const<TN *result,OPS *ops>;
%declare<TN *> areg_or_b4constu<TN *result,OPS *ops>;
%declare<TN *> extui_mask<>;
%declare<TN *> bbci_bbsi_imm<>;
%declare<TN *> logical_and_immed<TN *result,OPS *ops>;
%declare<TN *> clamps_const<>;
%declare<TN *> simm8x256<>;
//%declare<TN *> simm4<>;
//%declare<TN *> simm7<>;
%declare<TN *> simm8<>;
%declare<TN *> simm12<>;
//%declare<TN *> simm16<>;
%declare<TN *> simm32<>;
//%declare<TN *> uimm12x8<>;
//%declare<TN *> uimm16x4<>;
%declare<TN *> uimm4<>;
%declare<TN *> uimm5<>;
//%declare<TN *> uimm8<>;
//%declare<TN *> uimm8x2<>;
//%declare<TN *> uimm8x4<>;
//%declare<TN *> ai4const<>;
%declare<TN *> b4constu<>;
%declare<TN *> b4const<>;
//%declare<TN *> lsi4x4<>;
//%declare<TN *> op2p1<>;
//%declare<TN *> tp7<>;
%declare<TN *> msalp32<>;
%declare<void> zero<>;
%declare<void> one<>;
%declare<void> thirtytwo<>;
%declare<INT32> float_const<>;
//%declare<TN *> double_const<>;
%declare<TN *> stmt<TN *result,OPS *ops>;
%%

//=============================================================================
//
// Misc Statements
//
//=============================================================================

stmt: expr ?
{ $cost[0].cost = $cost[1].cost; }
{ return $action[1](result,ops); };

stmt: OPC_EVAL(expr) ?
{ $cost[0].cost = $cost[2].cost; }
{ return $action[2](result,ops); };


//=============================================================================
//
// Asm
//
//=============================================================================

stmt: OPC_ASM_STMT ?
{ return Label_Asm($0, &($cost[0])); }
{ Handle_ASM($0, asm_action_callback); return 0; };


//=============================================================================
//
// Alloca
//
//=============================================================================

areg: OPC_U4ALLOCA (areg_or_simm8) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Alloca(MTYPE_U4, result, $action[2](0, ops), ops);
};

stmt: OPC_DEALLOCA (areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True(!result, ("result not expected for OPR_DEALLOCA\n"));
  Generate_Dealloca(MTYPE_U4, $action[2](0, ops), ops);
  return 0;
};
 

//=============================================================================
//
// Barrier
//
//=============================================================================

stmt: OPC_FORWARD_BARRIER ?
{ Build_OP( WN_Barrier_No_Reorder($1)? TOP_extw_pseudo :
	    WN_Barrier_No_Reorder_Memory($1)? TOP_memw_pseudo :
	    WN_Barrier_Flush_Memory($1)? TOP_memw :
		earliest_arch==Barcelona_Xtensa ?	/* FLUSH */
		TOP_extw : TOP_memw,
	    ops ); return 0; };

stmt: OPC_BACKWARD_BARRIER ?
{ Build_OP( WN_Barrier_No_Reorder($1)? TOP_extw_pseudo :
	    WN_Barrier_No_Reorder_Memory($1)? TOP_memw_pseudo :
	    WN_Barrier_Flush_Memory($1)? TOP_memw :
		earliest_arch==Barcelona_Xtensa ?	/* FLUSH */
		TOP_extw : TOP_memw,
	    ops ); return 0; };

//=============================================================================
//
// Calls
//
//=============================================================================


stmt: OPC_VINTRINSIC_CALL && is_tie_intrinsic_call ?
{ 

  COST intr_cost, c;
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic($1));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count($1);
  intr_cost.cost=tie_macro->num_instructions();
  FmtAssert(kid_count==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));

#if 0
printf("isel tie intr call label: %s\n", tie_macro->name());
#endif
  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid($1,i));

    if (tie_macro->proto_is_immed(i) &&
	ISEL::match(kid, ISEL::find_nonterm("tie_imm"), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else if (ISEL::match(kid, ISEL::find_nonterm(
		find_nonterm_name(tie_macro->proto_mtype_id(tie_info,i))), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else {
      $cost[0] = COST_INFINITY;
      return false;
    }
  }

  $cost[0] = intr_cost;
  return true;
}

{ TN* in_operands[128];
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic($1));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count($1);
#if 0
printf("isel tie intr call action: %s\n", tie_macro->name());
#endif

  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid($1,i));
    if (tie_macro->proto_is_out(i) &&
	WN_operator(kid)==OPR_LDID &&
	ST_class(WN_st(kid))==CLASS_PREG)
      in_operands[i]=PREG_To_TN(WN_st(kid),WN_offset(kid));
    else {
      if (tie_macro->proto_is_immed(i))
	in_operands[i]=action_by_type(kid, "immediate", 0, ops);
      else
	in_operands[i]=action_by_type(kid,tie_macro->proto_mtype_id(tie_info,i),0,ops);
    }
  }

  Set_Last_Mem_OP( ops );
  expand_tie_macro_to_ops(ops, Intrinsic_To_Tie_Macro_Id(WN_intrinsic($1)), in_operands);
  Set_OP_To_WN_Map($1);

  return 0;
};

stmt: OPC_I4INTRINSIC_CALL && is_tie_intrinsic_call ?
{ 

  COST intr_cost, c;
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic($1));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);

  if (tie_macro->is_conditional_branch()==FALSE) {
    $cost[0] = COST_INFINITY;
    return false;
  }

  UINT kid_count = WN_kid_count($1);
  intr_cost.cost=tie_macro->num_instructions();
  FmtAssert(kid_count==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));

  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid($1,i));

    if (tie_macro->proto_is_label(i)) {
      if (WN_opcode(kid)!=OPC_I4INTCONST) {
	$cost[0] = COST_INFINITY;
	return false;
      }
    } else if (tie_macro->proto_is_immed(i) &&
	       ISEL::match(kid, ISEL::find_nonterm("tie_imm"), c)) {
      intr_cost.cost = intr_cost.cost + c.cost;
    } else if (ISEL::match(kid, ISEL::find_nonterm(
		find_nonterm_name(tie_macro->proto_mtype_id(tie_info,i))), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else {
      $cost[0] = COST_INFINITY;
      return false;
    }

  }

  $cost[0] = intr_cost;
  return true;
}

{ TN* in_operands[128];
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic($1));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count($1);
#if 0
printf("isel tie intr call action: %s\n", tie_macro->name());
#endif

  for (int i=0; i<kid_count; i++) {
    WN* kid = WN_kid0(WN_kid($1,i));
    if (tie_macro->proto_is_label(i)) {
      in_operands[i]= Gen_Label_TN(WN_const_val(kid),0);
    } else if (tie_macro->proto_is_out(i) &&
	WN_operator(kid)==OPR_LDID &&
	ST_class(WN_st(kid))==CLASS_PREG)
      in_operands[i]=PREG_To_TN(WN_st(kid),WN_offset(kid));
    else {
      if (tie_macro->proto_is_immed(i))
	in_operands[i]=action_by_type(kid, "immediate", 0, ops);
      else
	in_operands[i]=action_by_type(kid,tie_macro->proto_mtype_id(tie_info,i),0,ops);
    }
  }

  Set_Last_Mem_OP( ops );
  expand_tie_macro_to_ops(ops, Intrinsic_To_Tie_Macro_Id(WN_intrinsic($1)), in_operands);
  Set_OP_To_WN_Map($1);

  End_Basic_Block($0);

  return 0;
};

stmt: OPC_VCALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_I1CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_U1CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_I2CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_U2CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_I4CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_F4CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_U4CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_F8CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_I8CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_U8CALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };

stmt: OPC_MCALL ?
{ $cost[0].cost = 1; }
{ Generate_Call( $0, ABI_CALL, ops); return 0; };


//=============================================================================
//
// Indirect Calls
//
//=============================================================================

stmt: OPC_VICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_I1ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_U1ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_I2ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_U2ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_I4ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_F4ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_U4ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_F8ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_I8ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_U8ICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };

stmt: OPC_MICALL ?
{ return Label_ICall($0, &($cost[0])); }
{ Generate_ICall( $0, ABI_ICALL, ops); return 0; };


//=============================================================================
//
// Unconditional Branches
//
//=============================================================================

stmt: OPC_REGION_EXIT ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from region exit"));
  Build_OP( TOP_j, Gen_Label_TN(Get_WN_Label($0),0), ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_GOTO ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from goto"));
  Build_OP( TOP_j, Gen_Label_TN(Get_WN_Label($0),0), ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_XGOTO( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  if (ST_is_switchjump(WN_st($0))) { 
    FmtAssert( result==0, ("Requesting result from xgoto"));
    FmtAssert( !Gen_PIC_Shared, ("-mswitchjump not supported with PIC code"));
    Build_OP( TOP_jx, $action[2](0, ops), ops );
    Handle_XGOTO_Extras($0);
    End_Basic_Block($0);
    return 0;
  } else {
    Is_True( result==0, ("Requesting result from xgoto"));
    Build_OP( TOP_jx, $action[2](0, ops), ops );
    Handle_XGOTO_Extras($0);
    End_Basic_Block($0);
    return 0;
  }
};


stmt: OPC_AGOTO( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from agoto"));
  Build_OP( TOP_jx, $action[2](0, ops), ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( one ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Build_OP( TOP_j, Gen_Label_TN(Get_WN_Label($0),0), ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( areg )?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Build_OP( TOP_bnez, $action[2](0,ops), Gen_Label_TN(Get_WN_Label($0),0), ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( areg )?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Build_OP( TOP_beqz, $action[2](0,ops), Gen_Label_TN(Get_WN_Label($0),0), ops );
  End_Basic_Block($0);
  return 0;
};

//=============================================================================
//
// Xtbool Branches
//
//=============================================================================

stmt: OPC_TRUEBR( b1reg )?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[2](0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4F4NE(freg, freg) ) && hw_fp ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 2; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * r = $action[4](0,ops);
  TN * l = $action[3](0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4F4NE(freg, freg) ) && hw_fp ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 2; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * r = $action[4](0,ops);
  TN * l = $action[3](0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4XTBOOLCVT( b1reg ) )?
{ $cost[0].cost = $cost[3].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[3](0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4XTBOOLCVT( OPC_XTBOOLBNOT(b1reg) ) )?
{ $cost[0].cost = $cost[4].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[4](0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( b1reg )?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[2](0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4F4NE(freg, freg) ) && hw_fp ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 2; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * r = $action[4](0,ops);
  TN * l = $action[3](0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4F4NE(freg, freg) ) && hw_fp ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 2; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * r = $action[4](0,ops);
  TN * l = $action[3](0,ops);
  TN * tn1 = Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4XTBOOLCVT( b1reg ) )?
{ $cost[0].cost = $cost[3].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[3](0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4XTBOOLCVT( OPC_XTBOOLBNOT(b1reg) ) )?
{ $cost[0].cost = $cost[4].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[4](0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};


//=============================================================================
//
// Unsigned Branches
//
//=============================================================================

// signed result

stmt: OPC_TRUEBR( OPC_I4U4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4GT( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4GE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4LT( areg_or_b4constu, areg_or_b4constu )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4XTBOOLCVT( b1reg ) )?
{ $cost[0].cost = $cost[3].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[3](0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_TRUEBR( OPC_XTBOOLBNOT(b1reg) )?
{ $cost[0].cost = $cost[3].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[3](0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( b1reg )?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[2](0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4XTBOOLCVT( b1reg ) )?
{ $cost[0].cost = $cost[3].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[3](0,ops);
  Build_OP( TOP_bf, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};

stmt: OPC_FALSEBR( OPC_XTBOOLBNOT(b1reg) )?
{ $cost[0].cost = $cost[3].cost + 1; }
{
  TN * tn2 = Gen_Label_TN(Get_WN_Label($0),0);
  TN * tn1 = $action[3](0,ops);
  Build_OP( TOP_bt, tn1, tn2, ops );
  End_Basic_Block($0);
  return 0;
};


//=============================================================================
//
// Unsigned Branches
//
//=============================================================================

// signed result

stmt: OPC_TRUEBR( OPC_I4U4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4GT( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4GE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4LT( areg_or_b4constu, areg_or_b4constu )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4U4LE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4U4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4U4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4U4GT( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4U4GE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);;
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4U4LT( areg_or_b4constu, areg_or_b4constu )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);;
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4U4LE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);;
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

// unsigned result

stmt: OPC_TRUEBR( OPC_U4U4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);;
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4U4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4U4GT( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);;
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4U4GE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4U4LT( areg_or_b4constu, areg_or_b4constu )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4U4LE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4U4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4U4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4U4GT( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4U4GE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4U4LT( areg_or_b4constu, areg_or_b4constu )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bgeu, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4U4LE( areg_or_b4constu, areg_or_b4constu) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_U4, TOP_bltu, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

//=============================================================================
//
// Signed Branches
//
//=============================================================================

// signed result

stmt: OPC_TRUEBR( OPC_I4I4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4I4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4I4GT( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4I4GE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4I4LT( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_I4I4LE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4I4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4I4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4I4GT( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4I4GE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4I4LT( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_I4I4LE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

// unsigned result

stmt: OPC_TRUEBR( OPC_U4I4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4I4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4I4GT( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4I4GE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4I4LT( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_TRUEBR( OPC_U4I4LE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4I4EQ( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bne, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4I4NE( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_beq, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4I4GT( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4I4GE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4I4LT( areg_or_b4const, areg_or_b4const )) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_bge, Get_WN_Label($0), tn3, tn4, ops );
  return 0;
};

stmt: OPC_FALSEBR( OPC_U4I4LE( areg_or_b4const, areg_or_b4const) ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{
  Is_True( result==0, ("Requesting result from branch"));
  TN * tn3 = $action[3](0,ops);
  TN * tn4 = $action[4](0,ops);
  Generate_Branch( $0, MTYPE_I4, TOP_blt, Get_WN_Label($0), tn4, tn3, ops );
  return 0;
};


//=============================================================================
//
// Special Branches
//
//=============================================================================

// if a BAND feeds into an EQZ or NEZ, then we can use extui more
// freely since we don't care about the position of the bits, just
// whether they are non-zero or not

// ne

stmt: OPC_FALSEBR (OPC_I4I4NE (OPC_I4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4I4NE (OPC_I4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_I4I4NE (zero, OPC_I4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_I4I4NE (zero, OPC_I4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4I4NE (zero, OPC_I4BAND (areg, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 1; }
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn6, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_I4I4NE (OPC_I4BAND (areg, areg), zero)) ?
{ $cost[0].cost = $cost[5].cost + $cost[4].cost + 1; }
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn4, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_I4U4NE (OPC_U4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4U4NE (OPC_U4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_I4U4NE (zero, OPC_U4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_I4U4NE (zero, OPC_U4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4U4NE (zero, OPC_U4BAND (areg, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 1; }
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn6, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_I4U4NE (OPC_U4BAND (areg, areg), zero)) ?
{ $cost[0].cost = $cost[5].cost + $cost[4].cost + 1; }
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn4, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_U4I4NE (OPC_I4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4I4NE (OPC_I4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_U4I4NE (zero, OPC_I4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_U4I4NE (zero, OPC_I4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_beq, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4I4NE (zero, OPC_I4BAND (areg, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 1; }
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn6, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_U4I4NE (OPC_I4BAND (areg, areg), zero)) ?
{ $cost[0].cost = $cost[5].cost + $cost[4].cost + 1; }
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn4, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_U4U4NE (OPC_U4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4U4NE (OPC_U4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_U4U4NE (zero, OPC_U4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_U4U4NE (zero, OPC_U4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_beq, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4U4NE (zero, OPC_U4BAND (areg, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 1; }
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn6, ops);
  return 0; };

stmt: OPC_FALSEBR (OPC_U4U4NE (OPC_U4BAND (areg, areg), zero)) ?
{ $cost[0].cost = $cost[5].cost + $cost[4].cost + 1; }
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  Generate_Branch($0, MTYPE_I4, TOP_bnone, Get_WN_Label($0), tn5, tn4, ops);
  return 0; };

// eq

stmt: OPC_FALSEBR (OPC_I4I4EQ (OPC_I4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4I4EQ (OPC_I4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_I4I4EQ (zero, OPC_I4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_I4I4EQ (zero, OPC_I4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4U4EQ (OPC_U4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_I4U4EQ (OPC_U4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_I4U4EQ (zero, OPC_U4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_I4U4EQ (zero, OPC_U4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4I4EQ (OPC_I4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4I4EQ (OPC_I4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_U4I4EQ (zero, OPC_I4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_U4I4EQ (zero, OPC_I4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_I4, TOP_bne, tn6, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4U4EQ (OPC_U4BAND (areg, logical_and_immed), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn4, tn5, ops); };

stmt: OPC_FALSEBR (OPC_U4U4EQ (OPC_U4BAND (logical_and_immed, areg), zero)) ?
{ $cost[0].cost = $cost[4].cost + $cost[5].cost + 2;
  COST c;
  if (ISEL::match($4, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn4 = $action[4](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn5, tn4, ops); };

stmt: OPC_FALSEBR (OPC_U4U4EQ (zero, OPC_U4BAND (areg, logical_and_immed))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($6, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn5, tn6, ops); };

stmt: OPC_FALSEBR (OPC_U4U4EQ (zero, OPC_U4BAND (logical_and_immed, areg))) ?
{ $cost[0].cost = $cost[5].cost + $cost[6].cost + 2;
  COST c;
  if (ISEL::match($5, ISEL::find_nonterm("bbci_bbsi_imm"), c)) { $cost[0].cost--; }
}
{ 
  TN * tn5 = $action[5](0,ops);
  TN * tn6 = $action[6](0,ops);
  return Generate_Logical_And_Conditional($0, MTYPE_U4, TOP_bne, tn6, tn5, ops); };


//=============================================================================
//
// Signed Relational operator, evaluate for value not for branch condition.
//
//=============================================================================

// signed result

areg: OPC_I4I4LT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
    return Generate_Comparison(OPR_LT, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4I4GT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4I4NE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4I4EQ(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4I4GE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4I4LE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_I4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

// unsigned result

areg: OPC_U4I4LT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LT, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4I4GT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4I4NE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4I4EQ(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4I4GE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4I4LE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_U4, MTYPE_I4,
			     result, tn2, tn3, ops);
};


//=============================================================================
//
// Unsigned Relational operator, evaluate for value not for branch condition.
//
//=============================================================================

// signed result

areg: OPC_I4U4LT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LT, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4U4GT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4U4NE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4U4EQ(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4U4GE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_I4U4LE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_I4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

// unsigned result

areg: OPC_U4U4LT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LT, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4U4GT( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GT, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4U4NE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_NE, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4U4EQ(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_EQ, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4U4GE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_GE, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);
};

areg: OPC_U4U4LE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Comparison(OPR_LE, MTYPE_U4, MTYPE_U4,
			     result, tn2, tn3, ops);
};


//==========================================================================
//
// Special Relational operators that can be simplified
//
//==========================================================================

// PR 3950: 
// a = (BOOL)(b & (1 << c))
// ------------------------
// extui a, b, c, 1

areg: OPC_I4I4NE (OPC_I4BAND (areg, bbci_bbsi_imm), zero) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{ 
  INT32 bit_pos;
  TN * power_of_2 = $action[4]();
  TN * src = $action[3](0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_I4);
  if (Get_Bbci_Bbsi_Immediate(TN_value(power_of_2), &bit_pos))
    Build_OP(TOP_extui, result, src, 
             Gen_Literal_TN(bit_pos, 4), Gen_Literal_TN(1, 4), ops);
  else 
    Fail_FmtAssertion("Expected a power of 2 (1..1<<31)");
  return result;
};

areg: OPC_I4U4NE (OPC_U4BAND (areg, bbci_bbsi_imm), zero) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + 1; }
{ 
  INT32 bit_pos;
  TN * power_of_2 = $action[4]();
  TN * src = $action[3](0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_I4);
  if (Get_Bbci_Bbsi_Immediate(TN_value(power_of_2), &bit_pos))
    Build_OP(TOP_extui, result, src, 
             Gen_Literal_TN(bit_pos, 4), Gen_Literal_TN(1, 4), ops);
  else 
    Fail_FmtAssertion("Expected a power of 2 (1..1<<31)");
  return result;
};


//==========================================================================
//
// Rules for Select
//
//==========================================================================

// register condition

areg: OPC_I4SELECT( areg, areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movnez, result, tn2, tn3, tn4, ops);
};

areg: OPC_U4SELECT( areg, areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Cmov(MTYPE_U4, TOP_movnez, result, tn2, tn3, tn4, ops);
};

areg: OPC_F4SELECT( areg, areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movnez, result, tn2, tn3, tn4, ops);
};

freg: OPC_F4SELECT( areg, freg, freg ) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  TOP cmov = TI_TOP_Topcode("movnez.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, tn2, tn3, tn4, ops);
};

// signed conditional selects w/ signed comparison

areg: OPC_I4SELECT( OPC_I4U4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4U4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4U4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4U4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4U4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4U4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4I4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4I4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4I4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4I4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4I4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_I4I4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

// signed conditional selects w/ unsigned comparison

areg: OPC_I4SELECT( OPC_U4U4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4U4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4U4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4U4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4U4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4U4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4I4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4I4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4I4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4I4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4I4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_I4SELECT( OPC_U4I4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

// unsigned conditional selects w/ unsigned comparison

areg: OPC_U4SELECT( OPC_U4U4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4U4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4U4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4U4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4U4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4U4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4I4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4I4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4I4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4I4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4I4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_U4I4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

// unsigned conditional selects w/ signed comparison

areg: OPC_U4SELECT( OPC_I4U4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4U4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4U4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4U4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4U4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4U4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4I4EQ(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4I4NE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4I4GT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4I4GE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4I4LT(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};

areg: OPC_U4SELECT( OPC_I4I4LE(areg_or_simm8, areg_or_simm8), areg_or_simm12, areg_or_simm12 ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost +
    $cost[5].cost + $cost[6].cost + 1; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Conditional_Select(WN_rtype($2), WN_desc($2), WN_operator($2),
				     result,
				     tn3, tn4, tn5, tn6, 
				     ops);
};


//==========================================================================
//
// Rules for xtbool conditional move
//
//==========================================================================

// register condition

areg: OPC_I4SELECT( b1reg, areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movt, result, tn2, tn3, tn4, ops);
};

areg: OPC_U4SELECT( b1reg, areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Cmov(MTYPE_U4, TOP_movt, result, tn2, tn3, tn4, ops);
};

areg: OPC_F4SELECT( b1reg, areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movt, result, tn2, tn3, tn4, ops);
};

freg: OPC_F4SELECT( b1reg, freg, freg ) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  TOP cmov = TI_TOP_Topcode("movt.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, tn2, tn3, tn4, ops);
};

areg: OPC_I4SELECT( OPC_XTBOOLBNOT(b1reg), areg, areg ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1; }
{
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movf, result, tn3, tn4, tn5, ops);
};

areg: OPC_U4SELECT( OPC_XTBOOLBNOT(b1reg), areg, areg ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1; }
{
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Cmov(MTYPE_U4, TOP_movf, result, tn3, tn4, tn5, ops);
};

areg: OPC_F4SELECT( OPC_XTBOOLBNOT(b1reg), areg, areg ) ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1; }
{
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  return Generate_Cmov(MTYPE_I4, TOP_movf, result, tn3, tn4, tn5, ops);
};

freg: OPC_F4SELECT( OPC_XTBOOLBNOT(b1reg), freg, freg ) && hw_fp ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1; }
{
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TOP cmov = TI_TOP_Topcode("movf.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, tn3, tn4, tn5, ops);
};

freg: OPC_F4SELECT( OPC_I4F4NE(freg, freg), freg, freg ) && hw_fp ?
{ $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + $cost[6].cost + 2; }
{
  TN * tn6 = $action[6](0,ops);
  TN * tn5 = $action[5](0,ops);
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  
  TN *boolean_cond = Generate_FP_Comparison_br(OPR_EQ, 0, tn3, tn4, ops);
  TOP cmov = TI_TOP_Topcode("movf.s");
  return Generate_Cmov(MTYPE_F4, cmov, result, boolean_cond, tn5, tn6, ops);
};

breg: OPC_XTBOOLSELECT( areg, breg, breg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 3; }
{
  FmtAssert(WN_rtype(WN_kid($0,1))==MTYPE_XTBOOL, ("Expecting xtbool type"));
  FmtAssert(WN_rtype(WN_kid($0,2))==MTYPE_XTBOOL, ("Expecting xtbool type"));
  TYPE_ID rtype = MTYPE_XTBOOL;
  TYPE_ID desc = WN_desc(WN_kid0($0));
  TN * tn_false = $action[4](0,ops);
  TN * tn_true = $action[3](0,ops);
  TN * l = $action[2](0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};

breg: OPC_XTBOOL2SELECT( areg, breg, breg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 3; }
{
  FmtAssert(WN_rtype(WN_kid($0,1))==MTYPE_XTBOOL2, ("Expecting xtbool2 type"));
  FmtAssert(WN_rtype(WN_kid($0,2))==MTYPE_XTBOOL2, ("Expecting xtbool2 type"));
  TYPE_ID rtype = MTYPE_XTBOOL2;
  TYPE_ID desc = WN_desc(WN_kid0($0));
  TN * tn_false = $action[4](0,ops);
  TN * tn_true = $action[3](0,ops);
  TN * l = $action[2](0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};

breg: OPC_XTBOOL4SELECT( areg, breg, breg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 3; }
{
  FmtAssert(WN_rtype(WN_kid($0,1))==MTYPE_XTBOOL4, ("Expecting xtbool4 type"));
  FmtAssert(WN_rtype(WN_kid($0,2))==MTYPE_XTBOOL4, ("Expecting xtbool4 type"));
  TYPE_ID rtype = MTYPE_XTBOOL4;
  TYPE_ID desc = WN_desc(WN_kid0($0));
  TN * tn_false = $action[4](0,ops);
  TN * tn_true = $action[3](0,ops);
  TN * l = $action[2](0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};

breg: OPC_XTBOOL8SELECT( areg, breg, breg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 3; }
{
  FmtAssert(WN_rtype(WN_kid($0,1))==MTYPE_XTBOOL8, ("Expecting xtbool8 type"));
  FmtAssert(WN_rtype(WN_kid($0,2))==MTYPE_XTBOOL8, ("Expecting xtbool8 type"));
  TYPE_ID rtype = MTYPE_XTBOOL8;
  TYPE_ID desc = WN_desc(WN_kid0($0));
  TN * tn_false = $action[4](0,ops);
  TN * tn_true = $action[3](0,ops);
  TN * l = $action[2](0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};

breg: OPC_XTBOOL16SELECT( areg, breg, breg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 3; }
{
  FmtAssert(WN_rtype(WN_kid($0,1))==MTYPE_XTBOOL16, ("Expecting xtbool16 type"));
  FmtAssert(WN_rtype(WN_kid($0,2))==MTYPE_XTBOOL16, ("Expecting xtbool16 type"));
  TYPE_ID rtype = MTYPE_XTBOOL16;
  TYPE_ID desc = WN_desc(WN_kid0($0));
  TN * tn_false = $action[4](0,ops);
  TN * tn_true = $action[3](0,ops);
  TN * l = $action[2](0,ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};


//==========================================================================
//
// Rules for Handling memory stores
//
//==========================================================================

expr: OPC_I4STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_I4, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_U4STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U4, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_F4STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory($0, MTYPE_I4, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_F4STID(freg) && !is_preg && hw_fp ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory($0, MTYPE_F4, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_I2STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_I2, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_U2STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U2, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_I1STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_I1, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_U1STID(areg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U1, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};


//==========================================================================
//
// Rules for stores into registers.
//
//==========================================================================


expr: OPC_I4STID(areg) && is_preg ?
{ $cost[0].cost = $cost[2].cost; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return $action[2](dst,ops);
};

expr: OPC_U4STID(areg) && is_preg ?
{ $cost[0].cost = $cost[2].cost; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return $action[2](dst,ops);
};

//
// This loads a 16-bit signed value into a areg.  We are assuming that
// if we are loading into a register that the tree below us
// will take care of any necessary sign extension.
//
expr: OPC_I2STID(areg) && is_preg ?
{ $cost[0].cost = $cost[2].cost; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return $action[2](dst,ops);
};

//
// This loads a 16-bit unsigned value into a areg.  We are assuming that
// if we are loading into a register that the tree below us
// will take care of any necessary clearing of more significant bits.
//
expr: OPC_U2STID(areg) && is_preg ?
{ $cost[0].cost = $cost[2].cost; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return $action[2](dst,ops);
};

expr: OPC_I1STID(areg) && is_preg ?
{ $cost[0].cost = $cost[2].cost; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return $action[2](dst,ops);
};

expr: OPC_U1STID(areg) && is_preg ?
{ $cost[0].cost = $cost[2].cost; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  return $action[2](dst,ops);
};

// AR <- AR
expr: OPC_F4STID(areg) && is_preg && !is_float_tn ?
{ $cost[0].cost = $cost[2].cost; }
{
  Is_True( result==0, ("Requesting result from store"));
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = float_preg_to_int_tn(s, o);      
  return $action[2](dst,ops);
};

// FR <- FR
expr: OPC_F4STID(freg) && is_preg && is_float_tn ?
{ $cost[0].cost = $cost[2].cost; }
{
  Is_True( result==0, ("Requesting result from store"));
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s, o);
  return $action[2](dst,ops);
};

expr: OPC_U4ISTORE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U4, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_U2ISTORE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U2, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_U1ISTORE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U1, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_I4ISTORE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_I4, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_I2ISTORE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_I2, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_I1ISTORE(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_I1, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_F4ISTORE(areg, areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_I4, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_F4ISTORE(freg, areg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_F4, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: areg ?
{ $cost[0].cost = $cost[1].cost; }
{ 
  return $action[1](result, ops);
};
	
expr: tie_reg ?
{ $cost[0].cost = $cost[1].cost; }
{ 
  return $action[1](result, ops);
};
	
expr: tie_cvt_reg ?
{ $cost[0] = COST_INFINITY; }
{ 
  FmtAssert(0,("Should never reach here"));
  return 0;
};

expr: ll_cvt_areg ?
{ $cost[0] = COST_INFINITY; }
{ 
  FmtAssert(0,("Should never reach here"));
  return 0;
};

expr: breg ?
{ $cost[0].cost = $cost[1].cost; }
{ 
  return $action[1](result, ops);
};
	
expr: freg ?
{ $cost[0].cost = $cost[1].cost; }
{ 
  return $action[1](result, ops);
};
	
//=============================================================================
//
// Rules for loading
//
//=============================================================================

areg: OPC_I4I4LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
};

areg: OPC_I4I2LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
};

areg: OPC_I4I1LDID && is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
};


areg: OPC_U4U4LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
};

areg: OPC_U4U2LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
};

areg: OPC_U4U1LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
};

areg: OPC_F4F4LDID && is_preg && !is_float_tn ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  TN *val = float_preg_to_int_tn(s, o);      
  return Move_To_Register(MTYPE_I4, result, val, ops);
};

freg: OPC_F4F4LDID && is_preg && is_float_tn ?
{ $cost[0].cost = 1; }
{
  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  TN *val = PREG_To_TN(s, o);
  return Move_To_Register(MTYPE_F4, result, val, ops);
};

areg: OPC_I4I4LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

areg: OPC_I4I2LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I2, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

areg: OPC_I4I1LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I1, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

areg: OPC_U4U4LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

areg: OPC_U4U2LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

areg: OPC_U4U1LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

// Load a floating point number into an areg.
areg: OPC_F4F4LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_I4);
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, mtype, mtype, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

freg: OPC_F4F4LDID && !is_preg && hw_fp ?
{ $cost[0].cost = 1; }
{
  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_F4);
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, mtype, mtype, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

areg: OPC_I4I4ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

areg: OPC_I4I2ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I2, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

areg: OPC_I4I1ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I1, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

areg: OPC_U4U4ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

areg: OPC_U4U2ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

areg: OPC_U4U1ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

//
// Indirect load of a floating point number into a areg.
// Note we need this rule --- even if we have a floating point
// coprocessor --- for loading floats into argument registers.
//
areg: OPC_F4F4ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_I4);
  return Generate_Load_Memory($0, mtype, mtype, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

freg: OPC_F4F4ILOAD(areg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TYPE_ID mtype = (result ? TN_mtype(result) : MTYPE_F4);
  return Generate_Load_Memory($0, mtype, mtype, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

areg: OPC_U4LDA && !is_auto_or_formal ?
{ $cost[0].cost = 1; }
{
  ST *s = WN_st($0);
  INT64 o = WN_lda_offset($0);
  return Generate_Constant(MTYPE_U4, $0, result, s, o, ops);
};

areg: OPC_U4LDA_LABEL ?
{ $cost[0].cost = 1; }
{
  return Generate_Constant(MTYPE_U4, $0, result, Gen_Label_TN(Get_WN_Label($0),0), ops );
};

areg: OPC_U4LDA && is_auto_or_formal ?
{ $cost[0].cost = 1; }
{
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Allocate_Object(WN_st($0));
  Set_Last_Mem_OP(ops);
  Generate_OP_And_Address_Computation(TOP_addi, result,
				      WN_st($0), WN_load_offset($0), ops,
				      use_conservative_addressing(WN_st($0)),
				      false, false);
  Set_OP_To_WN_Map($0);
  return result;
};


//=============================================================================
//
// Rules for loading long longs
//
//=============================================================================

// For the following functions, we don't need to setup the high bits
// because none of our parents should need to use the high bits. All such
// cases should have already been converted into 32-bit operations in 
// WN_Lower. 
areg: OPC_I4I8LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + Preg_Increment(MTYPE_I4);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
};

ll_cvt_areg: OPC_I8I8LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o_lo = WN_load_offset($0);
  INT64 o_hi = o_lo + Preg_Increment(MTYPE_I4);
  if (Target_Byte_Sex == BIG_ENDIAN) {
    o_hi = WN_load_offset($0);
    o_lo = o_hi + Preg_Increment(MTYPE_I4);
  }
  if (result==NULL)
    result = Build_TN_Of_Mtype(MTYPE_I4);
  TN* result_1 = Build_TN_Of_Mtype(MTYPE_I4);
  set_reg_tn_pair(result, result_1);
  Move_To_Register(MTYPE_I4,result_1,PREG_To_TN(s,o_hi),ops);
  return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o_lo),ops);
};

//  areg: OPC_I8I4LDID &&  is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    ST *s = WN_st($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + Preg_Increment(MTYPE_I4);
//    return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
//  };

//  areg: OPC_I8I2LDID &&  is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    ST *s = WN_st($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + Preg_Increment(MTYPE_I4);
//    return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
//  };

//  areg: OPC_I8I1LDID && is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    ST *s = WN_st($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + Preg_Increment(MTYPE_I4);
//    return Move_To_Register(MTYPE_I4,result,PREG_To_TN(s,o),ops);
//  };

areg: OPC_U4U8LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + Preg_Increment(MTYPE_U4);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
};

ll_cvt_areg: OPC_U8U8LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o_lo = WN_load_offset($0);
  INT64 o_hi = o_lo + Preg_Increment(MTYPE_U4);
  if (Target_Byte_Sex == BIG_ENDIAN) {
    o_hi = WN_load_offset($0);
    o_lo = o_hi + Preg_Increment(MTYPE_U4);
  }
  if (result==NULL)
    result = Build_TN_Of_Mtype(MTYPE_U4);
  TN* result_1 = Build_TN_Of_Mtype(MTYPE_U4);
  set_reg_tn_pair(result, result_1);
  Move_To_Register(MTYPE_U4,result_1,PREG_To_TN(s,o_hi),ops);
  return Move_To_Register(MTYPE_U4,result,PREG_To_TN(s,o_lo),ops);
};

//  areg: OPC_U8U4LDID &&  is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    ST *s = WN_st($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + Preg_Increment(MTYPE_U4);
//    return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
//  };

//  areg: OPC_U8U2LDID &&  is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    ST *s = WN_st($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + Preg_Increment(MTYPE_U4);
//    return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
//  };

//  areg: OPC_U8U1LDID &&  is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    ST *s = WN_st($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + Preg_Increment(MTYPE_U4);
//    return Move_To_Register(MTYPE_U4,result,PREG_To_TN( s, o ),ops);
//  };

areg: OPC_I4I8LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  INT64 o = WN_load_offset($0);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_I4);
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
			      WN_st($0), o, Variant_LDID($0), ops);
};

//  areg: OPC_I8I8LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o_lo = WN_load_offset($0);
//    INT64 o_hi = o_lo + MTYPE_RegisterSize(MTYPE_I4);
//    if (Target_Byte_Sex == BIG_ENDIAN) {
//      o_hi = WN_load_offset($0);
//      o_lo = o_hi + MTYPE_RegisterSize(MTYPE_I4);
//    }
//    if (result==NULL)
//      result = Build_TN_Of_Mtype(MTYPE_I4);
//    TN* result_1 = Build_TN_Of_Mtype(MTYPE_I4);
//    set_reg_tn_pair(result, result_1);
//    Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result_1,
//  			      WN_st($0), o_hi, Variant_LDID($0), ops);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
//  			      WN_st($0), o_lo, Variant_LDID($0), ops);
//  };

//  areg: OPC_I8I4LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
//  			      WN_st($0), o, Variant_LDID($0), ops);
//  };

//  areg: OPC_I8I2LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I2, result,
//  			      WN_st($0), o, Variant_LDID($0), ops);
//  };

//  areg: OPC_I8I1LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I1, result,
//  			      WN_st($0), o, Variant_LDID($0), ops);
//  };

areg: OPC_U4U8LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  INT64 o = WN_load_offset($0);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_U4);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
			      WN_st($0), o, Variant_LDID($0), ops);
};

//  areg: OPC_U8U8LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o_lo = WN_load_offset($0);
//    INT64 o_hi = o_lo + MTYPE_RegisterSize(MTYPE_U4);
//    if (Target_Byte_Sex == BIG_ENDIAN) {
//      o_hi = WN_load_offset($0);
//      o_lo = o_hi + MTYPE_RegisterSize(MTYPE_U4);
//    }
//    if (result==NULL)
//      result = Build_TN_Of_Mtype(MTYPE_U4);
//    TN* result_1 = Build_TN_Of_Mtype(MTYPE_U4);
//    set_reg_tn_pair(result, result_1);
//    Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result_1,
//  			      WN_st($0), o_hi, Variant_LDID($0), ops);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
//  			      WN_st($0), o_lo, Variant_LDID($0), ops);
//  };

//  areg: OPC_U8U4LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
//  			      WN_st($0), o, Variant_LDID($0), ops);
//  };

//  areg: OPC_U8U2LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, result,
//  			      WN_st($0), o, Variant_LDID($0), ops);
//  };

//  areg: OPC_U8U1LDID && !is_preg ?
//  { $cost[0].cost = 1; }
//  {
//    Check_For_Dedicated_Preg($0);
//    INT64 o = WN_load_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
//  			      WN_st($0), o, Variant_LDID($0), ops);
//  };

areg: OPC_I4I8ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  INT64 o = WN_offset($0);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_I4);
  return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
};

//  areg: OPC_I8I8ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

//  areg: OPC_I8I4ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

//  areg: OPC_I8I2ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I2, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

//  areg: OPC_I8I1ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_I4);
//    return Generate_Load_Memory($0, MTYPE_I4, MTYPE_I1, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

areg: OPC_U4U8ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  INT64 o = WN_offset($0);
  if (Target_Byte_Sex == BIG_ENDIAN)
     o = o + MTYPE_RegisterSize(MTYPE_U4);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
};

//  areg: OPC_U8U8ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

//  areg: OPC_U8U4ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

//  areg: OPC_U8U2ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };

//  areg: OPC_U8U1ILOAD(areg) ?
//  { $cost[0].cost = $cost[2].cost + 1; }
//  {
//    INT64 o = WN_offset($0);
//    if (Target_Byte_Sex == BIG_ENDIAN)
//      o = o + MTYPE_RegisterSize(MTYPE_U4);
//    return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
//  			      $action[2](0,ops), o, Variant_ILOAD($0), ops);
//  };


//=============================================================================
//
// Rules for storing long long preg
//
//=============================================================================

// the only case that needs this rule is when there is a TIE to longlong
// conversion and the conversion cannot be lowered into register pair in
// the lowerer
// instead, we use a temp preg to hold the conversion results

expr: OPC_I8STID(areg) &&  is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  WN* kid = WN_kid0($0);
  TN *result_lo, *result_hi;

  Is_True(WN_operator(kid)==OPR_CVT, ("Expecting TIE conversion"));
  Is_True(MTYPE_is_tie(WN_desc(kid)), ("Expecting TIE type"));
  Is_True(result==0, ("Requesting result from store"));
  if (Target_Byte_Sex == BIG_ENDIAN) {
    result_lo = PREG_To_TN(s,o+Preg_Increment(MTYPE_I4));
    result_hi = PREG_To_TN(s,o);
  } else {
    result_hi = PREG_To_TN(s,o+Preg_Increment(MTYPE_I4));
    result_lo = PREG_To_TN(s,o);
  }

  TN* areg = $action[2](0,ops);
  TN* areg_1 = get_reg_tn_pair(areg);
  Move_To_Register(MTYPE_I4,result_hi,areg_1,ops);
  return Move_To_Register(MTYPE_I4,result_lo,areg,ops);
};

expr: OPC_U8STID(areg) &&  is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  WN* kid = WN_kid0($0);
  TN *result_lo, *result_hi;

  Is_True(WN_operator(kid)==OPR_CVT, ("Expecting TIE conversion"));
  Is_True(MTYPE_is_tie(WN_desc(kid)), ("Expecting TIE type"));
  Is_True(result==0, ("Requesting result from store"));
  if (Target_Byte_Sex == BIG_ENDIAN) {
    result_lo = PREG_To_TN(s,o+Preg_Increment(MTYPE_U4));
    result_hi = PREG_To_TN(s,o);
  } else {
    result_hi = PREG_To_TN(s,o+Preg_Increment(MTYPE_U4));
    result_lo = PREG_To_TN(s,o);
  }

  TN* areg = $action[2](0,ops);
  TN* areg_1 = get_reg_tn_pair(areg);
  Move_To_Register(MTYPE_U4,result_hi,areg_1,ops);
  return Move_To_Register(MTYPE_U4,result_lo,areg,ops);
};

//===========================================================================
//
// Arithmetic rules
//
//===========================================================================

// signed add

areg: OPC_I4ADD(areg, areg_or_simm8) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *reg_or_imm = $action[3](0,ops);
  return Generate_Binary(MTYPE_I4, (TN_has_value(reg_or_imm)) ? TOP_addi : TOP_add,
			 result, $action[2](0,ops), reg_or_imm, ops);
};

areg: OPC_I4ADD(simm8, areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{ 
  TN * tn2 = $action[2]();
  TN * tn3 = $action[3](0,ops);
  
  return Generate_Binary( MTYPE_I4, TOP_addi, result,
			  tn3, tn2, ops );
};

areg: OPC_I4ADD(areg, simm8x256) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{ 
  TN * tn3 = $action[3]();
  TN * tn2 = $action[2](0,ops);
  return Generate_Binary( MTYPE_I4, TOP_addmi, result,
			  tn2, tn3, ops );
};

areg: OPC_I4ADD(simm8x256, areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{ 
  TN * tn2 = $action[2]();
  TN * tn3 = $action[3](0,ops);
  return Generate_Binary( MTYPE_I4, TOP_addmi, result,
			  tn3, tn2, ops );
};

// unsigned add

areg: OPC_U4ADD(areg, areg_or_simm8) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *reg_or_imm = $action[3](0,ops);
  return Generate_Binary(MTYPE_U4, (TN_has_value(reg_or_imm)) ? TOP_addi : TOP_add,
			 result, $action[2](0,ops), reg_or_imm, ops);
};

areg: OPC_U4ADD(simm8, areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn2 = $action[2]();
  TN * tn3 = $action[3](0,ops);			  
  return Generate_Binary( MTYPE_U4, TOP_addi, result,
			  tn3, tn2, ops );
};

areg: OPC_U4ADD(areg, simm8x256) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3]();
  TN * tn2 = $action[2](0,ops);
  
  return Generate_Binary( MTYPE_U4, TOP_addmi, result,
			  tn2, tn3, ops );
};

areg: OPC_U4ADD(simm8x256, areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{ 
  TN * tn2 = $action[2]();
  TN * tn3 = $action[3](0,ops);
			  
  return Generate_Binary( MTYPE_U4, TOP_addmi, result,
			  tn3, tn2, ops );
};

// signed subtract

areg: OPC_I4SUB(areg,areg_or_simm8) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
			  
  return Generate_Sub(MTYPE_I4, result, tn2, tn3, ops);
};

areg: OPC_I4SUB(areg,simm8x256) ?
{
  /* Check for corner case where max negative value fits, but positive
     doesn't. */
  if (!is_simm8x256_negated($3))
    NO_MATCH;

  $cost[0].cost = $cost[2].cost + $cost[3].cost + 1;
}
{   
  TN * tn3 = $action[3]();
  TN * tn2 = $action[2](0,ops);
			  
 return Generate_Binary(MTYPE_U4, TOP_addmi, result, tn2,
			 Gen_Literal_TN(-TN_value(tn3), 4), ops);

};

// unsigned subtract

areg: OPC_U4SUB(areg,areg_or_simm8) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
			  
  return Generate_Sub(MTYPE_U4, result, tn2, tn3, ops);
};

areg: OPC_U4SUB(areg,simm8x256) ?
{
  /* Check for corner case where max negative value fits, but positive
     doesn't. */
  if (!is_simm8x256_negated($3))
    NO_MATCH;

  $cost[0].cost = $cost[2].cost + $cost[3].cost + 1;
}
{ 
  TN * tn3 = $action[3]();
  TN * tn2 = $action[2](0,ops);		  
 return Generate_Binary(MTYPE_U4, TOP_addmi, result, tn2,
			 Gen_Literal_TN(-TN_value(tn3), 4), ops);

};


// signed multiplies

areg: OPC_I4MPY(areg,areg) ?
{   
  if (xt_mul16 && WN_Mpy_16Bit($1))
  {
    if (!MUL16_arg_cost($1, $2, $3, &($cost[0]), 1))
      NO_MATCH;
  }
  else if (xt_mul32)
  {
    $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; 
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit($1))
  {
    int cost_val = WN_Mpy_16Bit_Signed($1) ? 4 : 5;
    if (!MUL16_arg_cost($1, $2, $3, &($cost[0]), cost_val))
      NO_MATCH;
  }
  else
    NO_MATCH;
}
{
  char *op_name = NULL;
  bool mul16 = false;
  if (xt_mul16 && WN_Mpy_16Bit($1))
  {
    if (WN_Mpy_16Bit_Signed($1))
      op_name = "mul16s";
    else
      op_name = "mul16u";
    mul16 = true;
  }  
  else if (xt_mul32)
  {
    op_name = "mull";
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit($1))
  {
    /* op_name is set to NULL. Note that xt_mul16 and xt_mul32 have
       priority over HiFi2. */
    mul16 = true;
  }
  else
    FmtAssert(FALSE, ("cannot generate multiply instruction"));

  if (mul16)
    return Generate_MUL16(MTYPE_I4, result, $1, op_name, $2, $3, ops);
  
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  
  return Generate_Mul(MTYPE_I4, result, $1, op_name, tn2, tn3, ops);
};


// unsigned multiplies

areg: OPC_U4MPY(areg,areg) ?
{   
  if (xt_mul16 && WN_Mpy_16Bit($1))
  {
    if (!MUL16_arg_cost($1, $2, $3, &($cost[0]), 1))
      NO_MATCH;
  }
  else if (xt_mul32)
  {
    $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; 
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit($1))
  {
    int cost_val = WN_Mpy_16Bit_Signed($1) ? 4 : 5;
    if (!MUL16_arg_cost($1, $2, $3, &($cost[0]), cost_val))
      NO_MATCH;
  }
  else
    NO_MATCH;
}
{
  char *op_name = NULL;
  bool mul16 = false;
  if (xt_mul16 && WN_Mpy_16Bit($1))
  {
    if (WN_Mpy_16Bit_Signed($1))
      op_name = "mul16s";
    else
      op_name = "mul16u";
    mul16 = true;
  }  
  else if (xt_mul32)
  {
    op_name = "mull";
  }
  else if (!xt_mac16 && Enable_HiFi2_Ops && WN_Mpy_16Bit($1))
  {
    /* op_name is set to NULL. Note that xt_mul16 and xt_mul32 have
       priority over hifi2. */
    mul16 = true;
  }
  else
    FmtAssert(FALSE, ("cannot generate multiply instruction"));

  if (mul16)
    return Generate_MUL16(MTYPE_U4, result, $1, op_name, $2, $3, ops);
  
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  
  return Generate_Mul(MTYPE_U4, result, $1, op_name, tn2, tn3, ops);
};


areg: OPC_I4DIV(areg, areg) && hw_idiv32 ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to DIV are constant");
    return Generate_Constant(MTYPE_I4, result, tn_equiv_const(tn2)/tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_I4, TOP_quos, result, tn2, tn3, ops);
  }
};

areg: OPC_U4DIV(areg, areg) && hw_idiv32 ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to unsigned DIV are constant");
    return Generate_Constant(MTYPE_U4, result, tn_equiv_const(tn2)/tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_U4, TOP_quou, result, tn2, tn3, ops);
  }
};

areg: OPC_I4REM(areg, areg) && hw_idiv32 ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to REM are constant");
    return Generate_Constant(MTYPE_I4, result, tn_equiv_const(tn2) % tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_I4, TOP_rems, result, tn2, tn3, ops);
  }
};

areg: OPC_U4REM(areg, areg) && hw_idiv32 ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to unsigned REM are constant");
    return Generate_Constant(MTYPE_U4, result, tn_equiv_const(tn2) % tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_U4, TOP_remu, result, tn2, tn3, ops);
  }
};

areg: OPC_I4MOD(areg, areg) && hw_idiv32 ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to MOD are constant");
    // a mod b == (1) (a rem b)        if a*b >= 0 OR (a rem b) == 0;
    //            (2) (a rem b) + b    otherwise
    INT64 cdivident = tn_equiv_const(tn2);
    INT64 cdivisor  = tn_equiv_const(tn3);
    INT64 cres      = cdivident % cdivisor;
    if ( (cres != 0) && (cdivident * cdivisor < 0) ) {
      cres += cdivisor;
    }
    return Generate_Constant(MTYPE_I4, result, cres, ops);
  } else {
    TN *sign_tn;
    TN *tmp;
    Build_OP(TOP_movi, tmp, Gen_Literal_TN(0, 4), ops);
    Build_OP(TOP_xor, sign_tn, tn2, tn3, ops);
    Build_OP(TOP_movltz, tmp, tn3, sign_tn, ops);
    
    Generate_iDivRem(MTYPE_I4, TOP_rems, result, tn2, tn3, ops);

    Build_OP(TOP_add, tmp, tmp, result, ops);
    Build_OP(TOP_movnez, result, tmp, result, ops);
    return result;
  }
};

// Same as OPC_U4REM 
areg: OPC_U4MOD(areg, areg) && hw_idiv32 ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
  if ((CG_opt_level > 0) && tn_is_const_equiv(tn2) && tn_is_const_equiv(tn3) &&
      (tn_equiv_const(tn3) != 0)) {
    DevWarn("both operands to unsigned MOD are constant");
    return Generate_Constant(MTYPE_U4, result, tn_equiv_const(tn2) % tn_equiv_const(tn3), ops);
  } else {
    return Generate_iDivRem(MTYPE_U4, TOP_remu, result, tn2, tn3, ops);
  }
};

// max/min

areg: OPC_I4MAX(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + ((xt_minmax) ? 1 : 2); }
{ 
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops);
			  
  return Generate_MINMAX( MTYPE_I4, TOP_max, OPR_GE, result,
			  tn2, tn3,
			  ops );
};

areg: OPC_U4MAX(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + ((xt_minmax) ? 1 : 2); }
{ 
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_MINMAX( MTYPE_U4, TOP_maxu, OPR_GE, result,
			  tn2, tn3,
			  ops );
};

areg: OPC_I4MIN(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + ((xt_minmax) ? 1 : 2); }
{ 
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_MINMAX( MTYPE_I4, TOP_min, OPR_LE, result,
			  tn2, tn3,
			  ops );
};

areg: OPC_U4MIN(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + ((xt_minmax) ? 1 : 2); }
{ 
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_MINMAX( MTYPE_U4, TOP_minu, OPR_LE, result,
			  tn2, tn3,
			  ops );
};

// clamps

areg: OPC_I4MIN(OPC_I4MAX(areg, clamps_const), clamps_const) ?
{
  if (!xt_clamps || !is_clamps_const_pair($4, $5))
    NO_MATCH;
  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[3](0,ops);
  TN *imm = $action[5]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MIN(clamps_const, OPC_I4MAX(areg, clamps_const)) ?
{
  if (!xt_clamps || !is_clamps_const_pair($5, $2))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[4](0,ops);
  TN *imm = $action[2]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MIN(OPC_I4MAX(clamps_const, areg), clamps_const) ?
{
  if (!xt_clamps || !is_clamps_const_pair($3, $5))
    NO_MATCH;
  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[4](0,ops);
  TN *imm = $action[5]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MIN(clamps_const, OPC_I4MAX(clamps_const, areg)) ?
{
  if (!xt_clamps || !is_clamps_const_pair($4, $2))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[5](0,ops);
  TN *imm = $action[2]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MAX(OPC_I4MIN(areg, clamps_const), clamps_const) ?
{
  if (!xt_clamps || !is_clamps_const_pair($5, $4))
    NO_MATCH;
  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[3](0,ops);
  TN *imm = $action[4]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MAX(clamps_const, OPC_I4MIN(areg, clamps_const)) ?
{
  if (!xt_clamps || !is_clamps_const_pair($2, $5))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[4](0,ops);
  TN *imm = $action[5]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MAX(OPC_I4MIN(clamps_const, areg), clamps_const) ?
{
  if (!xt_clamps || !is_clamps_const_pair($5, $3))
    NO_MATCH;
  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[4](0,ops);
  TN *imm = $action[3]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

areg: OPC_I4MAX(clamps_const, OPC_I4MIN(clamps_const, areg)) ?
{
  if (!xt_clamps || !is_clamps_const_pair($2, $4))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost + $cost[4].cost + $cost[5].cost + 1;
}
{ 
  TN *src = $action[5](0,ops);
  TN *imm = $action[4]();
  return Generate_Clamps(MTYPE_I4, result, src, imm, ops);
};

// abs

areg: OPC_I4ABS(areg) ?
{ $cost[0].cost = $cost[2].cost + xt_abs ? 1 : 2; }
{ 
  if (xt_abs)
    return Generate_Unary( MTYPE_I4, TOP_abs, result,
			   $action[2](0,ops), ops );
  else {
    TN * value =  $action[2](0,ops);
    TN * neg = Generate_Unary( MTYPE_I4, TOP_neg, NULL,
			       value, ops );
    TN * cond = Generate_Cmov(MTYPE_I4, TOP_movgez, result, 
			      value, value, neg, ops);
    return cond;
  }
			      
};

// negation

areg: OPC_I4NEG(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{ return Generate_Unary( MTYPE_I4, TOP_neg, result,
			  $action[2](0,ops), ops );
};

areg: OPC_U4NEG(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{ return Generate_Unary( MTYPE_U4, TOP_neg, result,
			  $action[2](0,ops), ops );
};


//===========================================================================
//
// Floating-point rules
//
//===========================================================================

// add

freg: OPC_F4ADD(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TOP add_s = TI_TOP_Topcode("add.s");
  return Generate_Binary_FP(MTYPE_F4, add_s, result, tn2, tn3, true, ops);
};

// subtract

freg: OPC_F4SUB(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TOP sub_s = TI_TOP_Topcode("sub.s");
  return Generate_Binary_FP(MTYPE_F4, sub_s, result, tn2, tn3, true, ops);
};

// multiply

freg: OPC_F4MPY(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TOP mul_s = TI_TOP_Topcode("mul.s");
  return Generate_Binary_FP(MTYPE_F4, mul_s, result, tn2, tn3, true, ops);
};

// divide


freg: OPC_F4DIV(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TOP div_s = TI_TOP_Topcode("div.s");
  return Generate_Binary_FP(MTYPE_F4, div_s, result, tn2, tn3, true, ops);
};

// multiply-add

freg: OPC_F4MADD(freg, freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TN *tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP madd_s = TI_TOP_Topcode("madd.s");
  TN* state4 = cpenable_tn(madd_s);
  if (state4)
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);

  if (result == NULL) {
    result = tmp;
  } else {
    result = Move_To_Register(MTYPE_F4, result, tmp, ops);
  }
  return result;
};

freg: OPC_F4NMADD(freg, freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 2; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TN * tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP madd_s = TI_TOP_Topcode("madd.s");
  TN* state4 = cpenable_tn(madd_s);
  if (state4)
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(madd_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);
  TOP neg_s = TI_TOP_Topcode("neg.s"); 
  return Generate_Unary_FP(MTYPE_F4, neg_s, result, tmp, ops );
};

// multiply-subtract

freg: OPC_F4NMSUB(freg, freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TN *tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP msub_s = TI_TOP_Topcode("msub.s");
  TN* state4 = cpenable_tn(msub_s);
  if (state4)
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);

  if (result == NULL) {
    result = tmp;
  } else {
    result = Move_To_Register(MTYPE_F4, result, tmp, ops);
  }
  return result;
};

freg: OPC_F4MSUB(freg, freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 2; }
{
  TN * tn4 = $action[4](0,ops);
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  TN * tmp = Build_TN_Of_Mtype(MTYPE_F4);
  tmp = Move_To_Register(MTYPE_F4, tmp, tn2, ops);
  TOP msub_s = TI_TOP_Topcode("msub.s");
  TN* state4 = cpenable_tn(msub_s);
  if (state4)
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), state4 /* cpenable_tn() */, ops);
  else
    Build_OP(msub_s, tmp, tmp, tn3, tn4, round_mode_tn(), ops);
  TOP neg_s = TI_TOP_Topcode("neg.s"); 
  return Generate_Unary_FP(MTYPE_F4, neg_s, result, tmp, ops );
};

// abs

freg: OPC_F4ABS(freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + 1; }
{ 
  TOP abs_s = TI_TOP_Topcode("abs.s"); 
  return Generate_Unary_FP(MTYPE_F4, abs_s, result, $action[2](0,ops), ops );
};

// negation

freg: OPC_F4NEG(freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + 1; }
{ 
  TOP neg_s = TI_TOP_Topcode("neg.s"); 
  return Generate_Unary_FP(MTYPE_F4, neg_s, result, $action[2](0,ops), ops );
};

// reciprocal

freg: OPC_F4RECIP(freg) && hw_fp_recip ?
{ $cost[0].cost = $cost[2].cost + 1; }
{ 
  TOP recip_s = TI_TOP_Topcode("recip.s"); 
  return Generate_Unary_FP(MTYPE_F4, recip_s, result, $action[2](0, ops), ops );
};

// reciprocal square root

freg: OPC_F4RSQRT(freg) && hw_fp_rsqrt ?
{ $cost[0].cost = $cost[2].cost + 1; }
{ 
  TOP rsqrt_s = TI_TOP_Topcode("rsqrt.s"); 
  return Generate_Unary_FP(MTYPE_F4, rsqrt_s, result, $action[2](0, ops), ops );
};

// conversion from int to float

freg: OPC_F4I4CVT(areg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); }
{ 
  TN *src = $action[2](0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP float_s = TI_TOP_Topcode("float.s"); 
  /* Move the data from AR into the FP regfile first if necessary. */
  if (!tie_info->xtfloat_ar_converts())
    src = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), NULL, src, ops);
  return Generate_Binary_FP(MTYPE_F4, float_s, result, src, zero_tn, true, ops);
};

freg: OPC_F4U4CVT(areg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); }
{ 
  TN *src = $action[2](0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP float_s = TI_TOP_Topcode("ufloat.s"); 
  /* Move the data from AR into the FP regfile first if necessary. */
  if (!tie_info->xtfloat_ar_converts())
    src = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), NULL, src, ops);
  return Generate_Binary_FP(MTYPE_F4, float_s, result, src, zero_tn, true, ops);
};

// conversion from float to int

areg: OPC_I4F4CVT(freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); }
{ 
  TN *fr = $action[2](0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("trunc.s"); 

  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_I4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_I4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;
};

areg: OPC_I4F4TRUNC(freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); }
{ 
  TN *fr = $action[2](0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("trunc.s"); 

  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_I4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_I4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;
};

areg: OPC_U4F4CVT(freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); }
{ 
  TN *fr = $action[2](0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("utrunc.s"); 

  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_U4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_U4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;
};

areg: OPC_U4F4TRUNC(freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + (tie_info->xtfloat_ar_converts() ? 1 : 2); }
{ 
  TN *fr = $action[2](0,ops);
  TN *zero_tn = Gen_Literal_TN(0,4);
  TOP trunc_s = TI_TOP_Topcode("utrunc.s"); 
  bool rfr_req = !tie_info->xtfloat_ar_converts();
  TN *tmp_res = rfr_req ? NULL : result;
  tmp_res = Generate_Binary_FP(rfr_req ? MTYPE_F4 : MTYPE_U4,
                               trunc_s, tmp_res, fr, zero_tn, false, ops);
  /* Move the result from the FP regfile to AR if necessary. */
  if (rfr_req)
    tmp_res = Generate_Unary_FP(MTYPE_U4, TI_TOP_Topcode("rfr"), result, tmp_res, ops);
  return tmp_res;
};

// signed result comparisons

areg: OPC_I4F4LT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_LT, MTYPE_I4, result, l, r, ops);
};

b1reg: OPC_I4F4LT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, l, r, ops);
};

areg: OPC_I4F4GT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_GT, MTYPE_I4, result, l, r, ops);
};

b1reg: OPC_I4F4GT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, r, l, ops);
};

areg: OPC_I4F4LE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_LE, MTYPE_I4, result, l, r, ops);
};

b1reg: OPC_I4F4LE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, l, r, ops);
};

areg: OPC_I4F4GE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_GE, MTYPE_I4, result, l, r, ops);
};

b1reg: OPC_I4F4GE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, r, l, ops);
};

areg: OPC_I4F4EQ(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_EQ, MTYPE_I4, result, l, r, ops);
};

b1reg: OPC_I4F4EQ(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
};

areg: OPC_I4F4NE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_NE, MTYPE_I4, result, l, r, ops);
};

// unsigned result comparisons

areg: OPC_U4F4LT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_LT, MTYPE_U4, result, l, r, ops);
};

b1reg: OPC_U4F4LT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, l, r, ops);
};

areg: OPC_U4F4GT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_GT, MTYPE_U4, result, l, r, ops);
};

b1reg: OPC_U4F4GT(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LT, result, r, l, ops);
};

areg: OPC_U4F4LE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_LE, MTYPE_U4, result, l, r, ops);
};

b1reg: OPC_U4F4LE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, l, r, ops);
};

areg: OPC_U4F4GE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_GE, MTYPE_U4, result, l, r, ops);
};

b1reg: OPC_U4F4GE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_LE, result, r, l, ops);
};

areg: OPC_U4F4EQ(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_EQ, MTYPE_U4, result, l, r, ops);
};

b1reg: OPC_U4F4EQ(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison_br(OPR_EQ, result, l, r, ops);
};

areg: OPC_U4F4NE(freg, freg) && hw_fp ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
{
  TN *r = $action[3](0,ops);
  TN *l = $action[2](0,ops);
  return Generate_FP_Comparison(OPR_NE, MTYPE_U4, result, l, r, ops);
};


//===========================================================================
//
// Logical rules
//
//===========================================================================

// and

areg: OPC_I4BAND(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Binary( MTYPE_I4, TOP_and, result,
			  tn2, tn3,
			  ops );
};

areg: OPC_I4BAND(areg,extui_mask) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3]();
  TN * tn2 = $action[2](0,ops); 
  return Generate_And_Immediate(MTYPE_I4, result,tn2, tn3, ops);
}; 
  
areg: OPC_I4BAND(extui_mask,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn2 = $action[2]();
  TN * tn3 = $action[3](0,ops); 
  return Generate_And_Immediate(MTYPE_I4, result, tn3, tn2, ops);
}; 
  
areg: OPC_U4BAND(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Binary( MTYPE_U4, TOP_and, result, tn2, tn3, ops );
};

areg: OPC_U4BAND(areg,extui_mask) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3]();
  TN * tn2 = $action[2](0,ops); 
  return Generate_And_Immediate(MTYPE_U4, result, tn2, tn3, ops);
}; 
  
areg: OPC_U4BAND(extui_mask,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn2 = $action[2]();
  TN * tn3 = $action[3](0,ops); 
  return Generate_And_Immediate(MTYPE_U4, result, tn3, tn2, ops);
}; 
  
// or

areg: OPC_I4BIOR(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Binary( MTYPE_I4, TOP_or, result, tn2, tn3,  ops );
};

areg: OPC_U4BIOR(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Binary( MTYPE_U4, TOP_or, result, tn2, tn3, ops );
};

// PR 4370: 
// x = (y << 1) | 1 
// ----------------
// movi	 z, 1
// addx2 x, y, z

areg: OPC_I4BIOR (OPC_I4SHL (areg, one), one) ?
{ 
  $cost[0].cost = $cost[3].cost + 2; 
  if (!xt_addx) 
    NO_MATCH;
}
{   
  TN * left = $action[3](0,ops);
  TN * one = Generate_Constant( MTYPE_I4, NULL, 1, ops ); 
  return Generate_Binary( MTYPE_I4, TOP_addx2, result, left, one,  ops );
};

areg: OPC_U4BIOR (OPC_U4SHL (areg, one), one) ?
{ 
  $cost[0].cost = $cost[3].cost + 2; 
  if (!xt_addx) 
    NO_MATCH;
}
{   
  TN * left = $action[3](0,ops);
  TN * one = Generate_Constant( MTYPE_U4, NULL, 1, ops ); 
  return Generate_Binary( MTYPE_U4, TOP_addx2, result, left, one,  ops );
};

// xor

areg: OPC_I4BXOR(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Binary( MTYPE_I4, TOP_xor, result, tn2, tn3, ops );
};

areg: OPC_U4BXOR(areg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{   
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Binary( MTYPE_U4, TOP_xor, result, tn2, tn3, ops );
};

// binary not

areg: OPC_I4BNOT(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN *tmp = Generate_Constant(MTYPE_I4, NULL, -1, ops);
    
  return Generate_Binary( MTYPE_I4, TOP_xor, result,
			  $action[2](0,ops), tmp, ops );
};

areg: OPC_U4BNOT(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN *tmp = Generate_Constant(MTYPE_I4, NULL, -1, ops);

  return Generate_Binary( MTYPE_U4, TOP_xor, result,
			  $action[2](0,ops), tmp, ops );
};

// logical not

areg: OPC_I4LNOT(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN *tmp = Generate_Constant(MTYPE_I4, NULL, 1, ops);

  /* Get the source tn. We must copy it to a temporary tn if 'src' ==
     'result' since we clobber 'result' before using 'src'. */
  TN *src = $action[2](0,ops);
  if (src == result)
    src = Move_To_Register(MTYPE_I4,Build_TN_Of_Mtype(MTYPE_I4), src, ops);
  
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  result = Generate_Constant(MTYPE_I4, result, 0, ops);
  Build_OP(TOP_moveqz, result, result, tmp, src, ops );
  return result;
};

areg: OPC_U4LNOT(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  TN *tmp = Generate_Constant(MTYPE_U4, NULL, 1, ops);

  /* Get the source tn. We must copy it to a temporary tn if 'src' ==
     'result' since we clobber 'result' before using 'src'. */
  TN *src = $action[2](0,ops);
  if (src == result)
    src = Move_To_Register(MTYPE_U4, Build_TN_Of_Mtype(MTYPE_U4), src, ops);
  
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  result = Generate_Constant(MTYPE_U4, result, 0, ops);
  Build_OP(TOP_moveqz, result, result, tmp, src, ops );
  return result;
};


//===========================================================================
//
// Shift rules
//
//===========================================================================

// immediate forms

areg: OPC_I4SHL(areg,msalp32) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_slli, result, left, right, ops );
  return result;
};

areg: OPC_U4SHL(areg,msalp32) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_slli, result, left, right, ops );
  return result;
};

areg: OPC_I4ASHR(areg,uimm5) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_srai, result, left, right, ops );
  return result;
};

areg: OPC_U4ASHR(areg,uimm5) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_srai, result, left, right, ops );
  return result;
};

areg: OPC_I4LSHR(areg,uimm4) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_srli, result, left, right, ops );
  return result;
};

areg: OPC_U4LSHR(areg,uimm4) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_srli, result, left, right, ops );
  return result;
};

areg: OPC_I4LSHR(areg,uimm5) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP(TOP_extui, result, left, right, Gen_Literal_TN(32-TN_value(right),4), ops);
  return result;
};

areg: OPC_U4LSHR(areg,uimm5) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3]();
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_extui, result, left, right, Gen_Literal_TN(32-TN_value(right),4), ops);
  return result;
};

// sar forms
areg: OPC_I4SHL(areg,sar_left) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3](ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_sll, result, left, right, ops );
  return result;
};

areg: OPC_U4SHL(areg,sar_left) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3](ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_sll, result, left, right, ops );
  return result;
};

areg: OPC_I4ASHR(areg,sar_right) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3](ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_sra, result, left, right, ops );
  return result;
};

areg: OPC_U4ASHR(areg,sar_right) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3](ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_sra, result, left, right, ops );
  return result;
};

areg: OPC_I4LSHR(areg,sar_right) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3](ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_I4);
  Build_OP( TOP_srl, result, left, right, ops );
  return result;
};

areg: OPC_U4LSHR(areg,sar_right) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  TN *left = $action[2](0,ops);
  TN *right = $action[3](ops);
  if(!result) 
    result = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP( TOP_srl, result, left, right, ops );
  return result;
};

// src form
areg: OPC_U4BIOR(OPC_U4LSHR(areg, wsar), OPC_U4SHL(areg,OPC_I4SUB(thirtytwo, areg))) ?
{ 
  const OPERATOR opc4 = WN_operator($4);
  const OPERATOR opc9 = WN_operator($9);
  if (opc4 != OPR_INTCONST) {
    if (opc4 != OPR_LDID || ST_class(WN_st($4)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st($9)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv($4, $9))
      NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[6].cost + 1; 
}
{
    TN *left  = $action[6](0,ops);
    TN *right = $action[3](0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = $action[4](ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;
};

areg: OPC_U4BIOR(OPC_U4LSHR(areg, wsar), OPC_I4SHL(areg,OPC_I4SUB(thirtytwo, areg))) ?
{ 
  const OPERATOR opc4 = WN_operator($4);
  const OPERATOR opc9 = WN_operator($9);
  if (opc4 != OPR_INTCONST) {
    if (opc4 != OPR_LDID || ST_class(WN_st($4)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st($9)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv($4, $9))
      NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[6].cost + 1; 
}
{
    TN *left  = $action[6](0,ops);
    TN *right = $action[3](0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = $action[4](ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;
};

areg: OPC_U4BIOR(OPC_U4SHL(areg,OPC_I4SUB(thirtytwo, areg)),OPC_U4LSHR(areg, wsar)) ?
{ 
  const OPERATOR opc6 = WN_operator($6);
  const OPERATOR opc9 = WN_operator($9);
  if (opc6 != OPR_INTCONST) {
    if (opc6 != OPR_LDID || ST_class(WN_st($6)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st($9)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv($6, $9))
      NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[8].cost + $cost[9].cost + 1; 
}
{
    TN *left  = $action[3](0,ops);
    TN *right = $action[8](0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = $action[9](ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;
};

areg: OPC_U4BIOR(OPC_I4SHL(areg,OPC_I4SUB(thirtytwo, areg)),OPC_U4LSHR(areg, wsar)) ?
{ 
  const OPERATOR opc6 = WN_operator($6);
  const OPERATOR opc9 = WN_operator($9);
  if (opc6 != OPR_INTCONST) {
    if (opc6 != OPR_LDID || ST_class(WN_st($6)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (opc9 != OPR_INTCONST) {
    if (opc9 != OPR_LDID || ST_class(WN_st($9)) != CLASS_PREG) {
      NO_MATCH;
    }
  }
  if (!WN_Equiv($6, $9))
      NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[8].cost + $cost[9].cost + 1; 
}
{
    TN *left  = $action[3](0,ops);
    TN *right = $action[8](0,ops);
    if (!result)
	result = Build_TN_Of_Mtype(MTYPE_I4);
    TN *sar_r = $action[9](ops);
    Build_OP(TOP_src, result, left, right, sar_r, ops);
    return result;
};

//===========================================================================
//
// Combined Shift Add/Sub rules
//
//===========================================================================

areg: OPC_I4ADD(areg, OPC_I4SHL(areg,msalp32)) ?
{
  if (!allowed_shiftadd_immed($5))
    NO_MATCH;

  $cost[0].cost = $cost[2].cost + $cost[4].cost + $cost[5].cost + 1;
}
{
  TN *left = $action[4](0,ops);
  TN *right = $action[2](0,ops);
  TN *shift = $action[5]();
  return Generate_AddShift($0, MTYPE_I4, result, left, right, shift, ops);
};  

areg: OPC_I4ADD(OPC_I4SHL(areg,msalp32), areg) ?
{
  if (!allowed_shiftadd_immed($4))
    NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{
  TN *left = $action[3](0,ops);
  TN *right = $action[5](0,ops);
  TN *shift = $action[4]();
  return Generate_AddShift($0, MTYPE_I4, result, left, right, shift, ops);
}; 

areg: OPC_U4ADD(areg, OPC_U4SHL(areg,msalp32)) ?
{
  if (!allowed_shiftadd_immed($5))
    NO_MATCH;

  $cost[0].cost = $cost[2].cost + $cost[4].cost + $cost[5].cost + 1;
}
{
  TN *left = $action[4](0,ops);
  TN *right = $action[2](0,ops);
  TN *shift = $action[5]();
  return Generate_AddShift($0, MTYPE_U4, result, left, right, shift, ops);
}; 

areg: OPC_U4ADD(OPC_U4SHL(areg, msalp32), areg) ?
{
  if (!allowed_shiftadd_immed($4))
    NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{
  TN *left = $action[3](0,ops);
  TN *right = $action[5](0,ops);
  TN *shift = $action[4]();
  return Generate_AddShift($0, MTYPE_U4, result, left, right, shift, ops);
}; 

areg: OPC_I4SUB(OPC_I4SHL(areg,msalp32), areg) ?
{
  if (!allowed_shiftadd_immed($4))
    NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{
  TN *left = $action[3](0,ops);
  TN *right = $action[5](0,ops);
  TN *shift = $action[4]();
  return Generate_SubShift($0, MTYPE_I4, result, left, right, shift, ops);
}; 

areg: OPC_U4SUB(OPC_U4SHL(areg,msalp32), areg) ?
{
  if (!allowed_shiftadd_immed($4))
    NO_MATCH;

  $cost[0].cost = $cost[3].cost + $cost[4].cost + $cost[5].cost + 1;
}
{
  TN *left = $action[3](0,ops);
  TN *right = $action[5](0,ops);
  TN *shift = $action[4]();
  return Generate_SubShift($0, MTYPE_U4, result, left, right, shift, ops);
}; 


//===========================================================================
//
// MAC16 rules: Note that none of these rules return a result because the
//              acc_reg nonterminal is always associated with the same
//              dedicated TN.
//
//===========================================================================

acc_reg: OPC_I4MPY(areg,areg) ?
{
  if (!xt_mac16 || !WN_Mpy_16Bit($1))
    NO_MATCH;
  return MAC16_arg_cost($2, $3, &($cost[0]), 1);
}
{
  if (WN_Mpy_16Bit_Signed($1))
    Generate_MAC16("mul.aa.ll", $2, $3, ops);
  else
    Generate_MAC16("umul.aa.ll", $2, $3, ops);
  return;
};

acc_reg: OPC_U4MPY(areg,areg) ?
{
  if (!xt_mac16 || !WN_Mpy_16Bit($1))
    NO_MATCH;
  return MAC16_arg_cost($2, $3, &($cost[0]), 1);
}
{
  if (WN_Mpy_16Bit_Signed($1))
    Generate_MAC16("mul.aa.ll", $2, $3, ops);
  else
    Generate_MAC16("umul.aa.ll", $2, $3, ops);
  return;
};

acc_reg: OPC_I4ADD(acc_reg,OPC_I4MPY(areg,areg)) ?
{ 
  if (!xt_mac16 || !WN_Mpy_16Bit($3))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype($4)) || MTYPE_is_unsigned(WN_rtype($5)))
    NO_MATCH;
  return MAC16_arg_cost($4, $5, &($cost[0]), $cost[2].cost + 1);
}
{
  $action[2](0,ops);
  Generate_MAC16("mula.aa.ll", $4, $5, ops);
  return;
};

acc_reg: OPC_I4ADD(OPC_I4MPY(areg,areg),acc_reg) ?
{ 
  if (!xt_mac16 || !WN_Mpy_16Bit($2))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype($3)) || MTYPE_is_unsigned(WN_rtype($4)))
    NO_MATCH;
  return MAC16_arg_cost($3, $4, &($cost[0]), $cost[5].cost + 1);
}
{
  $action[5](0,ops);
  Generate_MAC16("mula.aa.ll", $3, $4, ops);
  return;
};

acc_reg: OPC_U4ADD(acc_reg,OPC_I4MPY(areg,areg)) ?
{ 
  if (!xt_mac16 || !WN_Mpy_16Bit($3))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype($4)) || MTYPE_is_unsigned(WN_rtype($5)))
    NO_MATCH;
  return MAC16_arg_cost($4, $5, &($cost[0]), $cost[2].cost + 1);
}
{
  $action[2](0,ops);
  Generate_MAC16("mula.aa.ll", $4, $5, ops);
  return;
};

acc_reg: OPC_U4ADD(OPC_I4MPY(areg,areg),acc_reg) ?
{ 
  if (!xt_mac16 || !WN_Mpy_16Bit($2))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype($3)) || MTYPE_is_unsigned(WN_rtype($4)))
    NO_MATCH;
  return MAC16_arg_cost($3, $4, &($cost[0]), $cost[5].cost + 1);
}
{
  $action[5](0,ops);
  Generate_MAC16("mula.aa.ll", $3, $4, ops);
  return;
};

acc_reg: OPC_I4SUB(acc_reg,OPC_I4MPY(areg,areg)) ?
{ 
  if (!xt_mac16 || !WN_Mpy_16Bit($3))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype($4)) || MTYPE_is_unsigned(WN_rtype($5)))
    NO_MATCH;
  return MAC16_arg_cost($4, $5, &($cost[0]), $cost[2].cost + 1);
}
{
  $action[2](0,ops);
  Generate_MAC16("muls.aa.ll", $4, $5, ops);
  return;
};

acc_reg: OPC_U4SUB(acc_reg,OPC_I4MPY(areg,areg)) ?
{ 
  if (!xt_mac16 || !WN_Mpy_16Bit($3))
    NO_MATCH;
  if (MTYPE_is_unsigned(WN_rtype($3)) || MTYPE_is_unsigned(WN_rtype($4)))
    NO_MATCH;
  return MAC16_arg_cost($4, $5, &($cost[0]), $cost[2].cost + 1);
}
{
  $action[2](0,ops);
  Generate_MAC16("muls.aa.ll", $4, $5, ops);
  return;
};

//===========================================================================
//
// Bit insert and extract
//
//===========================================================================

// compose_bits

areg: OPC_I4COMPOSE_BITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 4; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Compose($0, MTYPE_I4, MTYPE_I4, result, tn2, tn3, ops);
};

areg: OPC_U4COMPOSE_BITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 4; }
{
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_Compose($0, MTYPE_U4, MTYPE_U4, result, tn2, tn3, ops);
};

// extract_bits

areg: OPC_I4EXTRACT_BITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Extract($0, MTYPE_I4, MTYPE_I4, result, $action[2](0, ops), ops);
};

areg: OPC_U4EXTRACT_BITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Extract($0, MTYPE_U4, MTYPE_U4, result, $action[2](0, ops), ops);
};

// stbits

areg: OPC_U4STBITS( areg ) && is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st($0), WN_store_offset($0));
  return Generate_Compose($0, Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4),
			  MTYPE_U4, result, result, $action[2](0, ops), ops); 
};

areg: OPC_U2STBITS( areg ) && is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st($0), WN_store_offset($0));
  return Generate_Compose($0, Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4),
			  MTYPE_U2, result, result, $action[2](0, ops), ops); 
};

areg: OPC_U1STBITS( areg ) && is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st($0), WN_store_offset($0));
  return Generate_Compose($0, Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4),
			  MTYPE_U1, result, result, $action[2](0, ops), ops); 
};

areg: OPC_I4STBITS( areg ) && is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st($0), WN_store_offset($0));
  return Generate_Compose($0, Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4),
			  MTYPE_U4, result, result, $action[2](0, ops), ops); 
};

areg: OPC_I2STBITS( areg ) && is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st($0), WN_store_offset($0));
  return Generate_Compose($0, Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4),
			  MTYPE_U2, result, result, $action[2](0, ops), ops); 
};

areg: OPC_I1STBITS( areg ) && is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  result = PREG_To_TN(WN_st($0), WN_store_offset($0));
  return Generate_Compose($0, Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4),
			  MTYPE_U1, result, result, $action[2](0, ops), ops); 
};

areg: OPC_U4STBITS( areg ) && !is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory($0, rtype, MTYPE_U4, 0,
				    WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  TN *comped = Generate_Compose($0, rtype, MTYPE_U4, 0, src_tn, $action[2](0, ops), ops);
  Generate_Store_Memory($0, MTYPE_U4, comped, WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  return comped;
};

areg: OPC_U2STBITS( areg ) && !is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory($0, rtype, MTYPE_U2, 0,
				    WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  TN *comped = Generate_Compose($0, rtype, MTYPE_U2, 0, src_tn, $action[2](0, ops), ops);
  Generate_Store_Memory($0, MTYPE_U2, comped, WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  return comped;
};

areg: OPC_U1STBITS( areg ) && !is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory($0, rtype, MTYPE_U1, 0,
				    WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  TN *comped = Generate_Compose($0, rtype, MTYPE_U1, 0, src_tn, $action[2](0, ops), ops);
  Generate_Store_Memory($0, MTYPE_U1, comped, WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  return comped;
};

areg: OPC_I4STBITS( areg ) && !is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory($0, rtype, MTYPE_U4, 0,
				    WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  TN *comped = Generate_Compose($0, rtype, MTYPE_U4, 0, src_tn, $action[2](0, ops), ops);
  Generate_Store_Memory($0, MTYPE_U4, comped, WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  return comped;
};

areg: OPC_I2STBITS( areg ) && !is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory($0, rtype, MTYPE_U2, 0,
				    WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  TN *comped = Generate_Compose($0, rtype, MTYPE_U2, 0, src_tn, $action[2](0, ops), ops);
  Generate_Store_Memory($0, MTYPE_U2, comped, WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  return comped;
};

areg: OPC_I1STBITS( areg ) && !is_preg ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TYPE_ID rtype = Mtype_TransferSize(WN_rtype(WN_kid0($0)), MTYPE_U4);
  TN *src_tn = Generate_Load_Memory($0, rtype, MTYPE_U1, 0,
				    WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  TN *comped = Generate_Compose($0, rtype, MTYPE_U1, 0, src_tn, $action[2](0, ops), ops);
  Generate_Store_Memory($0, MTYPE_U1, comped, WN_st($0), WN_load_offset($0), Variant_STID($0), ops);
  return comped;
};

// istbits

areg: OPC_U4ISTBITS( areg, OPC_U4LDA ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits($0, MTYPE_U4, MTYPE_U4, $action[2](0, ops), ops);
};

areg: OPC_U2ISTBITS( areg, OPC_U4LDA ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits($0, MTYPE_U2, MTYPE_U2, $action[2](0, ops), ops);
};

areg: OPC_U1ISTBITS( areg, OPC_U4LDA ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits($0, MTYPE_U1, MTYPE_U1, $action[2](0, ops), ops);
};

areg: OPC_I4ISTBITS( areg, OPC_U4LDA ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits($0, MTYPE_U4, MTYPE_U4, $action[2](0, ops), ops);
};

areg: OPC_I2ISTBITS( areg, OPC_U4LDA ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits($0, MTYPE_U2, MTYPE_U2, $action[2](0, ops), ops);
};

areg: OPC_I1ISTBITS( areg, OPC_U4LDA ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  return Generate_IStoreLda_Bits($0, MTYPE_U1, MTYPE_U1, $action[2](0, ops), ops);
};

areg: OPC_U4ISTBITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = $action[3](0,ops);
  TN * tn2  =$action[2](0,ops); 
  return Generate_IStore_Bits($0, MTYPE_U4, MTYPE_U4,
			      tn2, tn3, ops);
};

areg: OPC_U2ISTBITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_IStore_Bits($0, MTYPE_U2, MTYPE_U2,
			      tn2, tn3, ops);
};

areg: OPC_U1ISTBITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_IStore_Bits($0, MTYPE_U1, MTYPE_U1,
			      tn2, tn3, ops);
};

areg: OPC_I4ISTBITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_IStore_Bits($0, MTYPE_U4, MTYPE_U4,
			      tn2, tn3, ops);
};

areg: OPC_I2ISTBITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_IStore_Bits($0, MTYPE_U2, MTYPE_U2,
			      tn2, tn3, ops);
};

areg: OPC_I1ISTBITS( areg, areg ) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN * tn3 = $action[3](0,ops);
  TN * tn2 = $action[2](0,ops); 
  return Generate_IStore_Bits($0, MTYPE_U1, MTYPE_U1,
			      tn2, tn3, ops);
};

// ldbits

areg: OPC_U4U4LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_U4U2LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_U4U1LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_U4I4LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_U4I2LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_U4I1LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_I4U4LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_I4U2LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_I4U1LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_I4I4LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_I4I2LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_I4I1LDBITS && is_preg ?
{ $cost[0].cost = 1; }
{
  TN *src_tn = PREG_To_TN(WN_st($0), WN_load_offset($0));
  return Generate_Extract($0, WN_rtype($0), WN_desc($0), result, src_tn, ops);
};

areg: OPC_U4U4LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_U4, MTYPE_U4, result, src_tn, ops);
};

areg: OPC_U4U2LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_U4, MTYPE_U4, result, src_tn, ops);
};

areg: OPC_U4U1LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_U4, MTYPE_U4, result, src_tn, ops);
};

areg: OPC_U4I4LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_U4, MTYPE_I4, result, src_tn, ops);
};

areg: OPC_U4I2LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_I4, MTYPE_I2, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_U4, MTYPE_I4, result, src_tn, ops);
};

areg: OPC_U4I1LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  /* Load as unsigned and let Generate_Extract do the sign extension. */
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_U4, MTYPE_I1, result, src_tn, ops);
};

areg: OPC_I4U4LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U4, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_I4, MTYPE_U4, result, src_tn, ops);
};

areg: OPC_I4U2LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_I4, MTYPE_U4, result, src_tn, ops);
};

areg: OPC_I4U1LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_I4, MTYPE_U4, result, src_tn, ops);
};

areg: OPC_I4I4LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_I4, MTYPE_I4, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_I4, MTYPE_I4, result, src_tn, ops);
};

areg: OPC_I4I2LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  TN *src_tn = Generate_Load_Memory($0, MTYPE_I4, MTYPE_I2, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_I4, MTYPE_I4, result, src_tn, ops);
};

areg: OPC_I4I1LDBITS && !is_preg ?
{ $cost[0].cost = 2; }
{
  /* Load as unsigned and let Generate_Extract do the sign extension. */
  TN *src_tn = Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, 0,
				    WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
  return Generate_Extract($0, MTYPE_I4, MTYPE_I1, result, src_tn, ops);
};

// ildbits

areg: OPC_U4U4ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_U4, MTYPE_U4, result, ops);
};

areg: OPC_U4U2ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_U4, MTYPE_U2, result, ops);
};

areg: OPC_U4U1ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_U4, MTYPE_U1, result, ops);
};

areg: OPC_U4I4ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_U4, MTYPE_I4, result, ops);
};

areg: OPC_U4I2ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_U4, MTYPE_I2, result, ops);
};

areg: OPC_U4I1ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_U4, MTYPE_I1, result, ops);
};

areg: OPC_I4U4ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_I4, MTYPE_U4, result, ops);
};

areg: OPC_I4U2ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_I4, MTYPE_U2, result, ops);
};

areg: OPC_I4U1ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_I4, MTYPE_U1, result, ops);
};

areg: OPC_I4I4ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_I4, MTYPE_I4, result, ops);
};

areg: OPC_I4I2ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_I4, MTYPE_I2, result, ops);
};

areg: OPC_I4I1ILDBITS( OPC_U4LDA ) ?
{ $cost[0].cost = 2; }
{
  return Generate_ILoadLda_Bits($0, MTYPE_I4, MTYPE_I1, result, ops);
};

areg: OPC_U4U4ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_U4, MTYPE_U4, result, $action[2](0, ops), ops);
};

areg: OPC_U4U2ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_U4, MTYPE_U2, result, $action[2](0, ops), ops);
};

areg: OPC_U4U1ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_U4, MTYPE_U1, result, $action[2](0, ops), ops);
};

areg: OPC_U4I4ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_U4, MTYPE_I4, result, $action[2](0, ops), ops);
};

areg: OPC_U4I2ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_U4, MTYPE_I2, result, $action[2](0, ops), ops);
};

areg: OPC_U4I1ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_U4, MTYPE_I1, result, $action[2](0, ops), ops);
};

areg: OPC_I4U4ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_I4, MTYPE_U4, result, $action[2](0, ops), ops);
};

areg: OPC_I4U2ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_I4, MTYPE_U2, result, $action[2](0, ops), ops);
};

areg: OPC_I4U1ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_I4, MTYPE_U1, result, $action[2](0, ops), ops);
};

areg: OPC_I4I4ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_I4, MTYPE_I4, result, $action[2](0, ops), ops);
};

areg: OPC_I4I2ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_I4, MTYPE_I2, result, $action[2](0, ops), ops);
};

areg: OPC_I4I1ILDBITS( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_ILoad_Bits($0, MTYPE_I4, MTYPE_I1, result, $action[2](0, ops), ops);
};


//===========================================================================
//
// CVTL rules
//
//===========================================================================

areg: OPC_U4CVTL( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Extend(MTYPE_U4, result, $action[2](0,ops),
			 WN_cvtl_bits($0), ops);
};

areg: OPC_I4CVTL( areg ) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Extend(MTYPE_I4, result, $action[2](0,ops),
			 WN_cvtl_bits($0), ops);
};

// rules where CVTL is unnecessary

areg: OPC_U4CVTL( areg ) && is_nop_cvtl ?
{ $cost[0].cost = $cost[2].cost; }
{
  return $action[2](result,ops);
};

areg: OPC_I4CVTL( areg ) && is_nop_cvtl ?
{ $cost[0].cost = $cost[2].cost; }
{
  return $action[2](result,ops);
};


//===========================================================================
//
// CVT rules
//
//===========================================================================

areg: OPC_I4U4CVT (areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  return $action[2](result, ops);
};

areg: OPC_U4I4CVT (areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  return $action[2](result, ops);
};


//===========================================================================
//
// Register -> register rules
//
//===========================================================================

sar_left: areg ?
{ $cost[0].cost = $cost[1].cost + 1; }
{
  TN *ar = $action[1](0, ops);
  TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
  Build_OP(TOP_ssl, sar, ar, ops );
  return sar;
};

sar_right: areg ?
{ $cost[0].cost = $cost[1].cost + 1; }
{
  TN *ar = $action[1](0, ops);
  TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
  Build_OP(TOP_ssr, sar, ar, ops );
  return sar;
};

wsar: areg ?
{ $cost[0].cost = $cost[1].cost + 1; }
{
  TN *ar = $action[1](0, ops);
  TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
  Build_OP(TI_TOP_Topcode("wsr.sar"), sar, xtsync_tn(), ar, ops);
  return sar;
};

// not safe when the shift amount is 0 or 32
//sar_right: OPC_I4SUB(thirtytwo, areg) ?
//{ $cost[0].cost = $cost[3].cost + 1; }
//{
//    TN *ar = $action[3](0, ops);
//    TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
//    Build_OP(TOP_ssl, sar, ar, ops);
//    return sar;
//};
//
//sar_right: OPC_U4SUB(thirtytwo, areg) ?
//{ $cost[0].cost = $cost[3].cost + 1; }
//{
//    TN *ar = $action[3](0, ops);
//    TN *sar = Build_Dedicated_TN(REGISTER_CLASS_sar, REGISTER_sar, 4);
//    Build_OP(TOP_ssl, sar, ar, ops);
//    return sar;
//};
//
    
areg: OPC_TN && is_preg && !is_tie_tn ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

tie_reg: OPC_TN && is_preg && is_tie_tn ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

breg: OPC_TN && is_preg && is_xtbool_tn ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

acc_reg: areg ?
{   
  if (!xt_mac16)
    NO_MATCH;
  $cost[0].cost = $cost[1].cost + 1; 
}
{ 
  TN *ar = $action[1](0, ops);
  Build_OP(TI_TOP_Topcode("wsr.acclo"), accum_tn(), ar, accum_tn(), ops );
  return;
};

areg: acc_reg ?
{ 
  if (!xt_mac16)
    NO_MATCH;

  if (TI_ISA_Prefer_MUL16())
    $cost[0].cost = $cost[1].cost + 100; 
  else
    $cost[0].cost = $cost[1].cost + 1; 
}
{
  if (!result)
  {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  $action[1](0, ops);
  Build_OP(TI_TOP_Topcode("rsr.acclo"), result, accum_tn(), ops );
  return result;
};
    

freg: OPC_TN && is_preg && is_float_tn ?
{ $cost[0].cost = 0; }
{ 
  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  return WN_tn($0); 
};

freg: areg ?
{
  if (!xt_hard_float)
    NO_MATCH;

  $cost[0].cost = $cost[1].cost + 1;
}
{
  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  TN *ar = $action[1](0, ops);

  result = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), result, ar, ops);
  return result;
};

areg: freg ?
{
  if (!xt_hard_float)
    NO_MATCH;

  $cost[0].cost = $cost[1].cost + 1;
}
{
  FmtAssert(xt_hard_float, ("Float TN requires FP coprocessor"));
  TN *fr = $action[1](0, ops);
  result = Generate_Unary_FP(MTYPE_I4, TI_TOP_Topcode("rfr"), result, fr, ops);
  return result;
};


//===========================================================================
//
// Literal -> register rules
//
//===========================================================================

areg: simm12 ?
{ $cost[0].cost = $cost[1].cost + 1; }
{
  TN *val = $action[1]();
  return Generate_Constant(MTYPE_I4, result, TN_value(val), ops);
};

areg: simm32 ?
{ $cost[0].cost = $cost[1].cost + 1; }
{
  TN *val = $action[1]();
  return Generate_Constant(MTYPE_I4, result, TN_value(val), ops);
};

areg: float_const ?
{ $cost[0].cost = $cost[1].cost + 1; }
{
  INT32 val = $action[1]();
  if (result && xt_hard_float && TN_register_class(result)==TI_ISA_Regclass_Float()) {

    // destination is a floating point register

    TN *tmp = Build_TN_Of_Mtype(MTYPE_U4);
    tmp = Generate_Constant(MTYPE_U4, tmp, val, ops);

    result = Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), result, tmp, ops);
    return result;
  } else 
    return Generate_Constant(MTYPE_U4, result, val, ops);
};

areg_or_simm12: areg ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1](0, ops);
};

areg_or_simm12: simm12 ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1]();
};

areg_or_simm8: areg ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1](0, ops);
};

areg_or_simm8: simm8 ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1]();
};

areg_or_b4const: areg ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1](0, ops);
};

areg_or_b4const: b4const ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1]();
};

areg_or_b4constu: areg ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1](0, ops);
};

areg_or_b4constu: b4constu ?
{ $cost[0].cost = $cost[1].cost; }
{
  return $action[1]();
};

//===========================================================================
//
// Literal rules
//
//===========================================================================

// zero 
zero: OPC_I4INTCONST && is_zero ?
{ $cost[0].cost = 0; }
{ return; };

zero: OPC_U4INTCONST && is_zero ?
{ $cost[0].cost = 0; }
{ return; };

// one 
one: OPC_I4INTCONST && is_one ?
{ $cost[0].cost = 0; }
{ return; };

one: OPC_U4INTCONST && is_one ?
{ $cost[0].cost = 0; }
{ return; };

one: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_one(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{ return; };

one: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_one(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{ return; };

// thirtytwo
thirtytwo: OPC_I4INTCONST && is_thirtytwo ?
{ $cost[0].cost = 0; }
{ return; };

thirtytwo: OPC_U4INTCONST && is_thirtytwo ?
{ $cost[0].cost = 0; }
{ return; };

thirtytwo: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_thirtytwo(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{ return; };

one: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_thirtytwo(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{ return; };

// float_const 
float_const: OPC_F4CONST ?
{ $cost[0].cost = 1; }
{
  ST *s = WN_st($0);
  union {
    INT32 ii;
    float ff;
  } float_to_int_bytes;
  float_to_int_bytes.ff = TCON_R4(STC_val(s));

  return float_to_int_bytes.ii;
};

// extui_mask
extui_mask: OPC_I4INTCONST && is_extui_mask ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

extui_mask: OPC_U4INTCONST && is_extui_mask ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

extui_mask: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_extui_mask(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

extui_mask: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_extui_mask(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// bbci_bbsi_imm
bbci_bbsi_imm: OPC_I4INTCONST && is_bbci_bbsi_imm ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

bbci_bbsi_imm: OPC_U4INTCONST && is_bbci_bbsi_imm ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

bbci_bbsi_imm: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_bbci_bbsi_imm(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

bbci_bbsi_imm: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_bbci_bbsi_imm(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// logical_and_immed
logical_and_immed: OPC_I4INTCONST && (is_extui_shift_mask || is_bbci_bbsi_imm) ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

logical_and_immed: OPC_U4INTCONST && (is_extui_shift_mask || is_bbci_bbsi_imm) ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

logical_and_immed: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || (!is_extui_shift_mask(lit) && !is_bbci_bbsi_imm(lit)))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

logical_and_immed: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || (!is_extui_shift_mask(lit) && !is_bbci_bbsi_imm(lit)))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// PR 5643:
// if (a & (1 << b)) goto L
// ------------------------
// bbs a, b, L

logical_and_immed: OPC_I4SHL (one, areg) ?
{ 
  $cost[0].cost = $cost[3].cost; 
}
{ 
  return $action[3](0, ops);
};

logical_and_immed: OPC_U4SHL (one, areg) ?
{ 
  $cost[0].cost = $cost[3].cost; 
}
{ 
  return $action[3](0, ops);
};

// clamps_const
clamps_const: OPC_I4INTCONST && is_clamps_const ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

clamps_const: OPC_U4INTCONST && is_clamps_const ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

clamps_const: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_clamps_const(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

clamps_const: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_clamps_const(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// simm8x256 
simm8x256: OPC_I4INTCONST && is_simm8x256 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm8x256: OPC_U4INTCONST && is_simm8x256 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm8x256: OPC_TN && is_simm8x256 ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

simm8x256: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_simm8x256(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

simm8x256: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_simm8x256(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// simm4 
//simm4: OPC_I4INTCONST && is_simm4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//simm4: OPC_U4INTCONST && is_simm4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//simm4: OPC_TN && is_simm4 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// simm7 
//simm7: OPC_I4INTCONST && is_simm7 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//simm7: OPC_U4INTCONST && is_simm7 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//simm7: OPC_TN && is_simm7 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// simm8 
simm8: OPC_I4INTCONST && is_simm8 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm8: OPC_U4INTCONST && is_simm8 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm8: OPC_TN && is_simm8 ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

simm8: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_simm8(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

simm8: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_simm8(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// simm12
// we don't have the preg-equivalent-to-literal rules because
// simm12's require a movi, and if we have a preg then the movi has
// already been performed, presumedly at a more favorable location
// (e.g. outside the loop).
simm12: OPC_I4INTCONST && is_simm12 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm12: OPC_U4INTCONST && is_simm12 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm12: OPC_TN && is_simm12 ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

// simm16 
//simm16: OPC_I4INTCONST && is_simm16 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//simm16: OPC_U4INTCONST && is_simm16 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//simm16: OPC_TN && is_simm16 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// simm32 
// we don't have the preg-equivalent-to-literal rules because
// simm32's require a load constant, and if we have a preg 
// then it has already been performed, presumedly at a more 
// favorable location
// (e.g. outside the loop).
simm32: OPC_I4INTCONST && is_simm32 ?
{ $cost[0].cost = 1; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm32: OPC_U4INTCONST && is_simm32 ?
{ $cost[0].cost = 1; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

simm32: OPC_TN && is_simm32 ?
{ $cost[0].cost = 1; }
{ return WN_tn($0); };

// tie_imm
tie_imm: OPC_I4INTCONST ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

tie_imm: OPC_U4INTCONST ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

tie_imm: OPC_TN ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

expr: tie_imm ?
{ $cost[0] = COST_INFINITY; }
{ 
  FmtAssert(0,("Should never reach here"));
  return 0;
};

// uimm12x8 
//uimm12x8: OPC_I4INTCONST && is_uimm12x8 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm12x8: OPC_U4INTCONST && is_uimm12x8 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm12x8: OPC_TN && is_uimm12x8 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// uimm16x4 
//uimm16x4: OPC_I4INTCONST && is_uimm16x4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm16x4: OPC_U4INTCONST && is_uimm16x4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm16x4: OPC_TN && is_uimm16x4 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// uimm4 
uimm4: OPC_I4INTCONST && is_uimm4 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

uimm4: OPC_U4INTCONST && is_uimm4 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

uimm4: OPC_TN && is_uimm4 ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

uimm4: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_uimm4(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

uimm4: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_uimm4(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// uimm5 
uimm5: OPC_I4INTCONST && is_uimm5 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

uimm5: OPC_U4INTCONST && is_uimm5 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

uimm5: OPC_TN && is_uimm5 ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

uimm5: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_uimm5(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

uimm5: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_uimm5(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// uimm8 
//uimm8: OPC_I4INTCONST && is_uimm8 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm8: OPC_U4INTCONST && is_uimm8 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm8: OPC_TN && is_uimm8 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// uimm8x2 
//uimm8x2: OPC_I4INTCONST && is_uimm8x2 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm8x2: OPC_U4INTCONST && is_uimm8x2 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm8x2: OPC_TN && is_uimm8x2 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// uimm8x4 
//uimm8x4: OPC_I4INTCONST && is_uimm8x4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm8x4: OPC_U4INTCONST && is_uimm8x4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//uimm8x4: OPC_TN && is_uimm8x4 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// ai4const 
//ai4const: OPC_I4INTCONST && is_ai4const ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//ai4const: OPC_U4INTCONST && is_ai4const ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//ai4const: OPC_TN && is_ai4const ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// b4constu 
b4constu: OPC_I4INTCONST && is_b4constu ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

b4constu: OPC_U4INTCONST && is_b4constu ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

b4constu: OPC_TN && is_b4constu ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

b4constu: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_b4constu(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

b4constu: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_b4constu(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// b4const 
b4const: OPC_I4INTCONST && is_b4const ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

b4const: OPC_U4INTCONST && is_b4const ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

b4const: OPC_TN && is_b4const ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

b4const: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_b4const(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

b4const: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_b4const(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

// lsi4x4 
//lsi4x4: OPC_I4INTCONST && is_lsi4x4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//lsi4x4: OPC_U4INTCONST && is_lsi4x4 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//lsi4x4: OPC_TN && is_lsi4x4 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// op2p1 
//op2p1: OPC_I4INTCONST && is_op2p1 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//op2p1: OPC_U4INTCONST && is_op2p1 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//op2p1: OPC_TN && is_op2p1 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// tp7 
//tp7: OPC_I4INTCONST && is_tp7 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//tp7: OPC_U4INTCONST && is_tp7 ?
//{ $cost[0].cost = 0; }
//{
//  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
//};
//
//tp7: OPC_TN && is_tp7 ?
//{ $cost[0].cost = 0; }
//{ return WN_tn($0); };

// msalp32 
msalp32: OPC_I4INTCONST && is_msalp32 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

msalp32: OPC_U4INTCONST && is_msalp32 ?
{ $cost[0].cost = 0; }
{
  return Gen_Literal_TN( (INT32) WN_const_val($0), 4 );
};

msalp32: OPC_TN && is_msalp32 ?
{ $cost[0].cost = 0; }
{ return WN_tn($0); };

msalp32: OPC_I4I4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_msalp32(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};

msalp32: OPC_U4U4LDID ?
{
  WN *lit = preg_equivalent_literal($1);
  if (!lit || !is_msalp32(lit))
    NO_MATCH;
  
  $cost[0].cost = 0;
}
{
  WN *lit = preg_equivalent_literal($1);
  FmtAssert(lit, ("expecting preg equivalent to literal"));
  return Gen_Literal_TN( (INT32) WN_const_val(lit), 4 );
};


//=============================================================================
//
// Rules for XTBOOL types
//
//=============================================================================

// xtbool LDIDs that can use direct moves

b1reg: OPC_XTBOOLXTBOOLLDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_XTBOOL,result,PREG_To_TN(s,o),ops);
};

breg: OPC_XTBOOL2XTBOOL2LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_XTBOOL2,result,PREG_To_TN(s,o),ops);
};

breg: OPC_XTBOOL4XTBOOL4LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_XTBOOL4,result,PREG_To_TN(s,o),ops);
};

breg: OPC_XTBOOL8XTBOOL8LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_XTBOOL8,result,PREG_To_TN(s,o),ops);
};

breg: OPC_XTBOOL16XTBOOL16LDID &&  is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_load_offset($0);
  return Move_To_Register(MTYPE_XTBOOL16,result,PREG_To_TN(s,o),ops);
};

// xtbool LDIDs that might be able to use direct loadi macro

breg: OPC_XTBOOLXTBOOLLDID && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

breg: OPC_XTBOOL2XTBOOL2LDID && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

breg: OPC_XTBOOL4XTBOOL4LDID && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

breg: OPC_XTBOOL8XTBOOL8LDID && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

breg: OPC_XTBOOL16XTBOOL16LDID && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

b1reg: OPC_XTBOOLI4CVT(b1reg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = val;
  } else {
    Build_OP(TOP_movbr, result, val, ops);
  }
  return result;
};


// xtbool LDIDs that have to go through AR using core instructions

bareg: OPC_XTBOOLXTBOOLLDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

bareg: OPC_XTBOOL2XTBOOL2LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

bareg: OPC_XTBOOL4XTBOOL4LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

bareg: OPC_XTBOOL8XTBOOL8LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

bareg: OPC_XTBOOL16XTBOOL16LDID && !is_preg ?
{ $cost[0].cost = 1; }
{
  Check_For_Dedicated_Preg($0);
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, result,
			      WN_st($0), WN_load_offset($0), Variant_LDID($0), ops);
};

bareg: breg ?
{ $cost[0].cost = $cost[1].cost + 2; }
{
  TN *br = $action[1](0, ops);
  if( !result )
    result = Build_TN_Of_Mtype(MTYPE_U4);
  TYPE_ID rtype = TN_mtype(br);
  TOP top = (rtype == MTYPE_XTBOOL) ? TOP_br_to_ar :
	    (rtype == MTYPE_XTBOOL2) ? TOP_br2_to_ar :
	    (rtype == MTYPE_XTBOOL4) ? TOP_br4_to_ar :
	    (rtype == MTYPE_XTBOOL8) ? TOP_br8_to_ar :
	    (rtype == MTYPE_XTBOOL16) ? TOP_br16_to_ar : TOP_UNDEFINED;
  FmtAssert(top!=TOP_UNDEFINED,("Unknown rtype"));
  Build_OP(top, result, br, ops );
  return result;
};

breg: b1reg ?
{
  if (WN_rtype($1)!=MTYPE_XTBOOL)
    NO_MATCH;
  $cost[0].cost = $cost[1].cost;
}
{
  result = $action[1](result, ops);
  return result;
};

b1reg: bareg ?
{
  if (WN_rtype($0)!=MTYPE_XTBOOL)
    NO_MATCH;
  $cost[0].cost = $cost[1].cost + 10;
}
{
  TN *ar = $action[1](0, ops);
  if( !result )
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
  TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_get_tmp_ar, tmp1, ops );
  Build_OP(TOP_get_tmp_ar, tmp2, ops );
  Build_OP(TOP_ar_to_br, result, ar, tmp1, tmp2, ops );
  return result;
};

breg: bareg ?
{
  $cost[0].cost = $cost[1].cost + 10;
}
{
  TN *ar = $action[1](0, ops);
  TYPE_ID rtype = WN_rtype($0);
  if( !result )
    result = Build_TN_Of_Mtype(rtype);
  else
    FmtAssert(TN_mtype(result)==rtype, ("xtbool type mismatch"));
  TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
  TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_get_tmp_ar, tmp1, ops );
  Build_OP(TOP_get_tmp_ar, tmp2, ops );
  TOP top = (rtype == MTYPE_XTBOOL) ? TOP_ar_to_br :
		(rtype == MTYPE_XTBOOL2) ? TOP_ar_to_br2 :
		(rtype == MTYPE_XTBOOL4) ? TOP_ar_to_br4 :
		(rtype == MTYPE_XTBOOL8) ? TOP_ar_to_br8 :
		(rtype == MTYPE_XTBOOL16) ? TOP_ar_to_br16 : TOP_UNDEFINED;
  FmtAssert(top!=TOP_UNDEFINED,("Unknown rtype"));
  Build_OP(top, result, ar, tmp1, tmp2, ops );
  return result;
};

// xtbool STIDs that can use direct moves

expr: OPC_XTBOOLSTID(b1reg) && is_preg ?
{ 
  if (WN_st($0)!=MTYPE_To_PREG(MTYPE_XTBOOL))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost+1;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = $action[2](0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;
};

expr: OPC_XTBOOL2STID(breg) && is_preg ?
{ 
  if (WN_st($0)!=MTYPE_To_PREG(MTYPE_XTBOOL2))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost+2;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = $action[2](0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL2 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr2, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;
};

expr: OPC_XTBOOL4STID(breg) && is_preg ?
{ 
  if (WN_st($0)!=MTYPE_To_PREG(MTYPE_XTBOOL4))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost+4;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = $action[2](0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL4 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr4, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;
};

expr: OPC_XTBOOL8STID(breg) && is_preg ?
{ 
  if (WN_st($0)!=MTYPE_To_PREG(MTYPE_XTBOOL8))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost+6;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = $action[2](0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL8 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
  TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
  Build_OP(TOP_get_tmp_ar, tmp1, ops );
  Build_OP(TOP_get_tmp_ar, tmp2, ops );
  Build_OP(TOP_movbr8, dst, src, tmp1, tmp2, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;
};

expr: OPC_XTBOOL16STID(breg) && is_preg ?
{ 
  if (WN_st($0)!=MTYPE_To_PREG(MTYPE_XTBOOL16))
    NO_MATCH;
  $cost[0].cost = $cost[2].cost;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *src = $action[2](0, ops);
  FmtAssert(TN_mtype(dst)==MTYPE_XTBOOL16 || TN_is_dedicated(dst),
	    ("Expecting xtbool result"));
  Build_OP(TOP_movbr16, dst, src, ops );
  Set_OP_copy (OPS_last(ops));
  return dst;
};

// xtbool STIDs that cannot use direct moves and have to go through areg

expr: OPC_XTBOOLSTID(bareg) && is_preg ?
{
  if (WN_st($0)==MTYPE_To_PREG(MTYPE_XTBOOL))
    $cost[0].cost = $cost[2].cost+7;
  else
    $cost[0].cost = $cost[2].cost+1;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = $action[2](0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;
};

expr: OPC_XTBOOL2STID(bareg) && is_preg ?
{
  if (WN_st($0)==MTYPE_To_PREG(MTYPE_XTBOOL2))
    $cost[0].cost = $cost[2].cost+7;
  else
    $cost[0].cost = $cost[2].cost+1;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = $action[2](0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br2, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;
};

expr: OPC_XTBOOL4STID(bareg) && is_preg ?
{
  if (WN_st($0)==MTYPE_To_PREG(MTYPE_XTBOOL4))
    $cost[0].cost = $cost[2].cost+7;
  else
    $cost[0].cost = $cost[2].cost+1;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = $action[2](0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br4, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;
};

expr: OPC_XTBOOL8STID(bareg) && is_preg ?
{
  if (WN_st($0)==MTYPE_To_PREG(MTYPE_XTBOOL8))
    $cost[0].cost = $cost[2].cost+7;
  else
    $cost[0].cost = $cost[2].cost+1;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = $action[2](0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br8, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;
};

expr: OPC_XTBOOL16STID(bareg) && is_preg ?
{
  if (WN_st($0)==MTYPE_To_PREG(MTYPE_XTBOOL16))
    $cost[0].cost = $cost[2].cost+7;
  else
    $cost[0].cost = $cost[2].cost+1;
}
{
  Check_For_Dedicated_Preg($0);
  ST *s = WN_st($0);
  INT64 o = WN_store_offset($0);
  TN *dst = PREG_To_TN(s,o);
  Is_True( result==0, ("Requesting result from store"));
  TN *ar = $action[2](0, ops);
  if (MTYPE_is_xtbool(TN_mtype(dst))) {
    TN* tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
    TN* tmp2 = Build_TN_Of_Mtype(MTYPE_U4);
    Build_OP(TOP_get_tmp_ar, tmp1, ops );
    Build_OP(TOP_get_tmp_ar, tmp2, ops );
    Build_OP(TOP_ar_to_br16, dst, ar, tmp1, tmp2, ops );
  } else if (TN_is_dedicated(dst) &&
	      TN_register_class(dst)==TI_ISA_Regclass_Integer()) {
    Build_OP(TOP_mov_n, dst, ar, ops );
  } else {
    FmtAssert(0, ("Expecting xtbool result"));
  }
  return dst;
};

// xtbool STIDs that might be able to use direct storei macro

expr: OPC_XTBOOLSTID(breg) && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, WN_desc($0), val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL2STID(breg) && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, WN_desc($0), val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL4STID(breg) && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, WN_desc($0), val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL8STID(breg) && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, WN_desc($0), val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL16STID(breg) && !is_preg ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, WN_desc($0), val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

// xtbool STIDs that have to go through AR using core instructions

expr: OPC_XTBOOLSTID(bareg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U1, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL2STID(bareg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U1, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL4STID(bareg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U1, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL8STID(bareg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U1, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

expr: OPC_XTBOOL16STID(bareg) && !is_preg ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  Check_For_Dedicated_Preg($0);
  TN *val = $action[2](0,ops);
  Is_True( result==0, ("Requesting result from store"));
  Generate_Store_Memory( $0, MTYPE_U2, val, WN_st($0), WN_store_offset($0), Variant_STID($0), ops);
  return val;
};

// xtbool ILOADs that might be able to use direct loadi macro

breg: OPC_XTBOOLXTBOOLILOAD(areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

breg: OPC_XTBOOL2XTBOOL2ILOAD(areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

breg: OPC_XTBOOL4XTBOOL4ILOAD(areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

breg: OPC_XTBOOL8XTBOOL8ILOAD(areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

breg: OPC_XTBOOL16XTBOOL16ILOAD(areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_loadi_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  return Generate_Load_Memory($0, WN_rtype($0), WN_desc($0), result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

// xtbool ILOADs that have to go through AR using core instructions

bareg: OPC_XTBOOLXTBOOLILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

bareg: OPC_XTBOOL2XTBOOL2ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

bareg: OPC_XTBOOL4XTBOOL4ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

bareg: OPC_XTBOOL8XTBOOL8ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U1, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

bareg: OPC_XTBOOL16XTBOOL16ILOAD(areg) ?
{ $cost[0].cost = $cost[2].cost + 1; }
{
  return Generate_Load_Memory($0, MTYPE_U4, MTYPE_U2, result,
			      $action[2](0,ops), WN_offset($0), Variant_ILOAD($0), ops);
};

// xtbool ISTORES that might be able to use direct storei macro

expr: OPC_XTBOOLISTORE(breg,areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + $cost[3].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, WN_desc($0), val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL2ISTORE(breg,areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + $cost[3].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, WN_desc($0), val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL4ISTORE(breg,areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + $cost[3].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, WN_desc($0), val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL8ISTORE(breg,areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + $cost[3].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, WN_desc($0), val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL16ISTORE(breg,areg) ?
{
  TIE_MACRO_p macro = tie_info->mtype_storei_macro(WN_desc($0));
  if (macro && macro->num_instructions()!=0)
    $cost[0].cost = $cost[2].cost + $cost[3].cost + macro->num_instructions();
  else
    NO_MATCH;
}
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, WN_desc($0), val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

// xtbool ISTORES that have to go through AR using core instructions

expr: OPC_XTBOOLISTORE(bareg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U1, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL2ISTORE(bareg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U1, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL4ISTORE(bareg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U1, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL8ISTORE(bareg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U1, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

expr: OPC_XTBOOL16ISTORE(bareg,areg) ?
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
{
  Is_True( result==0, ("Requesting result from store"));
  TN *addr = $action[3](0,ops);
  TN *val = $action[2](0,ops);
  Generate_Store_Memory($0, MTYPE_U2, val, addr, WN_offset($0), Variant_ISTORE($0), ops );
  return val;
};

bareg: OPC_XTBOOLI4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 1;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL2I4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 2;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL4I4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 4;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL8I4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 8;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL16I4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 16;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

areg: OPC_I4XTBOOLCVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_I4XTBOOL2CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_I4XTBOOL4CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_I4XTBOOL8CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_I4XTBOOL16CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

bareg: OPC_XTBOOLU4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 1;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL2U4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 2;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL4U4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 4;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL8U4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 8;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

bareg: OPC_XTBOOL16U4CVT(areg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (!result) {
    result = Build_TN_Of_Mtype(MTYPE_U4);
  }
  UINT32 num_bits = 16;
  Build_OP(TOP_extui, result, val,
		Gen_Literal_TN(0,4), Gen_Literal_TN(num_bits,4), ops );
  return result;
};

areg: OPC_U4XTBOOLCVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_U4XTBOOL2CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_U4XTBOOL4CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_U4XTBOOL8CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

areg: OPC_U4XTBOOL16CVT(bareg) ?
{ $cost[0].cost = $cost[2].cost; }
{
  TN* val = $action[2](0,ops);
  if (result) {
    Build_OP(TOP_mov_n, result, val, ops );
    return result;
  } else {
    return val;
  }
};

//===========================================================================
//
// Xtbool logical rules
//
//===========================================================================

b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn5 = $action[5](0,ops);
  Build_OP(TOP_andb, result, tn3, tn5, ops );
  return result;
};

b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))) ?
{ $cost[0].cost = $cost[3].cost + $cost[6].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn6 = $action[6](0,ops);
  Build_OP(TOP_andbc, result, tn3, tn6, ops );
  return result;
};

b1reg: OPC_I4BAND(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn5 = $action[5](0,ops);
  Build_OP(TOP_andbc, result, tn3, tn5, ops );
  return result;
};

b1reg: OPC_I4BAND(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)), OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[4].cost + $cost[6].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn4 = $action[4](0,ops); 
  TN * tn6 = $action[6](0,ops);
  Build_OP(TOP_andbc, result, tn6, tn4, ops );
  return result;
};

b1reg: OPC_I4BAND(OPC_XTBOOLBNOT(b1reg), OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn5 = $action[5](0,ops);
  Build_OP(TOP_andbc, result, tn5, tn3, ops );
  return result;
};

b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn5 = $action[5](0,ops);
  Build_OP(TOP_orb, result, tn3, tn5, ops );
  return result;
};

b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg))) ?
{ $cost[0].cost = $cost[3].cost + $cost[6].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn6 = $action[6](0,ops);
  Build_OP(TOP_orbc, result, tn3, tn6, ops );
  return result;
};

b1reg: OPC_I4BIOR(OPC_I4XTBOOLCVT(b1reg),OPC_XTBOOLBNOT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn5 = $action[5](0,ops);
  Build_OP(TOP_orbc, result, tn3, tn5, ops );
  return result;
};

b1reg: OPC_I4BIOR(OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)), OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[4].cost + $cost[6].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn4 = $action[4](0,ops); 
  TN * tn6 = $action[6](0,ops);
  Build_OP(TOP_orbc, result, tn6, tn4, ops );
  return result;
};

b1reg: OPC_I4BIOR(OPC_XTBOOLBNOT(b1reg), OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops); 
  TN * tn5 = $action[5](0,ops);
  Build_OP(TOP_orbc, result, tn5, tn3, ops );
  return result;
};

b1reg: OPC_I4BXOR(OPC_I4XTBOOLCVT(b1reg),OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + $cost[5].cost + 1; }
{
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN * tn3 = $action[3](0,ops);
  TN * tn5 = $action[5](0,ops); 
  Build_OP(TOP_xorb, result, tn3, tn5, ops );
  return result;
};

b1reg: OPC_I4BNOT(OPC_I4XTBOOLCVT(b1reg)) ?
{ $cost[0].cost = $cost[3].cost + 2; }
{
  TN* zero = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* br = $action[3](0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  Build_OP(TOP_orbc, zero, br, br, ops );
  Build_OP(TOP_xorb, result, br, zero, ops );
  return result;
};

b1reg: OPC_XTBOOLBNOT(b1reg) ?
{ $cost[0].cost = $cost[2].cost + 2; }
{
  TN* zero = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  TN* br = $action[2](0,ops);
  if (!result)
    result = Build_TN_Of_Mtype(MTYPE_XTBOOL);
  Build_OP(TOP_orbc, zero, br, br, ops );
  Build_OP(TOP_xorb, result, br, zero, ops );
  return result;
};

stmt: OPC_XTBOOLCALL ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( $0, ABI_CALL, ops);
  return 0;
};

stmt: OPC_XTBOOL2CALL ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( $0, ABI_CALL, ops);
  return 0;
};

stmt: OPC_XTBOOL4CALL ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( $0, ABI_CALL, ops);
  return 0;
};

stmt: OPC_XTBOOL8CALL ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( $0, ABI_CALL, ops);
  return 0;
};

stmt: OPC_XTBOOL16CALL ?
{ $cost[0].cost = 1; }
{
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( $0, ABI_CALL, ops);
  return 0;
};

%%
static int trace;

/* ISEL_trace - print trace message for matching p; decrement trace */
static void ISEL_trace(NODEPTR p, int eruleno, int cost, int bestcost) {
	if (trace < 0)
		fprintf(stderr, "0x%x matched %s = %d with cost %d vs. %d\n", p,
			ISEL_string[eruleno], eruleno, cost, bestcost);
	else if (trace > 0 && cost < bestcost) {
		--trace;
		fprintf(stderr, "0x%x matched %s = %d with cost %d\n", p,
			ISEL_string[eruleno], eruleno, cost);
	}
}

/* dumpCover - print the matched cover for p */
static void dumpCover(NODEPTR p, int goalnt, int indent) {
	int eruleno = ISEL::rule(ISEL::STATE_LABEL(p), goalnt);
	short *nts = ISEL_nts[eruleno];
	NODEPTR kids[10];
	int i;

	for (i = 0; i < indent; i++)
		fprintf(stderr, " ");
	fprintf(stderr, "%s\n", ISEL_string[eruleno]);
	ISEL_kids(p, eruleno, kids);
	for (i = 0; nts[i]; i++)
		dumpCover(kids[i], nts[i], indent + 1);
}

MEM_POOL ISEL_Mem_Pool, ISEL_Map_Pool;
WN_MAP ISEL_State_Map;

//=============================================================================
//
// Utility functions to support the pattern matcher.
//
// add_op_info: associate an ISEL::Op_info data structure with the opcode opc.
//    This information is used to store information about rules in which
//    the root of the RHS is a node with the opcode opc.  We use a hash table
//    to do this.
//
// find_op_info: find the op_info associated above.
//
//=============================================================================

/* Maps MTYPE to the 2-bit value for hashing, the table is design such
   that we minimize collison for the most common types */
static unsigned char opc_hash_map[ MTYPE_CORE_LAST+1 ] = {
  0, 0, 0, 0, 
  1 /* MTYPE_I4 */, 0, 0, 0,
  2 /* MTYPE_U4 */, 0, 0, 0,
  0 /* MTYPE_F10 */, 0, 0, 0,
  0 /* MTYPE_M */, 0, 0, 0,
  3 /* MTYPE_V */, 0, 0, 0,
};

struct opcode_hash {
  HASH operator() (const OPCODE opc) const
    {
      int rtype = opc_hash_map[OPCODE_rtype(opc)];
      int desc = opc_hash_map[OPCODE_desc(opc)];
      return (OPCODE_operator(opc)<<4)|(desc<<2)|rtype;
    }
};

struct opcode_eq {
  BOOL operator() (const OPCODE l, const OPCODE r) const
    {
      return l==r;
    }
};

USER_HASH_TABLE<OPCODE,ISEL::Op_info *,opcode_hash,opcode_eq>
                op_info_hash(1<<(OPERATOR_BIT_SIZE+4),Malloc_Mem_Pool);

void ISEL::add_op_info( int opc, ISEL::Op_info *oi )
{
  op_info_hash.Enter( (OPCODE)opc, oi );
}

ISEL::Op_info *ISEL::find_op_info( int opc )
{
  return op_info_hash.Find( (OPCODE)opc );
}

inline ISEL::State *ISEL::STATE_LABEL(WN *p)
{	
  return (ISEL::State *)WN_MAP_Get(ISEL_State_Map,p);
}

inline void ISEL::SET_STATE(WN *p, ISEL::State *s)
{
  WN_MAP_Set(ISEL_State_Map,p,s);
}

inline void *ISEL::ALLOC_FOR_TREE( int size )
{
  return MEM_POOL_Alloc( &ISEL_Mem_Pool, size );
}

inline void *ISEL::ALLOC( int size )
{
  return MEM_POOL_Alloc( &ISEL_Map_Pool, size );
}

inline void *ISEL::REALLOC( void *a, int old_size, int new_size )
{
  return MEM_POOL_Realloc( &ISEL_Map_Pool, a, old_size, new_size ); 
}


//
// ISEL_{Initialize,Finalize}_For_Tree set ups memory allocation for
// the mactching process.  We allocate state structures from a pool
// during labelling and we use Finalize to deallocate them in one fell
// swoop.
//
static void
ISEL_Initialize_For_Tree()
{
  MEM_POOL_Push(&ISEL_Mem_Pool);
}

static void
ISEL_Finalize_For_Tree()
{
  MEM_POOL_Pop(&ISEL_Mem_Pool);
}

/* Given that we want to fit 'value' into an op like:

   op    x, p, value
   
  Compute 'k1', 'k2', 'a', and 'y' to be used like:

   addmi t, p, k1
   addmi t, t, k2
   addi  t, t, a
   op    x, t, y
   
   such that:

   1. k1, k2 >= 0
   2, if 'imm_lcs' contains LC_UNDEFINED then 'y' must be 0, otherwise 'y'
      must fit in every litclass in 'imm_lcs'
   3. if k2 > 0 then k1 > 0
   
   Return true if we can split 'value' in this way. Return false if we
   can't.
*/
static BOOL split_lc_ok (INT64 value, TIE_LITCLASS_LIST *lcs)
{
  for (TIE_LITCLASS_LIST *scan = lcs; scan; scan = scan->_next)
  {
    ISA_LITCLASS lc = scan->_lc;
    
    if (lc == LC_UNDEFINED)
      return value == 0;

    if (!TI_ISA_LC_Value_In_Class(value, lc))
      return FALSE;
  }

  return TRUE;
}

static BOOL split_addi_ok (INT64 value, TIE_LITCLASS_LIST *lcs, INT32 &a)
{
  /* We can use an addi along with 'op' to create offsets from -128 +
     'y' to 127 + 'y'. Most (at least for core instructions) literal
     classes provide a contiguous range of immediates, so we try the
     extremes. If the extremes fail we try every value to catch cases
     where 'lcs' does not contain all contiguous values. Is this too
     expensive? */
  
  if (split_lc_ok(value, lcs))
  {
    a = 0;
    return TRUE;
  }
  else if (split_lc_ok(value-127, lcs))
  {
    a = 127;
    return TRUE;
  }
  else if (split_lc_ok(value+128, lcs))
  {
    a = -128;
    return TRUE;
  }

  for (INT i = -126; i <= 127; i++)
  {
    if (split_lc_ok(value+i, lcs))
    {
      a = -i;
      return TRUE;
    }
  }
  
  return FALSE;
}

static BOOL split_immediate (INT64 value, TIE_LITCLASS_LIST *imm_lcs,
			     INT32 &y, INT32 &k1, INT32 &k2, INT32 &a)
{
  BOOL found = FALSE;

#if 0
  {
    fprintf(TFile, "split_immediate for offset %d, LC = ", (INT32)value);
    for (TIE_LITCLASS_LIST *scan = imm_lcs; scan; scan = scan->_next)
      fprintf(TFile, "%s ", TI_ISA_LC_Name(scan->_lc));
    fprintf(TFile, "\n");
  }
#endif
	  
  /* Maybe 'value' fits as is... */
  y = k1 = k2 = a = 0;
  if (split_lc_ok(value, imm_lcs))
  {
    y = value;
    found = TRUE;
  }
  else
  {
    /* We can use one or two addmi's along with 'op' to create offsets
       from -256*n + 'y' to 256*n + 'y'. We assume that 'imm_lcs'
       accepts a range that is somewhat centered around zero, so we
       try to make 'n' as large as possible so that we leave as little
       for 'y' as possible. We try both leaving the smallest positive
       and negative 'y' value. We could search through all possible
       'n' values here, but that might be too expensive and wuoldn't
       necessarily buy us much. */

    INT32 k = value / 256;
    if (value < 0)
      k--;

    if (split_addi_ok(value - (k * 256), imm_lcs, a))
    {
      found = TRUE;
    }
    else if (split_addi_ok(value - (k * 256) - 256, imm_lcs, a))
    {
      k++;
      found = TRUE;
    }
    
    y = value - (k * 256) - a;

    /* Break 'k' into 'k1' and 'k2'. */

    k1 = k;
    if (k1 > 127)
      k1 = 127;
    else if (k1 < -128)
      k1 = -128;
  
    k2 = k - k1;

    if ((k2 > 127) || (k2 < -128))
      found = FALSE;

    k1 *= 256;
    k2 *= 256;
  }

  return found;
}

static TIE_LITCLASS_LIST *offset_litclasses (TOP op)
{
  static TIE_LITCLASS_LIST lc_undef(LC_UNDEFINED, NULL);
  static TIE_LITCLASS_LIST lc_simm8(LC_simm8, NULL);

  if (op == TOP_UNDEFINED)
    return &lc_undef;

  /* Special cases... */
  if (op == TOP_addi)
    return &lc_simm8;
  
  /* From here we only expect memory ops. Find the offset field and
     return it's litclass. If 'op' doesn't have an offset field,
     return LC_UNDEFINED to indicate that only offset 0 is allowed. */
  Is_True(TI_ISA_Property_Set(PROP_load, op) ||
	  TI_ISA_Property_Set(PROP_store, op) ||
	  TI_ISA_Property_Set(PROP_prefetch, op),
	  ("expecting memory op"));
  
  INT offset_opnd = TI_TOP_Find_Operand_Use(op, OU_offset);
  if (offset_opnd == -1)
    return &lc_undef;

  const ISA_OPERAND_INFO *info = TI_ISA_Operand_Info(op);
  const ISA_OPERAND_VALTYP *vt = TI_ISA_Op_Operand(info, offset_opnd);
  if (!TI_ISA_Valtyp_Is_Literal(vt))
    return &lc_undef;
  return CXX_NEW(TIE_LITCLASS_LIST(TI_ISA_Valtyp_Litclass(vt), NULL), &ISEL_Mem_Pool);
}

static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    ST *s, INT64 o, OPS *ops,
                            bool conservative_addr,
			    bool is_tie_macro,
			    bool is_float)
{
  TN *base_tn;
  ST *base_sym;
  INT32 a, k1, k2, y;
  INT64 base_ofst;
  TIE_MACRO_p tie_macro = NULL;
  TN* in_operands[3];
  TIE_LITCLASS_LIST *offset_lcs;
  
  if (is_tie_macro)
  {
    tie_macro = tie_info->tie_macro((TIE_MACRO_ID)op);
    op = TOP_UNDEFINED;
    offset_lcs = tie_offset_litclass(tie_macro, 2);
    FmtAssert(offset_lcs, ("unexpected, tie macro %s, does not use immediate operand 2",
			   tie_macro->name()));
  }
  else
  {
    offset_lcs = offset_litclasses(op);
  }
  
  Base_Symbol_And_Offset_For_Addressing( s, o, &base_sym, &base_ofst);
  if( base_sym == SP_Sym )
    base_tn = SP_TN;
  else if(base_sym == FP_Sym)
    base_tn = FP_TN;
  else
  {
    switch (ST_storage_class(*s))
    {
    case SCLASS_FSTATIC:
    case SCLASS_MERGE_STRING:
    case SCLASS_PSTATIC:
    case SCLASS_EXTERN:
    {
      base_tn = Generate_Constant(MTYPE_U4, NULL, NULL, s, o, ops);
      if (!is_tie_macro)
	if (is_float) {
	  TN* state2 = cpenable_tn(op);
	  if (state2)
	    Build_OP( op, val, base_tn, Gen_Literal_TN( 0, 4 ), state2 /* cpenable_tn() */, ops );
	  else
	    Build_OP( op, val, base_tn, Gen_Literal_TN( 0, 4 ), ops );
	} else {
	  Build_OP( op, val, base_tn, Gen_Literal_TN( 0, 4 ), ops );
	}
      else {
	in_operands[0]=val;
	in_operands[1]=base_tn;
	in_operands[2]=Gen_Literal_TN( 0, 4 );
	expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
      }
      return;
    }
      
    default:
      //
      // So far only static cases can show up here but that probably isn't true
      // in general.  Probably all sorts of C++ stuff will get here and fail.
      //
      FmtAssert(FALSE, ("Unhandled storage class %s for symbol %s",
			Sclass_Name(ST_storage_class(*s)), ST_name(*s)));
    }
  }

  /* split base_ofst into three numbers y appropriate for the offset
     field of 'op', and k1, and k2 appropriate for addmi */

  BOOL split = split_immediate(base_ofst, offset_lcs, y, k1, k2, a);

  if (conservative_addr || !split)
  {
    /* generate constant, add, 'op' */
    
    TN *tmp;
    TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);

    if( conservative_addr || (s!=base_sym) )
    {
      tmp = Generate_Constant(MTYPE_U4, NULL, NULL, s, o, ops);
    }
    else
    {
      tmp = Generate_Constant(MTYPE_I4, NULL, base_ofst, ops);
    }

    Build_OP( TOP_add, tmp1, base_tn, tmp, ops );
    if (!is_tie_macro)
    {
      if (is_float) {
	TN* state2 = cpenable_tn(op);
	if (state2)
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), state2 /* cpenable_tn() */, ops );
	else
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      } else {
        Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      }
    }
    else
    {
      in_operands[0]=val;
      in_operands[1]=tmp1;
      in_operands[2]=Gen_Literal_TN( 0, 4 );
      expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
    }
  }
  else
  {
    TN *tmp = base_tn;
    if( k2 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k2, 4 ), ops );
      tmp = tmp1;
    }

    if( k1 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k1, 4 ), ops );
      tmp = tmp1;
    }

    if( a != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addi, tmp1, tmp, Gen_Literal_TN( a, 4 ), ops );
      tmp = tmp1;
    }

    /* We must use a symbol tn so that adjustments to the symbol
       offsets made for data layout (which occur after register
       allocation, and perhaps elsewhere) can correctly adjust the
       offset of the symbol. */
    if( s!=base_sym )
    {
      if (!is_tie_macro)
      {
	if (is_float) {
	  TN* state2 = cpenable_tn(op);
	  if (state2)
	    Build_OP( op, val, tmp, Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE),
			state2 /* cpenable_tn() */, ops );
	  else
	    Build_OP( op, val, tmp, Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE), ops );
	} else {
	  Build_OP( op, val, tmp, Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE), ops );
	}
      }
      else
      {
	in_operands[0]=val;
	in_operands[1]=tmp;
	in_operands[2]=Gen_Symbol_TN( s, y-(base_ofst-o), TN_RELOC_NONE);
	expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
      }
    }
    else
    {
      if (!is_tie_macro)
      {
	if (is_float) {
	  TN* state2 = cpenable_tn(op);
	  if (state2)
	    Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ),
			state2 /* cpenable_tn() */, ops );
	  else
	    Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
	} else {
	  Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
	}
      }
      else
      {
	in_operands[0]=val;
	in_operands[1]=tmp;
	in_operands[2]=Gen_Literal_TN( y, 4 );
	expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
      }
    }
  }
}

static void Generate_OP_And_Address_Computation( TOP op, TN *val, 
			    TN *base_tn, INT64 base_ofst, OPS *ops,
			    bool is_tie_macro,
			    bool is_float)
{
  INT32 a, k1, k2, y;
  TIE_MACRO_p tie_macro = NULL;
  TN* in_operands[3];
  TIE_LITCLASS_LIST *offset_lcs;

  if (is_tie_macro)
  {
    tie_macro = tie_info->tie_macro((TIE_MACRO_ID)op);
    op = TOP_UNDEFINED;
    offset_lcs = tie_offset_litclass(tie_macro, 2);
    FmtAssert(offset_lcs, ("unexpected, tie macro %s, does not use immediate operand 2",
			   tie_macro->name()));
  }
  else
  {
    offset_lcs = offset_litclasses(op);
  }
  
  /* split base_ofst into three numbers y appropriate for the offset
     field of 'op', and k1, and k2 appropriate for addmi */

  BOOL split = split_immediate(base_ofst, offset_lcs, y, k1, k2, a);

  if (!split)
  {
    /* generate load_const, add, 'op' */
    
    TN *tmp = Generate_Constant(MTYPE_I4, NULL, base_ofst, ops);
    TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);

    Build_OP( TOP_add, tmp1, base_tn, tmp, ops );
    if (!is_tie_macro)
    {
      if (is_float) {
	TN* state2 = cpenable_tn(op);
	if (state2)
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), state2 /* cpenable_tn() */, ops );
	else
          Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      } else {
        Build_OP( op, val, tmp1, Gen_Literal_TN( 0, 4 ), ops );
      }
    }
    else
    {
      in_operands[0]=val;
      in_operands[1]=tmp1;
      in_operands[2]=Gen_Literal_TN( 0, 4 );
      expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
    }
  }
  else
  {
    TN *tmp = base_tn;
    if( k2 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k2, 4 ), ops );
      tmp = tmp1;
    }

    if( k1 != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addmi, tmp1, tmp, Gen_Literal_TN( k1, 4 ), ops );
      tmp = tmp1;
    }
    
    if( a != 0 )
    {
      TN *tmp1 = Build_TN_Of_Mtype(MTYPE_U4);
      Build_OP( TOP_addi, tmp1, tmp, Gen_Literal_TN( a, 4 ), ops );
      tmp = tmp1;
    }

    if (!is_tie_macro)
    {
      if (is_float) {
	TN* state2 = cpenable_tn(op);
	if (state2)
          Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), state2 /* cpenable_tn() */, ops );
	else
          Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
      } else {
        Build_OP( op, val, tmp, Gen_Literal_TN( y, 4 ), ops );
      }
    }
    else
    {
      in_operands[0]=val;
      in_operands[1]=tmp;
      in_operands[2]=Gen_Literal_TN( y, 4 );
      expand_tie_macro_to_ops(ops, tie_macro->id(), in_operands );
    }
  }
}

static void Generate_Unaligned_Store(TYPE_ID mem_type, TN *val, TN *addr, 
					 INT16 variant, OPS *ops)
{
  TOP op = TOP_UNDEFINED;
  TYPE_ID piece_type;
  INT piece_size = Get_alignment(variant)*8;
  if (MTYPE_bit_size(mem_type) <= piece_size) {
    Is_True(0,("Undefined case"));
    //Build_OP( op, val, addr, Gen_Literal_TN( 0, 4 ), ops );
    return;
  }

  DevWarn("generating unaligned store");
  switch (piece_size)
  {
  case 32:
    op = TOP_s32i;
    piece_type = MTYPE_U4;
    break;
    
  case 16:
    op = TOP_s16i;
    piece_type = MTYPE_U2;
    break;

  case 8:
    op = TOP_s8i;
    piece_type = MTYPE_U1;
    break;
  }

  INT offset;
  INT bits_processed = 0;
  TN *tmp_val = Build_TN_Of_Mtype(MTYPE_U4);
  if (xt_hard_float && (mem_type == MTYPE_F4)) {
    Generate_Unary_FP(MTYPE_U4, TI_TOP_Topcode("rfr"), tmp_val, val, ops);
  } else {
    Build_OP( TOP_mov_n, tmp_val, val, ops );
  }

  while (bits_processed < MTYPE_bit_size(mem_type)) {
    bits_processed += piece_size;
    offset = (Target_Byte_Sex == BIG_ENDIAN) ? 
      MTYPE_bit_size(mem_type) - bits_processed : 
      bits_processed-piece_size;
    Build_OP( op, tmp_val, addr, Gen_Literal_TN(offset/8, 4 ), ops );
    if (bits_processed < MTYPE_bit_size(mem_type)) {
      if (piece_size < 16)
        Build_OP(TOP_srli, tmp_val, tmp_val, Gen_Literal_TN(piece_size,4), ops);
      else
        Build_OP(TOP_extui, tmp_val, tmp_val, Gen_Literal_TN(piece_size,4), Gen_Literal_TN(32-piece_size,4), ops);
    }
  }
}

static void Generate_Unaligned_Load(TYPE_ID mem_type, TN *val, TN *addr, 
					 INT16 variant, OPS *ops)
{
  TOP op = TOP_UNDEFINED;
  TYPE_ID piece_type;
  INT piece_size = Get_alignment(variant)*8;
  if (MTYPE_bit_size(mem_type) <= piece_size) {
    Is_True(0,("Undefined case"));
    //Build_OP( op, val, addr, Gen_Literal_TN( 0, 4 ), ops );
    return;
  }

  TN *tmp_val = Build_TN_Of_Mtype(MTYPE_U4);
  DevWarn("generating unaligned load");
  switch (piece_size)
  {
  case 32:
    op = TOP_l32i;
    piece_type = MTYPE_U4;
    break;
    
  case 16:
    op = TOP_l16ui;
    piece_type = MTYPE_U2;
    break;

  case 8:
    op = TOP_l8ui;
    piece_type = MTYPE_U1;
    break;
  }

  INT offset;
  INT bits_processed = piece_size;
  offset = (Target_Byte_Sex == BIG_ENDIAN) ? 
    bits_processed-piece_size:
    MTYPE_bit_size(mem_type) - piece_size ;

  /* Sign extend the upper bits */
  if (MTYPE_is_signed(mem_type) && 
      (MTYPE_bit_size(mem_type) < MTYPE_bit_size(MTYPE_I4) &&
      (piece_size == 16))) {
    Build_OP( TOP_l16si, tmp_val, addr, Gen_Literal_TN( offset/8, 4 ), ops );
  } else {
    Build_OP( op, tmp_val, addr, Gen_Literal_TN( offset/8, 4 ), ops );
  }

  while (bits_processed < MTYPE_bit_size(mem_type)) {
    TN *tmp_piece = Build_TN_Of_Mtype(piece_type);
    bits_processed += piece_size;
    offset = (Target_Byte_Sex == BIG_ENDIAN) ? 
      bits_processed-piece_size:
      MTYPE_bit_size(mem_type) - bits_processed ;
    Build_OP( TOP_slli, tmp_val, tmp_val, Gen_Literal_TN(piece_size, 4), ops );
    Build_OP( op, tmp_piece, addr, Gen_Literal_TN( offset/8, 4 ), ops );
    Build_OP( TOP_or, tmp_val, tmp_val, tmp_piece, ops );
  }

  if (MTYPE_is_signed(mem_type) && 
      (MTYPE_bit_size(mem_type) < MTYPE_bit_size(MTYPE_I4) &&
      (piece_size != 16))) {
    Generate_Extend(mem_type, val, tmp_val, MTYPE_bit_size(mem_type), ops);
  } else if (xt_hard_float && (mem_type == MTYPE_F4)) {
    Generate_Unary_FP(MTYPE_F4, TI_TOP_Topcode("wfr"), val, tmp_val, ops);
  } else {
    Build_OP( TOP_mov_n, val, tmp_val, ops );
  }
}

static void
Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, ST *s, INT64 o, INT16 variant, OPS *ops)
{
  Allocate_Object(s);
  Set_Last_Mem_OP( ops );

  TOP op = TOP_UNDEFINED;
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_s32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("ssi") : TOP_s32i);
    break;
    
  case MTYPE_U2:
  case MTYPE_I2:
    op = TOP_s16i;
    break;

  case MTYPE_I1:
  case MTYPE_U1:
    op = TOP_s8i;
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  TYPE_ID val_mtype = TN_mtype(val);
  if (MTYPE_is_tie(val_mtype) || MTYPE_is_tie(desc)) {
    if (TN_is_register(val) && TN_is_dedicated(val))
      val_mtype = desc;
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot store unaligned tie variable"));
    if (desc==val_mtype) {
      tie_macro = tie_info->mtype_storei_macro(desc);
    } else if (tree && WN_operator(WN_kid0(tree))==OPR_CVT) {

      // a TIE converting store
      // try to use mtypes in the CVT node if there is one since
      // that is the one checked by tie_rtom_rule_label
      // and we have problem when the source of the conversion
      // has different but compatible type and we want to make sure
      // I2 converting is used instead of I4 (see PR10880):
      //
      //	I4INTCONST 2 (0x2)
      //      _TIE_new_veclevelI2CVT
      //      U4U4LDID 0 <2,4,level> T<36,anon_ptr.,4>
      //     _TIE_new_veclevelISTORE 0 T<36,anon_ptr.,4> {freq: 0, ln: 24, col: 0}

      WN* kid = WN_kid0(tree);
      TYPE_ID cvt_desc = WN_desc(kid);
      tie_macro = tie_info->mtype_rtom_macro(cvt_desc, desc);
    } else
      tie_macro = tie_info->mtype_rtom_macro(val_mtype, desc);

    if (tie_macro==NULL && TN_is_register(val) && TN_is_dedicated(val) &&
	  TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(val))
      tie_macro = tie_info->mtype_storei_macro(desc);

    Generate_OP_And_Address_Computation((TOP)tie_macro->id(),
					val, s, o, ops,
					use_conservative_addressing(s),
					/* is_tie_macro = */true,
					/* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create store for type %s", Mtype_Name(desc)));

    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Store(desc, val, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, val, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }
  if( tree )
    Set_OP_To_WN_Map( tree );
}

static void
Generate_Store_Memory (WN *tree, TYPE_ID desc, TN *val, TN *addr, INT64 o, INT16 variant, OPS *ops)
{
  Set_Last_Mem_OP( ops );

  TOP op = TOP_UNDEFINED;
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_s32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("ssi") : TOP_s32i);
    break;
    
  case MTYPE_U2:
  case MTYPE_I2:
    op = TOP_s16i;
    break;

  case MTYPE_I1:
  case MTYPE_U1:
    op = TOP_s8i;
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  TYPE_ID val_mtype = TN_mtype(val);
  if (MTYPE_is_tie(val_mtype) || MTYPE_is_tie(desc)) {
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot store unaligned tie variable"));
    if (desc==val_mtype) {
      tie_macro = tie_info->mtype_storei_macro(desc);
    } else if (tree && WN_operator(WN_kid0(tree))==OPR_CVT) {

      // a TIE converting store
      // try to use mtypes in the CVT node if there is one since
      // that is the one checked by tie_rtom_rule_label
      // and we have problem when the source of the conversion
      // has different but compatible type and we want to make sure
      // I2 converting is used instead of I4 (see PR10880):
      //
      //	I4INTCONST 2 (0x2)
      //      _TIE_new_veclevelI2CVT
      //      U4U4LDID 0 <2,4,level> T<36,anon_ptr.,4>
      //     _TIE_new_veclevelISTORE 0 T<36,anon_ptr.,4> {freq: 0, ln: 24, col: 0}

      WN* kid = WN_kid0(tree);
      TYPE_ID cvt_desc = WN_desc(kid);
      tie_macro = tie_info->mtype_rtom_macro(cvt_desc, desc);
    } else
      tie_macro = tie_info->mtype_rtom_macro(val_mtype, desc);

    if (tie_macro==NULL && TN_is_register(val) && TN_is_dedicated(val) &&
	  TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(val))
      tie_macro = tie_info->mtype_storei_macro(desc);

    Generate_OP_And_Address_Computation( (TOP)tie_macro->id(),
					    val, addr, o, ops,
					    /* is_tie_macro = */true,
					    /* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create store for type %s", Mtype_Name(desc)));

    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Store(desc, val, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, val, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }
  if( tree )
    Set_OP_To_WN_Map( tree );
}

static TN *
Generate_Load_Memory( WN *tree, TYPE_ID rtype, TYPE_ID desc,
		      TN *result, ST *s, INT64 o, INT16 variant, OPS *ops )
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  Allocate_Object(s);
  Set_Last_Mem_OP( ops );

  FmtAssert((rtype == MTYPE_U4) || (rtype == MTYPE_I4) || (rtype == MTYPE_F4)
	    || (MTYPE_is_tie(rtype)) || (MTYPE_is_tie(desc)),
	    ("cannot create load to result type %s", Mtype_Name(rtype)));
  
  TOP op = TOP_UNDEFINED;
  TN *tresult = NULL;
  
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_l32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("lsi") : TOP_l32i);
    break;
    
  case MTYPE_U2:
    op = TOP_l16ui;
    break;

  case MTYPE_I2:
    op = TOP_l16si;
    break;

  case MTYPE_U1:
    op = TOP_l8ui;
    break;

  case MTYPE_I1:
    op = TOP_l8ui;
    if (TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer()) {
      tresult = result;
      result = Build_TN_Of_Mtype(rtype);
    }
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  if (MTYPE_is_tie(rtype) || MTYPE_is_tie(desc)) {
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot load unaligned tie variable"));
    if (desc==rtype)
	tie_macro = tie_info->mtype_loadi_macro(desc);
    else {
	tie_macro = tie_info->mtype_mtor_macro(desc, rtype);

        if (tie_macro==NULL && TN_is_register(result) && TN_is_dedicated(result) &&
	    TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(result))
          tie_macro = tie_info->mtype_storei_macro(desc);
    }

    Generate_OP_And_Address_Computation((TOP)tie_macro->id(),
					result, s, o, ops, 
					use_conservative_addressing(s),
					/* is_tie_macro = */true,
					/* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create load for rtype %s, desc %s",
				    Mtype_Name(rtype), Mtype_Name(desc)));
  
    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Load(desc, result, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, result, s, o, ops,
					  use_conservative_addressing(s),
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }

  if (desc == MTYPE_I1 &&
      TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer())
    result = Generate_Extend(MTYPE_I4, tresult, result, 8, ops);

  /* If the symbol is constant, then the last instruction we generated
     should be a load of that constant, and we can show it as not
     aliasing anything. */
  
  if (ST_is_constant(s))
  {
    OP *last = OPS_last(ops);
    if (last && OP_load(last))
      Set_OP_no_alias(last);
  }
  
  if( tree )
    Set_OP_To_WN_Map( tree );

  return result;
}

static TN *
Generate_Load_Memory( WN *tree, TYPE_ID rtype, TYPE_ID desc,
		      TN *result, TN *addr, INT64 o, INT16 variant, OPS *ops )
{
  if( !result )
    result = Build_TN_Of_Mtype(rtype);

  Set_Last_Mem_OP( ops );

  FmtAssert((rtype == MTYPE_U4) || (rtype == MTYPE_I4) || (rtype == MTYPE_F4)
	    || (MTYPE_is_tie(rtype)) || (MTYPE_is_tie(desc)),
	    ("cannot create load to result type %s", Mtype_Name(rtype)));
  
  TOP op = TOP_UNDEFINED;
  TN *tresult = NULL;
  
  switch (desc)
  {
  case MTYPE_U4:
  case MTYPE_I4:
    op = TOP_l32i;
    break;
    
  case MTYPE_F4:
    op = (xt_hard_float ? TI_TOP_Topcode("lsi") : TOP_l32i);
    break;
    
  case MTYPE_U2:
    op = TOP_l16ui;
    break;

  case MTYPE_I2:
    op = TOP_l16si;
    break;

  case MTYPE_U1:
    op = TOP_l8ui;
    break;

  case MTYPE_I1:
    op = TOP_l8ui;
    if (TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer()) {
      tresult = result;
      result = Build_TN_Of_Mtype(rtype);
    }
    break;
  }

  BOOL needs_memw = xt_serialize_volatile;
  if (tree && WN_Is_Volatile_Mem(tree) && needs_memw) {
    Build_OP( TOP_memw, ops );
  }

  if (MTYPE_is_tie(rtype) || MTYPE_is_tie(desc)) {
    TIE_MACRO_p tie_macro=NULL;
//      FmtAssert(variant==0, ("cannot load unaligned tie variable"));
    if (desc==rtype)
	tie_macro = tie_info->mtype_loadi_macro(desc);
    else {
	tie_macro = tie_info->mtype_mtor_macro(desc, rtype);

        if (tie_macro==NULL && TN_is_register(result) && TN_is_dedicated(result) &&
	    TI_ISA_Regclass_For_Mtype(desc)==TN_register_class(result))
          tie_macro = tie_info->mtype_storei_macro(desc);
    }
    Generate_OP_And_Address_Computation((TOP)tie_macro->id(),
					result, addr, o, ops,
					/* is_tie_macro = */true,
					/* is_float = */false);
  } else {
    FmtAssert(op != TOP_UNDEFINED, ("cannot create load for rtype %s, desc %s",
				  Mtype_Name(rtype), Mtype_Name(desc)));
  
    if (variant != 0) {
      TN *tmpaddr = Build_TN_Of_Mtype(MTYPE_U4);
      Generate_OP_And_Address_Computation(TOP_addi, tmpaddr, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */false);
      Generate_Unaligned_Load(desc, result, tmpaddr, variant, ops);
    } else
      Generate_OP_And_Address_Computation(op, result, addr, o, ops,
					  /* is_tie_macro = */false,
					  /* is_float = */(desc==MTYPE_F4));
  }

  if (desc == MTYPE_I1 &&
      TI_ISA_Regclass_For_Mtype(rtype)==TI_ISA_Regclass_Integer())
    result = Generate_Extend(MTYPE_I4, tresult, result, 8, ops);

  if( tree )
    Set_OP_To_WN_Map( tree );

  return result;
}

static ST *Generate_Pu_Static_Symbol(TYPE_ID mtype)
{
  ST *lc;

  /* Create a reference to the literal and put it in the  literal pool */
  lc = New_ST(CURRENT_SYMTAB);
  ST_Init( lc, Save_Str(Exp_Unique_Literal_Name()), CLASS_VAR,
	   SCLASS_PSTATIC, EXPORT_LOCAL,
	   MTYPE_To_TY(mtype));
  Set_ST_is_initialized(lc);
  Set_ST_is_const_var(lc);
  Allocate_Object(lc);
  return lc;
}

static ST *Generate_Literal_Symbol()
{
  ST *lc;

  /* Create a reference to the literal and put it in the  literal pool */
  lc = New_ST(CURRENT_SYMTAB);
  ST_Init( lc, Save_Str(Exp_Unique_Literal_Name()), CLASS_VAR,
	   SCLASS_LITERAL_POOL, EXPORT_LOCAL,
	   MTYPE_To_TY(MTYPE_U4));
  Set_ST_is_initialized(lc);
  Set_ST_is_temp_var(lc);
  Set_ST_is_const_var(lc);
  Allocate_Object(lc);
  return lc;
}

#if 0
// xtensa doesn't use this function, and if we decide to,
// we will have to update it for const16
// need to be updated for const16

// See description above
static ST *Generate_Literal_Pointer( ST *s, INT64 o )
{
  ST *base_sym;
  INT64 base_ofst;
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;

  Allocate_Object(s);
  Base_Symbol_And_Offset_For_Addressing( s, o, &base_sym, &base_ofst);

  lc = Generate_Literal_Symbol();
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Symoff(inv,base_sym,base_ofst);

  return lc;
}
#endif

static ST *Generate_Literal_Pointer_Nonbased( ST *s, INT64 o )
{
  INITV_IDX inv;

  Allocate_Object(s);

  ST *lc = Generate_Literal_Symbol();
  INITO_IDX ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Symoff(inv,s,o);

  return lc;
}

static ST *Generate_Literal_Label( LABEL_IDX lab )
{
  INITV_IDX inv;

  ST *lc = Generate_Literal_Symbol();
  INITO_IDX ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Label(inv,lab);

  return lc;
}

static ST *Generate_Literal_Float( float v )
{
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;

  lc = Generate_Literal_Symbol();
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Float(inv, MTYPE_F4, v);

  return lc;
}

static ST *Generate_Literal_Integer( int v )
{
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;

  lc = Generate_Literal_Symbol();
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Integer(inv, MTYPE_I4, v);

  return lc;
}

static ST *Generate_Literal_Tie(TYPE_ID mtype, int v)
{
  ST *lc;
  INITO_IDX ino;
  INITV_IDX inv;
  int mtype_size;
  int byte_count;

  lc = Generate_Pu_Static_Symbol(mtype);
  ino = New_INITO( lc, inv = New_INITV());
  INITV_Init_Integer(inv, mtype, v);

  return lc;
}

static BOOL Label_ICall ( WN *n, COST *cost)
{
  COST c;
  WN *target = WN_kid(n, WN_kid_count(n) - 1);
  if (!ISEL::match(target, ISEL::find_nonterm("areg"), c))
  {
    *cost = COST_INFINITY;
    return FALSE;
  }
  
  cost->cost = c.cost + 1;
  return TRUE;
}

static void Generate_ICall( WN *n, TOP top, OPS *ops )
{
  WN *target = WN_kid(n, WN_kid_count(n) - 1);
  TN *tn = areg_action(ISEL::STATE_LABEL(target), 0, ops);
  TN *ret_addr_tn = 0;
  ISA_REGCLASS ar = TI_ISA_Regclass_Integer();
  REGISTER ret_addr_reg;
  INT first_reg = TI_ISA_Regclass_First_Reg(TI_ISA_Regclass_Info(ar)) +
    REGISTER_MIN;
  switch (top) {
  case TOP_callx0:
    ret_addr_reg = first_reg + 0; break;
  case TOP_callx4:
    ret_addr_reg = first_reg + 4; break;
  case TOP_callx8:
    ret_addr_reg = first_reg + 8; break;
  case TOP_callx12:
    ret_addr_reg = first_reg + 12; break;
  }
  ret_addr_tn = Build_Dedicated_TN(ar, ret_addr_reg, 4);
  
  PU_Has_Calls = TRUE;
  Set_Last_Mem_OP( ops );
  Build_OP( top, ret_addr_tn, tn, ops );
  Handle_Call_Site_Extras( n, WN_operator( n ) );
}

static BOOL
MUL16_arg_cost (WN *result_wn, WN *left, WN *right,
                COST *new_cost, int cost_offset)
{
  COST c;
  int cost_val = cost_offset;

  Is_True(xt_mul16 || Enable_HiFi2_Ops, ("Unable to generate 16-bit multiply instructions"));
  
  /* Check for truncation. We can't optimize away the truncation if we
     are doing unsigned 16-bit multiplication on HiFi2. */
  if (xt_mul16 || WN_Mpy_16Bit_Signed(result_wn))
  {
    if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
      left = WN_kid0(left);
    
    if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
      right = WN_kid0(right);
  }
  
  if (!ISEL::match(left, ISEL::find_nonterm("areg"), c))
  {
    *new_cost = COST_INFINITY;
    return FALSE;
  }
  cost_val += c.cost;

  if (!ISEL::match(right, ISEL::find_nonterm("areg"), c))
  {
    *new_cost = COST_INFINITY;
    return FALSE;
  }
  cost_val += c.cost;

  new_cost->cost = cost_val;
  return TRUE;
}


static TN *
Generate_MUL16(TYPE_ID rtype, TN *result, WN *result_wn,
               char *instruction_name, WN *left, WN *right, OPS *ops)
{ 
  Is_True(xt_mul16 || Enable_HiFi2_Ops, ("Unable to generate 16-bit multiply instructions"));
  
  TN *left_tn, *right_tn;
  
  /* Optimize away truncation. We can't optimize away the truncation
     if we are doing unsigned 16-bit multiplication on HiFi2. */
  if (xt_mul16 || WN_Mpy_16Bit_Signed(result_wn))
  {
    if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
      left = WN_kid0(left);
    
    if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
      right = WN_kid0(right);
  }
  
  left_tn = areg_action(ISEL::STATE_LABEL(left), 0, ops);
  right_tn = areg_action(ISEL::STATE_LABEL(right), 0, ops);
  
  return Generate_Mul(rtype, result, result_wn,
                      instruction_name, left_tn, right_tn, ops);
}


static BOOL MAC16_arg_cost(WN *left, WN *right, COST *new_cost, 
			   int cost_offset)
{
  COST c;
  int cost_val = cost_offset;

  /* Check for multiplication with the upper half of the register */
  if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
    left = WN_kid0(left);
  if (((WN_operator(left) == OPR_ASHR) || (WN_operator(left) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(left)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(left)) == 16) &&
      ISEL::match(WN_kid0(left), ISEL::find_nonterm("areg"), c)) {
    cost_val += c.cost;
  } else {
    if (!ISEL::match(left, ISEL::find_nonterm("areg"), c))
    {
      *new_cost = COST_INFINITY;
      return FALSE;
    }
    cost_val += c.cost;
  }

  /* Check for multiplication with the upper half of the register */
  if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
    right = WN_kid0(right);
  if (((WN_operator(right) == OPR_ASHR) || (WN_operator(right) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(right)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(right)) == 16) &&
      ISEL::match(WN_kid0(right), ISEL::find_nonterm("areg"), c)) {
    cost_val += c.cost;
  } else {
    if (!ISEL::match(right, ISEL::find_nonterm("areg"), c))
    {
      *new_cost = COST_INFINITY;
      return FALSE;
    }
    cost_val += c.cost;
  }

  new_cost->cost = cost_val;
  return TRUE;
}

static void Generate_MAC16(const char *opcode, WN *left, WN *right, OPS *ops)
{ 
  Is_True(xt_mac16, ("Cannot generate multiply-add instructions"));

  TN *left_tn, *right_tn;
  int code = 0;

  if (!strcmp(opcode, "umul.aa.ll"))
    code += 0;
  if (!strcmp(opcode, "mul.aa.ll"))
    code += 4;
  if (!strcmp(opcode, "mula.aa.ll"))
    code += 8;
  if (!strcmp(opcode, "muls.aa.ll"))
    code += 12;

  if ((WN_operator(left) == OPR_CVTL) && (WN_cvtl_bits(left) == 16))
    left = WN_kid0(left);
  if (((WN_operator(left) == OPR_ASHR) || (WN_operator(left) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(left)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(left)) == 16)) {
    left = WN_kid0(left);
    code += 2;
  }
  left_tn = areg_action(ISEL::STATE_LABEL(left), 0, ops);

  if ((WN_operator(right) == OPR_CVTL) && (WN_cvtl_bits(right) == 16))
    right = WN_kid0(right);
  if (((WN_operator(right) == OPR_ASHR) || (WN_operator(right) == OPR_LSHR)) &&
      (WN_operator(WN_kid1(right)) == OPR_INTCONST) && 
      (WN_const_val(WN_kid1(right)) == 16)) {
    right = WN_kid0(right);
    code += 1;
  }
  right_tn = areg_action(ISEL::STATE_LABEL(right), 0, ops);

  const char* new_tops[] = {
    "umul.aa.ll", "umul.aa.lh", "umul.aa.hl", "umul.aa.hh",
    "mul.aa.ll", "mul.aa.lh", "mul.aa.hl", "mul.aa.hh",
    "mula.aa.ll", "mula.aa.lh", "mula.aa.hl", "mula.aa.hh",
    "muls.aa.ll", "muls.aa.lh", "muls.aa.hl", "muls.aa.hh",
  };

  if (code < 8) {
    Build_OP(TI_TOP_Topcode(new_tops[code]), accum_tn(), left_tn, right_tn, 
	     ops);
  } else {
    Build_OP(TI_TOP_Topcode(new_tops[code]), accum_tn(), left_tn, right_tn, 
	     accum_tn(), ops);
  }
}

static BOOL Label_Asm ( WN *n, COST *cost)
{
  cost->cost = 1;
  
  /* Label all the input parameters... */
  
  for (INT kid = 2; kid < WN_kid_count(n); ++kid)
  {
    COST c;

    WN* load = WN_kid0(WN_kid(n, kid));
    if (!ISEL::match(load, ISEL::find_nonterm(find_nonterm_name(WN_rtype(load))), c))
    {
      *cost = COST_INFINITY;
      return FALSE;
    }
  
    cost->cost += c.cost;
  }
  
  return TRUE;
}

static const char* find_nonterm_name(TYPE_ID mtype)
{
  FmtAssert(mtype!=MTYPE_UNKNOWN, ("Unknown TIE type"));

  if (MTYPE_is_tie(mtype))
    return "tie_reg";
  else if (mtype==MTYPE_XTBOOL)
    return "b1reg";
  else if (MTYPE_is_xtbool(mtype))
    return "breg";
  else if (mtype==MTYPE_F4 && xt_hard_float)
    return "freg";

  return "areg";
}

static const char* find_nonterm_name(const char* tie_proto_type) {

  if (!strcmp("immediate", tie_proto_type))
    return "tie_imm";

  TYPE_ID mtype = tie_info->mtype_id(tie_proto_type);
  return find_nonterm_name(mtype);
}

static TN* action_by_type(WN* n, TYPE_ID mtype, TN *result, OPS* ops) {

  FmtAssert(mtype!=MTYPE_UNKNOWN, ("Unknown TIE type"));
  if (MTYPE_is_tie(mtype))
    return tie_reg_action(ISEL::STATE_LABEL(n), result, ops);
  else if (mtype==MTYPE_XTBOOL)
    return b1reg_action(ISEL::STATE_LABEL(n), result, ops);
  else if (MTYPE_is_xtbool(mtype))
    return breg_action(ISEL::STATE_LABEL(n), result, ops);
  else if (mtype==MTYPE_F4 && xt_hard_float)
    return freg_action(ISEL::STATE_LABEL(n), result, ops);
  else
    return areg_action(ISEL::STATE_LABEL(n), result, ops);

  FmtAssert(FALSE, ("Unreachable code reached"));
}

static TN* action_by_type(WN* n, const char* tie_proto_type, TN *result, OPS* ops) {

  if (!strcmp("immediate", tie_proto_type))
    return tie_imm_action(ISEL::STATE_LABEL(n));

  TYPE_ID mtype = tie_info->mtype_id(tie_proto_type);
  return action_by_type(n, mtype, result, ops);
}

static bool
tie_select_rule_label(WN* n, COST &c) 
{

  COST c1;
  WN* kid0=WN_kid0(n);
  WN* kid1=WN_kid1(n);
  WN* kid2=WN_kid(n,2);

  if (WN_rtype(kid1) != WN_rtype(n) || WN_rtype(kid2) != WN_rtype(n)) {
      c = COST_INFINITY;
      return FALSE;
  }

  if (!ISEL::match(kid0, ISEL::find_nonterm("areg"), c1)) {
      c = COST_INFINITY;
      return FALSE;
  }
  c.cost += c1.cost;
  if (!ISEL::match(kid1, ISEL::find_nonterm("tie_reg"), c1)) {
      c = COST_INFINITY;
      return FALSE;
  }
  c.cost += c1.cost;
  if (!ISEL::match(kid2, ISEL::find_nonterm("tie_reg"), c1)) {
      c = COST_INFINITY;
      return FALSE;
  }
  c.cost += c1.cost;
  c.cost += 3;

  return true;
}

static TN*
tie_select_rule_action(ISEL::State* _s, TN* result, OPS* ops)
{
  WN* n = _s->node;
  WN* kid0=WN_kid0(n);
  WN* kid1=WN_kid1(n);
  WN* kid2=WN_kid(n,2);
  TYPE_ID rtype = WN_rtype(n);
  TYPE_ID desc = WN_desc(kid0);
  FmtAssert(WN_rtype(kid1)==rtype, ("Expecting tie type"));
  FmtAssert(WN_rtype(kid2)==rtype, ("Expecting tie type"));

  TN * l = areg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  TN * r = Generate_Constant(desc, 0, 0, ops);
  TN * tn_true = tie_reg_action(ISEL::STATE_LABEL(kid1), 0, ops);
  TN * tn_false = tie_reg_action(ISEL::STATE_LABEL(kid2), 0, ops);

  return Generate_Branch_Select(rtype, desc, TOP_bne,
				result, l, r, tn_true, tn_false, ops);
};

static bool tie_intr_op_rule_label(WN* n, COST &c) {

  if (!is_tie_intrinsic_call(n)) {
    c = COST_INFINITY;
    return false;
  }

  COST intr_cost;
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(n));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  UINT kid_count = WN_kid_count(n);
  intr_cost.cost=tie_macro->num_instructions();
  FmtAssert(tie_macro->is_whirl_intrinsic_op(),
	    ("Non-function TIE intrinsic %s used as operation",
	     tie_macro->name()));
  if (tie_macro->is_c_function())
    FmtAssert(kid_count+1==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));
  else if (MTYPE_is_tie_packed(WN_rtype(n)))
    FmtAssert(kid_count+tie_macro->num_output_protos()==
	      tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));
  else
    FmtAssert(kid_count==tie_macro->num_protos(),
	    ("Parameter count mis-match for TIE intrinsic %s",
	     tie_macro->name()));

#if 0
printf("isel tie intr op label: %s\n", tie_macro->name());
#endif
  for (int i=0,opnd_index=0; i<kid_count; i++,opnd_index++) {
    WN* kid = WN_kid0(WN_kid(n,i));

    while (tie_macro->proto_is_out(opnd_index))
      opnd_index++;
    if (tie_macro->proto_is_immed(opnd_index) &&
	ISEL::match(kid, ISEL::find_nonterm("tie_imm"), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else if (ISEL::match(kid, ISEL::find_nonterm(
		find_nonterm_name(tie_macro->proto_mtype_id(tie_info,opnd_index))), c))
      intr_cost.cost = intr_cost.cost + c.cost;
    else {
      c = COST_INFINITY;
      return false;
    }
  }

  c = intr_cost;
  return true;
}

static TN* tie_intr_op_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  OPS* copy_ops = NULL;
  WN* n = _s->node;
  TN* in_operands[128];
  TIE_MACRO_ID tie_macro_id = Intrinsic_To_Tie_Macro_Id(WN_intrinsic(n));
  TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
  bool packed_output = false;

  TYPE_ID rtype = WN_rtype(n);
  if (MTYPE_is_tie_packed(rtype)) {
    packed_output = true;
    if (result==NULL) {
      TYPE_ID ret_mtype = tie_macro->output_mtype(tie_info);
      ST* packed_st = MTYPE_To_PREG(ret_mtype);
      TY_IDX packed_ty = MTYPE_To_TY(ret_mtype);
      PREG_NUM packed_preg = Create_Preg(ret_mtype, "tie_intr_struct_out");
      result = PREG_To_TN(packed_st, packed_preg);
    }
  }
#if 0
printf("isel tie intr op action: %s\n", tie_macro->name());
#endif

  int num_outputs=0;
  for (int i=0,opnd_index=0; opnd_index<tie_macro->num_protos(); opnd_index++) {
      WN* kid = NULL;
      TYPE_ID mtype = tie_macro->proto_mtype_id(tie_info,opnd_index);
      if (tie_macro->proto_is_out(opnd_index)) {
	if (packed_output) {
	  PREG_NUM preg_num = TN_To_PREG(result);
          in_operands[opnd_index]=
		PREG_To_TN(MTYPE_To_PREG(mtype),preg_num+num_outputs);
	} else if (result)
          in_operands[opnd_index]=result;
	else {
          result=Build_TN_Of_Mtype(mtype);
          in_operands[opnd_index]=result;
	}
	num_outputs++;
      } else if (tie_macro->proto_is_inout(opnd_index)) {
	/* for inout parameter, we need to make sure a different TN
	   is used and a copy-in is made or we might use a int const
	   TN (from copy-prop optimization) and later cg may think it is
	   rematerializable
	*/
	TN* in_tn;
        kid = WN_kid0(WN_kid(n,i));
        in_tn=action_by_type(kid, mtype, 0, ops);

	if (copy_ops==NULL)
	  copy_ops = OPS_Create();

	if (packed_output) {
	  PREG_NUM preg_num = TN_To_PREG(result);
	  TN* dst = PREG_To_TN(MTYPE_To_PREG(mtype),preg_num+num_outputs);
	  Move_To_Register(mtype, dst, in_tn, copy_ops);
          in_operands[opnd_index]=dst;
	} else {
	  if (result==NULL) {
            result=Build_TN_Of_Mtype(mtype);
	  }
	  Move_To_Register(mtype,result, in_tn, copy_ops);
          in_operands[opnd_index]=result;
	}
        i++;
	num_outputs++;
      } else {
        kid = WN_kid0(WN_kid(n,i));
	if (tie_macro->proto_is_immed(opnd_index))
          in_operands[opnd_index]=action_by_type(kid, "immediate", 0, ops);
	else
          in_operands[opnd_index]=action_by_type(kid, mtype, 0, ops);
        i++;
      }
  }

  if (copy_ops)
    OPS_Append_Ops(ops, copy_ops);

  expand_tie_macro_to_ops(
	ops, Intrinsic_To_Tie_Macro_Id(WN_intrinsic(n)), in_operands);
  return result;
};

static bool tie_call_rule_label(WN* n, COST &c) { 
  c.cost = 1;
  return TRUE;
}

static TN* tie_call_rule_action(ISEL::State* _s, TN* result, OPS* ops) {
  WN* n = _s->node;
  Is_True( result==0, ("Requesting result from call"));
  Generate_Call( n, ABI_CALL, ops);
  return 0;
}

static bool
tie_ldid_rule_label(WN* n, COST &c) {

  c.cost = 1;
  return TRUE;

}

static TN*
tie_ldid_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID mtype_id = WN_rtype(n);

  if (MTYPE_is_tie_packed(mtype_id)) {

    FmtAssert(is_preg(n),("Expecting PREG of type '%s'", MTYPE_name(mtype_id)));
    ST *s = WN_st(n);
    INT64 preg_num = WN_load_offset(n);

    if (result==NULL)
      return PREG_To_TN(s,preg_num);

    FmtAssert(TN_register(result) &&
	      !TN_is_dedicated(result) && TN_To_PREG(result),
		("Missing result for LDID of type '%s'", MTYPE_name(mtype_id)));
    INT64 dst_preg_num = TN_To_PREG(result);
    for (int i=0; i<tie_info->num_scalar_mtypes(mtype_id); i++) {
      TYPE_ID mtype = tie_info->get_scalar_mtype(mtype_id, i);
      TN* src=PREG_To_TN(s,preg_num+i);
      TN* dst=PREG_To_TN(s,dst_preg_num+i);
      FmtAssert(TN_mtype(src)==TN_mtype(dst),("Mtypes mismatch"));
      Move_To_Register(mtype,dst,src,ops);
    }
    return PREG_To_TN(s,dst_preg_num);
  } else if (is_preg(n)) {
    Check_For_Dedicated_Preg(n);
    ST *s = WN_st(n);
    INT64 o = WN_load_offset(n);
    return Move_To_Register(mtype_id,result,PREG_To_TN(s,o),ops);
  } else {
    Check_For_Dedicated_Preg(n);
    return Generate_Load_Memory(n, mtype_id, mtype_id, result,
			      WN_st(n), WN_load_offset(n), Variant_LDID(n), ops);
  }
}

static bool
tie_iload_rule_label(WN* n, COST &c) {

  ISEL::Nonterm areg_nt = ISEL::find_nonterm("areg");
  COST c1;
  WN* value = WN_kid0(n);
  if (ISEL::match(value, areg_nt, c1)) {
    c.cost = c1.cost + 1;
    return TRUE;
  } else {
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_iload_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID mtype_id = WN_desc(n);
  TN *addr = expr_action(ISEL::STATE_LABEL(WN_kid0(n)), 0, ops);
  return Generate_Load_Memory(n, mtype_id, mtype_id, result,
			      addr, WN_offset(n), Variant_ILOAD(n), ops);
}

static bool
tie_istore_rule_label(WN* n, COST &c) {

  ISEL::Nonterm areg_nt = ISEL::find_nonterm("areg");
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  COST c1, c2;
  WN* value = WN_kid0(n);
  WN* addr = WN_kid1(n);
  if (ISEL::match(addr, areg_nt, c1)==false) {
    c = COST_INFINITY;
    return FALSE;
  }

  TYPE_ID value_mtype = WN_desc(n);
  ISEL::Nonterm reg_nt = MTYPE_is_tie(value_mtype)?
			ISEL::find_nonterm("tie_reg"):
			ISEL::find_nonterm("areg");
  if (ISEL::match(value, tie_cvt_reg_nt, c2)) {
    c.cost = c1.cost + c2.cost + 1;
    return TRUE;
  } else {
    /* only try to match for the TIE register file case here
       because tie_istore rules may be created for built-in mtypes which
       takes a TIE type conversion result and we want to add the
       tie_cvt_reg_nt rule for value but do not want to conflict with the
       static istore rules
    */
    if (MTYPE_is_tie(value_mtype)) {
      if (ISEL::match(value, reg_nt, c2)) {
        c.cost = c1.cost + c2.cost;
        return TRUE;
      }
    }
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_istore_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID value_mtype = WN_desc(n);

  Is_True( result==0, ("Requesting result from store"));
  WN* kid0 = WN_kid0(n);
  TN *val;
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  TN *addr = areg_action(ISEL::STATE_LABEL(WN_kid1(n)), 0, ops);

  if (ISEL::STATE_LABEL(kid0)->has_match_for(tie_cvt_reg_nt)) {
    val = tie_cvt_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  } else {
    FmtAssert(MTYPE_is_tie(value_mtype),
		 ("Dynamic istore rules without conversion used for non-TIE"));
    val = tie_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  }
  Generate_Store_Memory(n, value_mtype, val, addr, WN_offset(n), Variant_ISTORE(n), ops );
  return val;
};

static bool
mtype_need_paired_tn(TYPE_ID mtype) {
  switch (mtype) {
    case MTYPE_I8:
    case MTYPE_U8:
	return TRUE;
  }
  return FALSE;
}

static bool
tie_rtor_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  if (mtype_need_paired_tn(src_mtype) ||
      mtype_need_paired_tn(dst_mtype))
    return FALSE;

  TIE_MACRO_p rtor_macro = tie_info->mtype_rtor_macro(src_mtype,dst_mtype);
  if (rtor_macro==NULL)
    return FALSE;

  ISEL::Nonterm reg_nt = ISEL::find_nonterm(find_nonterm_name(src_mtype));

  WN* value = WN_kid0(n);
  if (ISEL::match(value, reg_nt, c1)) {
    c = c1;
    c.cost+= rtor_macro->num_instructions();
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_rtor_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);
  TIE_MACRO_p rtor_macro = tie_info->mtype_rtor_macro(src_mtype,dst_mtype);

  FmtAssert(rtor_macro,("Missing rtor macro"));

  TN* in_operands[128];
  if (result==NULL)
    result=Build_TN_Of_Mtype(dst_mtype);

  TN* src_tn = action_by_type(WN_kid0(n), src_mtype, 0, ops);

  in_operands[0] = result;
  in_operands[1] = src_tn;

  expand_tie_macro_to_ops(ops, rtor_macro->id(), in_operands);

  return result;
}

static bool
tie_rtom_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  if (mtype_need_paired_tn(src_mtype) ||
      mtype_need_paired_tn(dst_mtype))
    return FALSE;

  TIE_MACRO_p rtom_macro = tie_info->mtype_rtom_macro(src_mtype,dst_mtype);
  if (rtom_macro==NULL)
    return FALSE;

  ISEL::Nonterm reg_nt = MTYPE_is_tie(src_mtype)?
			ISEL::find_nonterm("tie_reg") :
			ISEL::find_nonterm("areg");
  WN* value = WN_kid0(n);
  if (ISEL::match(value, reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_rtom_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID src_mtype = WN_desc(n);

  result = MTYPE_is_tie(src_mtype)?
		tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), result, ops):
		areg_action(ISEL::STATE_LABEL(WN_kid0(n)), result, ops);

  return result;
}

static bool
tie_mtor_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  if (mtype_need_paired_tn(src_mtype) ||
      mtype_need_paired_tn(dst_mtype))
    return FALSE;

  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
  if (mtor_macro==NULL)
    return FALSE;

  ISEL::Nonterm simm32_nt = ISEL::find_nonterm("simm32");
  WN* load = WN_kid0(n);
  if (WN_operator(load)==OPR_ILOAD &&
      WN_desc(load)==src_mtype &&
      tie_iload_rule_label(load, c1)) {
    c = c1;
    /* c.cost++; */
    /* cost is free here as it is included in the iload labelling */
    return TRUE;
  } else if (WN_operator(load)==OPR_LDID &&
	     WN_desc(load)==src_mtype && !is_preg(load) &&
	     tie_ldid_rule_label(load, c1)) {
    c = c1;
    /* c.cost++; */
    /* cost is free here as it is included in the ldid labelling */
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_mtor_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* cvt = _s->node;
  FmtAssert(WN_operator(cvt)==OPR_CVT,("Bad operator"));

  TYPE_ID src_mtype = WN_desc(cvt);
  TYPE_ID dst_mtype = WN_rtype(cvt);
  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);

  FmtAssert(mtor_macro,("Missing mtor macro"));

  WN* load = WN_kid0(cvt);
  FmtAssert(WN_operator(load)==OPR_ILOAD ||
	    WN_operator(load)==OPR_LDID,
	    ("Bad operator"));

  if (result==NULL)
    result=Build_TN_Of_Mtype(dst_mtype);
  FmtAssert((dst_mtype==TN_mtype(result)) ||
	    (TN_is_dedicated(result) &&
	     (TN_register_class(result) == TI_ISA_Regclass_For_Mtype(dst_mtype))),
	    ("Mtype mis-match, result = %s, dst_mtype = %s\n",
	     MTYPE_name(TN_mtype(result)), MTYPE_name(dst_mtype)));

  if (WN_operator(load)==OPR_ILOAD) {
    TN *addr;
    addr = areg_action(ISEL::STATE_LABEL(WN_kid0(load)), 0, ops);
    return Generate_Load_Memory(load, dst_mtype, src_mtype, result,
			      addr, WN_offset(load), Variant_ILOAD(load), ops);
  } else {
    return Generate_Load_Memory(load, dst_mtype, src_mtype, result,
			      WN_st(load), WN_load_offset(load), Variant_LDID(load), ops);
  }
}

static bool
tie_rtor_spill_rule_label(WN* n, COST &c) {

  COST c1;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);

  c = COST_INFINITY;

  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
  TIE_MACRO_p rtom_macro = tie_info->mtype_rtom_macro(src_mtype,dst_mtype);
  if (mtor_macro==NULL && rtom_macro==NULL)
    return FALSE;

  ISEL::Nonterm reg_nt = MTYPE_is_tie(src_mtype)?
			ISEL::find_nonterm("tie_reg"):
			  (mtype_need_paired_tn(src_mtype)?
				ISEL::find_nonterm("ll_cvt_areg"):
				ISEL::find_nonterm("areg"));
  ISEL::Nonterm simm32_nt = ISEL::find_nonterm("simm32");
  WN* kid0 = WN_kid0(n);
  if (mtor_macro && ISEL::match(kid0, simm32_nt, c1)) {
    /* if the value can be put in literal pool to save a store */
    c = c1;
    c.cost+=100;
    return TRUE;
  } else if (ISEL::match(kid0, reg_nt, c1)) {
    c = c1;
    c.cost+=100;
    return TRUE;
  } else {
    return FALSE;
  }
}

static TN*
tie_rtor_spill_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID src_mtype = WN_desc(n);
  TYPE_ID dst_mtype = WN_rtype(n);
  TIE_MACRO_p mtor_macro = tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
  TIE_MACRO_p rtom_macro = tie_info->mtype_rtom_macro(src_mtype,dst_mtype);

  FmtAssert(mtor_macro || rtom_macro, ("Missing rtor with spill macro"));

  TN* in_operands[128];

  ISEL::Nonterm simm32_nt = ISEL::find_nonterm("simm32");
  ISEL::Nonterm ll_cvt_areg_nt = ISEL::find_nonterm("ll_cvt_areg");
  WN* kid0 = WN_kid0(n);
  TN* dst;
  TN* src;
  TN* src_1 = NULL; /* for paired tn if needed */
  TN* dst_1 = NULL; /* for paired tn if needed */
  char buffer[256];

  if (mtype_need_paired_tn(dst_mtype)) {
    FmtAssert(dst_mtype==MTYPE_I8 || dst_mtype==MTYPE_U8, ("Unknown type"));
    TYPE_ID new_dst_mtype=(dst_mtype==MTYPE_I8)?MTYPE_I4:MTYPE_U4;
    if (result==NULL)
      result=Build_TN_Of_Mtype(new_dst_mtype);
    dst=result;
    dst_1=Build_TN_Of_Mtype(new_dst_mtype);
  } else {
    if (result==NULL)
      result=Build_TN_Of_Mtype(dst_mtype);
    dst=result;
  }

  if (MTYPE_is_tie(src_mtype)) {
    src = tie_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  } else if (src_mtype == MTYPE_F4 && xt_hard_float) {
    src = freg_action(ISEL::STATE_LABEL(kid0), 0, ops);
  } else {
    if (mtor_macro && ISEL::STATE_LABEL(kid0)->has_match_for(simm32_nt)) {
      ST* lc;
      src = simm32_action(ISEL::STATE_LABEL(kid0));
      lc = Generate_Literal_Tie(src_mtype, TN_value(src));
      if (MTYPE_is_tie(dst_mtype)) {
	Generate_Load_Memory(0, dst_mtype, src_mtype, dst, lc, 0, 0, ops );
      } else {
	/* cannot use dst_mtype as result type as it can be I1/U1/I2/U2 */
        TYPE_ID int_rtype = Mtype_TransferSize(MTYPE_U4, dst_mtype);
        Generate_Load_Memory(0, int_rtype, src_mtype, dst, lc, 0, 0, ops );
      }
      return result;
    } else if (ISEL::STATE_LABEL(kid0)->has_match_for(ll_cvt_areg_nt)) {
      src = ll_cvt_areg_action(ISEL::STATE_LABEL(kid0), 0, ops);
    } else {
      src = areg_action(ISEL::STATE_LABEL(kid0), 0, ops);
    }
  }

  if (mtor_macro) {
    sprintf(buffer, "mtor_spill_%s", MTYPE_name(src_mtype));
    ST* temp_st = Gen_Temp_Symbol(MTYPE_To_TY(src_mtype), buffer);
    Allocate_Temp_To_Memory(temp_st);
    if (mtype_need_paired_tn(src_mtype)) {
      FmtAssert(src_mtype==MTYPE_I8 || src_mtype==MTYPE_U8, ("Unknown type"));
      TYPE_ID new_src_mtype=(src_mtype==MTYPE_I8)?MTYPE_I4:MTYPE_U4;
      src_1=get_reg_tn_pair(src);
      FmtAssert(src_1,("Missing register pair"));
      if (Target_Byte_Sex == BIG_ENDIAN) {
	Generate_Store_Memory (0, new_src_mtype, src, temp_st, 4, 0, ops);
	Generate_Store_Memory (0, new_src_mtype, src_1, temp_st, 0, 0, ops);
      } else {
	Generate_Store_Memory (0, new_src_mtype, src, temp_st, 0, 0, ops);
	Generate_Store_Memory (0, new_src_mtype, src_1, temp_st, 4, 0, ops);
      }
    } else {
      Generate_Store_Memory (0, src_mtype, src, temp_st, 0, 0, ops);
    }
    Generate_Load_Memory  (0, dst_mtype, src_mtype, dst, temp_st, 0, 0, ops );
  } else {
    sprintf(buffer, "rtom_spill_%s", MTYPE_name(dst_mtype));
    ST* temp_st = Gen_Temp_Symbol(MTYPE_To_TY(dst_mtype), buffer);
    Allocate_Temp_To_Memory(temp_st);
    Generate_Store_Memory (0, dst_mtype, src, temp_st, 0, 0, ops);
    if (mtype_need_paired_tn(dst_mtype)) {
      FmtAssert(dst_mtype==MTYPE_I8 || dst_mtype==MTYPE_U8, ("Unknown type"));
      TYPE_ID new_dst_mtype=(dst_mtype==MTYPE_I8)?MTYPE_I4:MTYPE_U4;
      FmtAssert(dst_1,("Missing register pair"));
      if (Target_Byte_Sex == BIG_ENDIAN) {
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst,temp_st,4,0,ops );
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst_1,temp_st,0,0,ops );
      } else {
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst,temp_st,0,0,ops );
	Generate_Load_Memory(0,new_dst_mtype,new_dst_mtype,dst_1,temp_st,4,0,ops );
      }
      set_reg_tn_pair(dst,dst_1);
    } else {
      if (MTYPE_is_tie(dst_mtype)) {
	Generate_Load_Memory(0, dst_mtype, dst_mtype, dst, temp_st, 0, 0, ops );
      } else {
	/* cannot use dst_mtype as result type as it can be I1/U1/I2/U2 */
        TYPE_ID int_rtype = Mtype_TransferSize(MTYPE_U4, dst_mtype);
	Generate_Load_Memory(0, int_rtype, dst_mtype, dst, temp_st, 0, 0, ops );
      }
    }
  }

  return result;
}

static bool
tie_outpart_rule_label(WN* n, COST &c) {

  COST c1;
  WN* kid = WN_kid0(n);
  TYPE_ID kid_mtype = WN_rtype(kid);
  ISEL::Nonterm reg_nt = ISEL::find_nonterm("tie_reg");

  /* we allow OUTPART(LDID) or OUTPART(INTRINISIC_OP)
     the second kind is normally a result of copy propagation from WOPT
  */
  if (!MTYPE_is_tie_packed(kid_mtype) ||
      (!(WN_operator(kid)==OPR_LDID && is_preg(kid)) &&
       !(WN_operator(kid)==OPR_INTRINSIC_OP))) {
    c = COST_INFINITY;
    return FALSE;
  } else if (ISEL::match(kid, reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else {
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_outpart_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  WN* kid = WN_kid0(n);
  int outpart = WN_outpart(n);
  TYPE_ID kid_rtype = WN_rtype(kid);
  TYPE_ID value_mtype = tie_info->get_scalar_mtype(kid_rtype, outpart-1);

  TN *src = tie_reg_action(ISEL::STATE_LABEL(kid), 0, ops);
  TN *value = PREG_To_TN(MTYPE_To_PREG(value_mtype),TN_To_PREG(src)+(outpart-1));
  FmtAssert(value_mtype==TN_mtype(value),("Mtypes mismatch"));
  if (result) {
    FmtAssert(((TN_is_dedicated(result) ||
		TN_register_class(result)==TI_ISA_Regclass_Integer()) &&
	       TN_register_class(result)==TN_register_class(value)) ||
	      TN_mtype(result)==TN_mtype(value),("Mtypes mismatch"));
    return Move_To_Register(value_mtype,result,value,ops);
  } else {
    return value;
  }
}

static bool
tie_stid_rule_label(WN* n, COST &c) {

  TYPE_ID value_mtype = WN_desc(n);
  COST c1;
  WN* value = WN_kid0(n);
  ISEL::Nonterm reg_nt = MTYPE_is_tie(value_mtype)?
			ISEL::find_nonterm("tie_reg"):
			ISEL::find_nonterm("areg");
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");

  if (!is_preg(n) && ISEL::match(value, tie_cvt_reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else if (ISEL::match(value, reg_nt, c1)) {
    c = c1;
    return TRUE;
  } else {
    c = COST_INFINITY;
    return FALSE;
  }
}

static TN*
tie_stid_rule_action(ISEL::State* _s, TN* result, OPS* ops) {

  WN* n = _s->node;
  TYPE_ID value_mtype = WN_desc(n);
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  WN* kid0 = WN_kid0(n);

  Is_True( result==0, ("Requesting result from store"));

  if (MTYPE_is_tie_packed(value_mtype)) {
    FmtAssert(is_preg(n),
	("Expecting PREG of type '%s'", MTYPE_name(value_mtype)));
    ST *s = WN_st(n);
    INT64 o = WN_store_offset(n);
    TN *dst = PREG_To_TN(s,o);
    dst = tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), dst, ops);
    return dst;
  } else if (is_preg(n)) {
    Check_For_Dedicated_Preg(n);
    ST *s = WN_st(n);
    INT64 o = WN_store_offset(n);
    TN *dst = PREG_To_TN(s,o);
    dst = MTYPE_is_tie(value_mtype)?
    		tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), dst, ops):
    		areg_action(ISEL::STATE_LABEL(WN_kid0(n)), dst, ops);
    return dst;
  } else {
    Check_For_Dedicated_Preg(n);
    TN *val;
    if (ISEL::STATE_LABEL(kid0)->has_match_for(tie_cvt_reg_nt)) {
      val = tie_cvt_reg_action(ISEL::STATE_LABEL(kid0), 0, ops);
    } else {
      val = MTYPE_is_tie(value_mtype)?
    		tie_reg_action(ISEL::STATE_LABEL(WN_kid0(n)), 0, ops):
    		areg_action(ISEL::STATE_LABEL(WN_kid0(n)), 0, ops);
    }
    Generate_Store_Memory( n, value_mtype, val, WN_st(n), WN_store_offset(n), Variant_STID(n), ops);
    return val;
  }

}

static void
add_isel_rule_for_tie_type(TYPE_ID mtype_id) {

  if (MTYPE_is_tie(mtype_id)==FALSE)
    return;

  ISEL::Nonterm stmt_nt = ISEL::find_nonterm("stmt");
  ISEL::Nonterm tie_reg_nt = ISEL::find_nonterm("tie_reg");

  OPCODE tie_ldid_opc = OPCODE_make_op(OPR_LDID, mtype_id, mtype_id);
  OPCODE tie_stid_opc = OPCODE_make_op(OPR_STID, MTYPE_V, mtype_id);
  OPCODE tie_iload_opc = OPCODE_make_op(OPR_ILOAD, mtype_id, mtype_id);
  OPCODE tie_istore_opc = OPCODE_make_op(OPR_ISTORE, MTYPE_V, mtype_id);
  OPCODE tie_select_opc = OPCODE_make_op(OPR_SELECT, mtype_id, MTYPE_V);
  OPCODE tie_call_opc = OPCODE_make_op(OPR_CALL, mtype_id, MTYPE_V);

  ISEL::Rule tie_ldid_rule =
	ISEL::add_rule((int)tie_ldid_opc, tie_reg_nt, 0, tie_ldid_rule_label);
  ISEL::add_tie_reg_action(tie_ldid_rule, tie_ldid_rule_action);

  ISEL::Rule tie_stid_rule =
	ISEL::add_rule((int)tie_stid_opc, stmt_nt, 1, tie_stid_rule_label);
  ISEL::add_stmt_action(tie_stid_rule, tie_stid_rule_action);

  /* packed mtype for TIE needs only ldid/stid rules */
  if (MTYPE_is_tie_packed(mtype_id)) {
    return;
  }

  ISEL::Rule tie_iload_rule =
	ISEL::add_rule((int)tie_iload_opc, tie_reg_nt, 1, tie_iload_rule_label);
  ISEL::add_tie_reg_action(tie_iload_rule, tie_iload_rule_action);

  ISEL::Rule tie_istore_rule =
	ISEL::add_rule((int)tie_istore_opc, stmt_nt, 2, tie_istore_rule_label);
  ISEL::add_stmt_action(tie_istore_rule, tie_istore_rule_action);

  ISEL::Rule tie_select_rule =
	ISEL::add_rule((int)tie_select_opc, tie_reg_nt, 3, tie_select_rule_label);
  ISEL::add_tie_reg_action(tie_select_rule, tie_select_rule_action);

  ISEL::Rule tie_call_rule =
	ISEL::add_rule((int)tie_call_opc, stmt_nt, 0, tie_call_rule_label);
  ISEL::add_stmt_action(tie_call_rule, tie_call_rule_action);
}

static void
add_isel_rule_for_tie_macros() {

  ISEL::Nonterm areg_nt = ISEL::find_nonterm("areg");
  ISEL::Nonterm freg_nt = ISEL::find_nonterm("freg");
  ISEL::Nonterm b1reg_nt = ISEL::find_nonterm("b1reg");
  ISEL::Nonterm breg_nt = ISEL::find_nonterm("breg");
  ISEL::Nonterm stmt_nt = ISEL::find_nonterm("stmt");
  ISEL::Nonterm tie_reg_nt = ISEL::find_nonterm("tie_reg");
  ISEL::Nonterm tie_cvt_reg_nt = ISEL::find_nonterm("tie_cvt_reg");
  TYPE_ID mtype_id;
  TIE_MACRO_ID tie_macro_id;

  FmtAssert(Mtype_Last<MTYPE_MAX,("Too many (>%d) mtypes\n",MTYPE_MAX));
  bool mtype_has_tie_intrinsic_op[MTYPE_MAX];
  bool mtype_has_tie_outpart[MTYPE_MAX];

  for (mtype_id=1; mtype_id<=Mtype_Last; mtype_id++) {
    mtype_has_tie_intrinsic_op[mtype_id]=false;
    mtype_has_tie_outpart[mtype_id]=false;
  }

  for (tie_macro_id=0; tie_macro_id<tie_info->num_macros(); tie_macro_id++) {

    TIE_MACRO_p tie_macro = tie_info->tie_macro(tie_macro_id);
    if (tie_macro->is_whirl_intrinsic_op()) {
      mtype_id = tie_macro->output_mtype(tie_info);
      if (mtype_id==MTYPE_I1 || mtype_id ==MTYPE_I2)
	mtype_id=MTYPE_I4;
      else if (mtype_id==MTYPE_U1 || mtype_id ==MTYPE_U2)
	mtype_id=MTYPE_U4;
      mtype_has_tie_intrinsic_op[mtype_id]=true;

      if (MTYPE_is_tie_packed(mtype_id)) {
	for (int i=0; i<tie_info->num_scalar_mtypes(mtype_id); i++) {
	  TYPE_ID scalar_mtype = tie_info->get_scalar_mtype(mtype_id,i);

	  if (scalar_mtype==MTYPE_I1 || scalar_mtype==MTYPE_I2)
	    scalar_mtype = MTYPE_I4;
	  else if (scalar_mtype==MTYPE_U1 || scalar_mtype==MTYPE_U2)
	    scalar_mtype = MTYPE_U4;

	  mtype_has_tie_outpart[scalar_mtype]=true;
	}
      }
    }
  }

  for (mtype_id=1; mtype_id<=Mtype_Last; mtype_id++) {
    if (mtype_has_tie_intrinsic_op[mtype_id] && (mtype_id != MTYPE_V)) {
      OPCODE tie_intr_op_opc =
		OPCODE_make_op(OPR_INTRINSIC_OP, mtype_id, MTYPE_V);
      ISEL::Rule tie_intr_op_rule;
      if (MTYPE_is_tie(mtype_id)) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, tie_reg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_tie_reg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else if (mtype_id==MTYPE_XTBOOL) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, b1reg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_areg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else if (MTYPE_is_xtbool(mtype_id)) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, breg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_areg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else if (MTYPE_is_float(mtype_id) && xt_hard_float) {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, freg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_tie_reg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      } else {
	tie_intr_op_rule=ISEL::add_rule(
		(int)tie_intr_op_opc, areg_nt, 0, tie_intr_op_rule_label);
        ISEL::add_tie_reg_action(tie_intr_op_rule, tie_intr_op_rule_action);
      }
    }
    if (mtype_has_tie_outpart[mtype_id]) {
      OPCODE tie_outpart_opc = OPCODE_make_op(OPR_OUTPART, mtype_id, MTYPE_V);
      ISEL::Rule tie_outpart_rule;
      if (MTYPE_is_tie(mtype_id)) {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, tie_reg_nt, 0, tie_outpart_rule_label);
        ISEL::add_tie_reg_action(tie_outpart_rule, tie_outpart_rule_action);
      } else if (mtype_id==MTYPE_XTBOOL) {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, b1reg_nt, 0, tie_outpart_rule_label);
        ISEL::add_areg_action(tie_outpart_rule, tie_outpart_rule_action);
      } else if (MTYPE_is_xtbool(mtype_id)) {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, breg_nt, 0, tie_outpart_rule_label);
        ISEL::add_areg_action(tie_outpart_rule, tie_outpart_rule_action);
      } else {
	tie_outpart_rule=ISEL::add_rule(
		(int)tie_outpart_opc, areg_nt, 0, tie_outpart_rule_label);
        ISEL::add_tie_reg_action(tie_outpart_rule, tie_outpart_rule_action);
      }
    }
  }

  TYPE_ID src_mtype;
  TYPE_ID dst_mtype;
  ISEL::Nonterm reg_nt;
  for (src_mtype=1; src_mtype<=Mtype_Last; src_mtype++)
    for (dst_mtype=1; dst_mtype<=Mtype_Last; dst_mtype++)
      if ((MTYPE_is_tie(src_mtype) || MTYPE_is_tie(dst_mtype)) &&
	  !(MTYPE_is_tie_packed(src_mtype) || MTYPE_is_tie_packed(dst_mtype))) {
	TIE_MACRO_p rtor_macro=tie_info->mtype_rtor_macro(src_mtype,dst_mtype);
	TIE_MACRO_p rtom_macro=tie_info->mtype_rtom_macro(src_mtype,dst_mtype);
	TIE_MACRO_p mtor_macro=tie_info->mtype_mtor_macro(src_mtype,dst_mtype);
	ISEL::Rule tie_cvt_rule;
	if (MTYPE_is_tie(dst_mtype))
	  reg_nt = tie_reg_nt;
	else
	  reg_nt = areg_nt;
	OPCODE tie_cvt_opc =
		OPCODE_make_op(OPR_CVT, dst_mtype, src_mtype);
	if (rtor_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, reg_nt, 1, tie_rtor_rule_label);
          ISEL::add_tie_reg_action(tie_cvt_rule, tie_rtor_rule_action);
	}
	if (rtom_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, tie_cvt_reg_nt, 1, tie_rtom_rule_label);
          ISEL::add_tie_cvt_reg_action(tie_cvt_rule, tie_rtom_rule_action);
	  if (MTYPE_is_tie(dst_mtype)==false) {
	     /* a rtom conversion from TIE to non-TIE */
  	     OPCODE istore_opc =
			OPCODE_make_op(OPR_ISTORE, MTYPE_V, dst_mtype);
	     ISEL::Rule tie_istore_rule =
			ISEL::add_rule((int)istore_opc, stmt_nt, 2,
				       tie_istore_rule_label);
	     ISEL::add_stmt_action(tie_istore_rule, tie_istore_rule_action);
	  }
	}
	if (mtor_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, reg_nt, 1, tie_mtor_rule_label);
          ISEL::add_tie_reg_action(tie_cvt_rule, tie_mtor_rule_action);
	}
	if (mtor_macro!=NULL || rtom_macro!=NULL) {
	  tie_cvt_rule=ISEL::add_rule(
		(int)tie_cvt_opc, reg_nt, 1, tie_rtor_spill_rule_label);
          ISEL::add_tie_reg_action(tie_cvt_rule, tie_rtor_spill_rule_action);
	}
      }
}

static void
asm_action_callback (WN *n, TN *result, OPS *ops)
{
#if 0
  fPrint_TN(stderr, "callback: result %s, tree:\n", result);
  fdump_tree(stderr, n);
#endif
  
  /* whirl2ops.cxx:Handle_ASM will call back here for us to generate
     ops to evaluate 'n' into 'result'. */
  action_by_type(n, WN_rtype(n), result, ops);
}


void ISEL_initialize(void)
{
  static int initialized=0;

  if( !initialized ) {

    MEM_POOL_Initialize(&ISEL_Mem_Pool,"Instruction Selection", TRUE);
    MEM_POOL_Initialize(&ISEL_Map_Pool,"Instruction Selection", TRUE);
    MEM_POOL_Push(&ISEL_Mem_Pool);
    MEM_POOL_Push(&ISEL_Map_Pool);

    ISEL::initialize();
    for (TYPE_ID i=MTYPE_CORE_LAST+1; i<=Mtype_Last; i++)
      if (MTYPE_is_tie(i))
        add_isel_rule_for_tie_type(i);

    add_isel_rule_for_tie_macros();

    initialized=1;
  }
  ISEL_State_Map = WN_MAP_Create(&ISEL_Map_Pool);

}

void ISEL_finalize(void)
{
  WN_MAP_Delete(ISEL_State_Map);

  // should pop and delete in the last finalize but cannot detect that
  // MEM_POOL_Pop(&ISEL_Mem_Pool);
  // MEM_POOL_Pop(&ISEL_Map_Pool);
  // MEM_POOL_Delete(&ISEL_Mem_Pool);
  // MEM_POOL_Delete(&ISEL_Map_Pool);
}

bool
ISEL_gen(WN *stmt, TN *result, OPS *ops)
{
  extern void debug();
  bool res;
  OPCODE opc;

  Is_True( result==0 || TN_is_register(result), ("Result tn not a register"));

  opc = WN_opcode(stmt);
  switch( opc ) {
  case OPC_PRAGMA:
  case OPC_XPRAGMA:
    /* We want the preamble to be in it's own BB initially, to help in
       recognizing FP_TN uses that are referencing the incoming
       argument from FP_TN uses as the frame pointer. */
    if (WN_pragma(stmt) == WN_PRAGMA_PREAMBLE_END)
    {
      BB *cur_bb = Get_Cur_BB();
      BB *new_bb = Start_New_Basic_Block();
      if (cur_bb != new_bb)
        Link_Pred_Succ(cur_bb, new_bb);
      Set_BB_end_preamble(Get_Cur_BB());
    }
    return false;

  case OPC_COMMENT:
  case OPC_RETURN:
  case OPC_LABEL:
    return false;
  }

  ISEL_Initialize_For_Tree();

  //fprintf(stderr, "\n\n *** lowering ***\n\n");
  //fdump_tree(stderr, stmt);

  try {
    res = (ISEL::label(stmt) != 0 );
    if( !res ) {
      if (WN_operator(stmt) == OPR_ASM_STMT) {
        ErrMsgSrcpos(EC_Inv_Asm_Opnd, WN_Get_Linenum(stmt));
      } else {
        fdump_tree(stderr, stmt);
        FmtAssert(FALSE, ("no cover"));
      }
    } else {
      (void) stmt_action(ISEL::STATE_LABEL(stmt),result,ops);
    }
  }
  catch(ISEL::Exception e) {
    if (WN_operator(stmt) == OPR_ASM_STMT) {
      ErrMsgSrcpos(EC_Inv_Asm_Opnd, WN_Get_Linenum(stmt));
    } else { 
      if (e.node) {
        fprintf(stderr, "node =\n");
        fdump_tree(stderr, e.node);
      }
      fprintf(stderr, "tree =\n");
      fdump_tree(stderr, stmt);
      FmtAssert(FALSE, ("ISEL error: %s\n", e.reason));
    }
  }

  ISEL_Finalize_For_Tree();
  return res;
}

// Local Variables:
// mode: c++
// c-style-variables-are-local-p: t
// c-file-style: "mongoose"
// End:
